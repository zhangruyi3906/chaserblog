<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-11%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-11%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>本次直播内容：</p><ol><li>上次直播问题总结✔</li><li>用户库表设计✔</li><li>完成登录注册的前后端开发</li><li>完成用户管理后台的前后端开发</li><li>其他（根据时间弹性安排）</li></ol><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min</p><ol><li>后端       20min <ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min</li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol><li>前端</li><li>后端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><hr><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>本次直播内容：</p><ol><li>上次直播问题总结✔</li><li>用户库表设计✔</li><li>完成登录注册的前后端开发</li><li>完成用户管理后台的前后端开发</li><li>其他（根据时间弹性安排）</li></ol><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-25%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E7%BB%88%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-25%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E7%BB%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>终 - 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p><strong>登录 &#x2F; 注册</strong> 20min</p><ol><li>前端</li><li>后端</li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol><li>前端</li><li>后端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-03%20%E5%B0%9D%E9%B2%9CAI%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6Copilot%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/2022-04-03%20%E5%B0%9D%E9%B2%9CAI%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6Copilot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="体验-AI-自动写代码插件-Copilot"><a href="#体验-AI-自动写代码插件-Copilot" class="headerlink" title="体验 AI 自动写代码插件 Copilot"></a>体验 AI 自动写代码插件 Copilot</h1><p>基于 GitHub 上开源的亿级别的代码，训练 AI 模型，自动生成代码。</p><p>数据量能够决定你 AI 模型精度的上限</p><p>而算法是帮助你不断逼近这个上限</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>自动补全</li><li>根据注释自动生成代码</li><li>自动推断、生成类似的代码</li><li>自动生成测试</li><li>自动生成代码建议，提供选择</li></ol><p>根据注释生成注释？</p><p>插件支持 VS Code、JetBrains 全家桶、Visual Studio</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>申请（<a href="https://copilot.github.com/%EF%BC%89">https://copilot.github.com/）</a></p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><ol><li>逻辑类代码（比如校验，80 分）</li><li>重复代码量越少，推荐越不准</li><li>固定格式的、通用的代码（java 40 分）大家写来写去都是一样的 &#x2F; 类似的代码</li><li>业务逻辑（用处不大)</li></ol><p>提示代码的准确度和模型本身、模型分析依赖的环境 &#x2F; 上下文有关。</p><p>以前：写代码，查百度，开发者</p><p>现在：写注释，翻生成的代码是否靠谱，监管者</p><p><strong>AI 辅助程序员</strong></p><p>自己能掌控代码再用</p><p>适合一些工具类（日期转换、对象转化，校验），提高效率 &#x3D;&gt; 不要拿来生成一些本来就看不懂的代码</p><p>不要在企业和敏感项目中使用，可能有安全隐患！</p><p>欢迎加入鱼皮的编程知识星球：dogyupi.com</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%AB%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-04-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>末 - 直播内容</p><ol><li>开发用户注销前端 7 分钟 &#x2F; 后端 3 分钟 √</li><li>补充用户注册校验逻辑前端 10 分钟 &#x2F; 后端 10 分钟 √</li><li>后端代码优化 20 - 30 min</li><li>前端代码优化 5 - 10 min</li><li>项目部署上线 1h<ol><li>买服务器   10 min</li><li>原生部署20 - 30 min</li><li>容器部署    20 - 30 min</li><li>绑定域名    5 min</li><li><strong>排查问题</strong></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%E7%BA%BF%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-04-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%E7%BA%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>GitLab 地址：<a href="http://gitlab.code-nav.cn/">http://gitlab.code-nav.cn/</a></p><p>部署 - 直播内容</p><ol><li>多环境 5 - 10min</li><li>项目部署上线 1h √<ul><li>原始前端 &#x2F; 后端项目</li><li>宝塔 Linux </li><li>容器</li><li>容器平台</li></ul></li><li>前后端的联调 —— 跨域 15 min</li><li>用户中心项目扩展和规划（优化点）5 - 10 min</li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端部署方式"><a href="#前端部署方式" class="headerlink" title="前端部署方式"></a>前端部署方式</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 后端</span><br><span class="hljs-attribute">docker</span> build -t user-center-backend:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br><br><span class="hljs-comment"># 前端</span><br><span class="hljs-attribute">docker</span> build -t user-center-front:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>前端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; </p><p>服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如果解决跨域</p><ol><li>把域名、端口改成相同的</li></ol><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><ol start="2"><li><p>网关支持（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改后端服务</p><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-17%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E9%83%A8%E7%BD%B2%EF%BC%89%20/"/>
    <url>/chaserblog/2024/04/28/2022-04-17%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E9%83%A8%E7%BD%B2%EF%BC%89%20/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>GitLab 地址：<a href="http://gitlab.code-nav.cn/">http://gitlab.code-nav.cn/</a></p><p>部署 - 直播内容</p><ol><li>多环境 5 - 10min</li><li>项目部署上线 1h √<ul><li>原始前端 &#x2F; 后端项目</li><li>宝塔 Linux </li><li>容器</li><li>容器平台</li></ul></li><li>前后端的联调 —— 跨域 15 min</li><li>用户中心项目扩展和规划（优化点）5 - 10 min</li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端部署方式"><a href="#前端部署方式" class="headerlink" title="前端部署方式"></a>前端部署方式</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 后端</span><br><span class="hljs-attribute">docker</span> build -t user-center-backend:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br><br><span class="hljs-comment"># 前端</span><br><span class="hljs-attribute">docker</span> build -t user-center-front:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>前端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; </p><p>服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如果解决跨域</p><ol><li>把域名、端口改成相同的</li></ol><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><ol start="2"><li><p>网关支持（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改后端服务</p><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024.4-28学习笔记</title>
    <link href="/chaserblog/2024/04/28/2024.4.28/"/>
    <url>/chaserblog/2024/04/28/2024.4.28/</url>
    
    <content type="html"><![CDATA[<p>(<a href="https://blog.fiveth.cc/p/bb32.html">如何用Hexo搭建个人博客? | Fiveth</a>)</p><p>优点<br>1、不需要服务器，github免费提供的托管服务<br>2、不需要域名，github同样提供了一个.io的域名<br>3、不用自己写xml、<a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a>提供了很多开源的博客模板。<br>4、便于维护更新，换风格直接换模板就行。</p><p>问题：</p><p>使用github作为服务器时，repo包中我用https:*******这个输入账号和密码一直显示连接错误</p><p>我改为用ssh连接时就好了。</p><p>配置SSH Key<br>注册完之后需要添加 SSH Key。 SSH Key是一个认证，让github识别绑定这台机器，允许这台机器无需密码提交，修改项目。执行如下命令：</p><p>生产新的SSH Key配置<br>在Git Bash(在任意文件夹中鼠标右击选择Git Bash Here打开)执行代码：</p><p><code>ssh-keygen -t rsa -C &quot;xxxxxxxxx@qq.com&quot;</code><br>上面的邮箱记得修改成你自己的，成功后会生成两个文件id_rsa（私钥） 以及id_rsa.pub（公钥）。 然后找到这两个文件，默认都在C盘 &gt; 用户 &gt; xxx &gt; .ssh 里面（xxx是计算机名字，我这里是Administrator）</p><p><img src="https://img-blog.csdnimg.cn/648d8c72050c46a9bf7f2dd252b57de6.png" alt="img"></p><p>然后用文本编辑器把id_rsa_pub（公钥）这个文件打开，全选复制出来； 然后打开在github上添加SSH Key，登录github账号，点击右上角用户头像，选择setting（设置）&gt; SSH and GPG keys &gt; NewSSH key</p><p><img src="https://img-blog.csdnimg.cn/1afa3b66e2114b5ba795545fa1bad8b0.png" alt="img"></p><p>然后把刚才复制的内容粘贴到key这里就可以了.</p><p>3.1. 测试是否成功<br><code>$ ssh -T git@github.com</code> # 注意邮箱地址不用改<br>复制</p><p>如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p><code>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</code></p><p>看到这个信息说明SSH已配置成功！<br>————————————————</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428085806628.png" alt="image-20240428085806628"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428090043539.png" alt="image-20240428090043539"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428132801443.png" alt="image-20240428132801443"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428132842085.png" alt="image-20240428132842085"></p><p>搭建个人博客</p><h1 id="项目展示】"><a href="#项目展示】" class="headerlink" title="项目展示】"></a>项目展示】</h1><blockquote><p>【展示地址】：<a href="https://zhangruyi3906.github.io/chaserblog/">chaserblog | 我的博客 (zhangruyi3906.github.io)</a>【注册、下载与安装】</p></blockquote><h2 id="【1】gitee注册"><a href="#【1】gitee注册" class="headerlink" title="【1】gitee注册"></a>【1】gitee注册</h2><blockquote><p>【gitee官方注册地址】：<a href="https://gitee.com/signup">https://gitee.com/signup</a></p></blockquote><h2 id="【2】Typora下载"><a href="#【2】Typora下载" class="headerlink" title="【2】Typora下载"></a>【2】Typora下载</h2><blockquote><p>【下载地址】：<a href="https://www.typora.io/">https://www.typora.io/</a></p></blockquote><h2 id="【3】node安装"><a href="#【3】node安装" class="headerlink" title="【3】node安装"></a>【3】node安装</h2><blockquote><p>【下载地址】：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>【安装过程】：选择磁盘可以切换到其他盘，然后一直下一步就好了。（这里演示是切换D盘）</p></blockquote><h2 id="【4】git安装"><a href="#【4】git安装" class="headerlink" title="【4】git安装"></a>【4】git安装</h2><blockquote><p>【下载地址】：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>【安装过程】：选择磁盘可以切换到其他盘，然后一直下一步就好了。（这里演示是切换D盘）</p></blockquote><h1 id="【本地博客搭建】"><a href="#【本地博客搭建】" class="headerlink" title="【本地博客搭建】"></a>【本地博客搭建】</h1><h2 id="【1】hexo-cli安装"><a href="#【1】hexo-cli安装" class="headerlink" title="【1】hexo-cli安装"></a>【1】hexo-cli安装</h2><blockquote><p>npm install hexo-cli -g</p><p>或</p><p>先安装cnpm，然后利用cnpm安装hexo-cli</p><p>npm install cnpm</p><p>cnpm install hexo-cli -g</p></blockquote><h2 id="【2】初始化hexo项目"><a href="#【2】初始化hexo项目" class="headerlink" title="【2】初始化hexo项目"></a>【2】初始化hexo项目</h2><blockquote><p>hexo init blog</p></blockquote><h2 id="【3】项目启动"><a href="#【3】项目启动" class="headerlink" title="【3】项目启动"></a>【3】项目启动</h2><blockquote><p>永远的hexo三件套：</p><p>-清除生成的页面相关内容</p><p>hexo clean</p><p>-构建生成的页面相关内容</p><p>hexo g</p><p>-项目启动</p><p>hexo s</p></blockquote><p>会看到这样的页面，证明本地hexo默认模板配置成功，<br><img src="https://img-blog.csdnimg.cn/img_convert/b26252eb40bc11f27ab2808484f82dd0.png" alt="wapchief"><br>到这一步如果将hexo放到github page，那么使用github.io访问的将是一个默认的页面。下面我们要把他diy成自己的博客，包括导入模板主题等。</p><p>安装主题<br>关于主题大多都是以压缩包形式，可以去github上搜hexo theme，会出来很多，里面都有介绍。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d99c1f1811f3af2535ab2d92d869563b.png" alt="hexo-theme主题">比如我们比如我们要用第一个。<br>可以通过两种方法，这里我直接使用git命令完成，具体请参考next官方文档：<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a><br>继续在我们的本地hexo目录输入</p><p>git clone <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> themes&#x2F;next</p><h1 id="【添加主题模板Fluid】"><a href="#【添加主题模板Fluid】" class="headerlink" title="【添加主题模板Fluid】"></a>【添加主题模板Fluid】</h1><h2 id="【1】在blog-themes目录下"><a href="#【1】在blog-themes目录下" class="headerlink" title="【1】在blog\themes目录下"></a>【1】在blog\themes目录下</h2><blockquote><p>去gitee上下载Fluid主题模板（github上真的太慢了有时候还下不下来。）</p><p>git clone <a href="https://gitee.com/mirrors/hexo-theme-fluid.git">https://gitee.com/mirrors/hexo-theme-fluid.git</a></p></blockquote><h2 id="【2】修改-conf-yml"><a href="#【2】修改-conf-yml" class="headerlink" title="【2】修改_conf.yml"></a>【2】修改_conf.yml</h2><blockquote><p>找到theme，替换为对应下载主题名字（在themes下载下来的文件夹名）</p><p>theme: hexo-theme-fluid</p><p>此时我出现了以下问题：</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428144618381.png" alt="image-20240428144618381"></p></blockquote><p>不能够通过老老实实的安装上述提及的相关缺失的包来解决问题，</p><p>而是可以通过在命令行中输入npm install 这个命令来解决问题</p><p>这个方法简便且快速和高效。</p><h2 id="【3】修改为主题语言为中文"><a href="#【3】修改为主题语言为中文" class="headerlink" title="【3】修改为主题语言为中文"></a>【3】修改为主题语言为中文</h2><blockquote><p>在blog目录下的_conf.yml，找到文件内容里的language替换为以下</p><p>language: zh-CN #指定语言，会影响主题显示的语言，按需修改</p></blockquote><h2 id="【4】生成about页面"><a href="#【4】生成about页面" class="headerlink" title="【4】生成about页面"></a>【4】生成about页面</h2><blockquote><p>在blog路径下，执行指令（管理员cmd操作）</p><p>hexo new page about</p><p>创建成功后，去到blog\source\about\index.md，添加layout属性，以为为index.md里所有内容</p><p>-–<br>title: about<br>date: 2021-10-01 14:53:12<br>layout: about<br>-–</p></blockquote><p>修改内容<br>内容较多建议参考官方文档<br><a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a><br>修改完之后，可以重新执行hexo s在浏览器查看效果。并确认无误，包括以后需要添加文章，或者更新主题等，都建议先在本地查看无误再远程部署。<br>根_config.yml文件中</p><h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p><code>title: 网站标题</code><br><code>subtitle: 副标题</code><br><code>description: 个人签名</code><br><code>author: 姓名</code><br><code>language: zh-Hans</code><br><code>timezone:</code></p><h1 id="【图片、内容等修改】"><a href="#【图片、内容等修改】" class="headerlink" title="【图片、内容等修改】"></a>【图片、内容等修改】</h1><h2 id="【1】添加友链导航"><a href="#【1】添加友链导航" class="headerlink" title="【1】添加友链导航"></a>【1】添加友链导航</h2><blockquote><p>【参考地址】：<a href="https://hexo.fluid-dev.com/docs/guide/#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5">https://hexo.fluid-dev.com/docs/guide/#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5</a></p><p>在blog\themes\hexo-theme-fluid目录下的_config.yml内容中去掉 navbar导航栏 menu下的link 前的注释</p><p>menu:<br>- { key: “home”, link: “&#x2F;“, icon: “iconfont icon-home-fill” }<br>- { key: “archive”, link: “&#x2F;archives&#x2F;“, icon: “iconfont icon-archive-fill” }<br>- { key: “category”, link: “&#x2F;categories&#x2F;“, icon: “iconfont icon-category-fill” }<br>- { key: “tag”, link: “&#x2F;tags&#x2F;“, icon: “iconfont icon-tags-fill” }<br>- { key: “about”, link: “&#x2F;about&#x2F;“, icon: “iconfont icon-user-fill” }<br>- { key: “links”, link: “&#x2F;links&#x2F;“, icon: “iconfont icon-link-fill” }</p></blockquote><h2 id="【2】改页面标题和页面前的小icons"><a href="#【2】改页面标题和页面前的小icons" class="headerlink" title="【2】改页面标题和页面前的小icons"></a>【2】改页面标题和页面前的小icons</h2><blockquote><p>blog目录下的_config.yml的内容中</p><p>原来是有title: Hexo</p><p>改为title: 阿怼博客</p></blockquote><blockquote><p>blog\themes\hexo-theme-fluid\主题目录下的_config.yml的内容中</p><p>navbar:</p><p> blog_title: “Fluid”</p><p>改为</p><p>navbar:</p><p> blog_title: “阿怼博客”</p><p>同样文件，找到首页（index）</p><p>index:<br># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同<br># Path of Banner image, can be a relative path or an absolute path, the same on other pages<br>banner_img: &#x2F;img&#x2F;default.png</p><p># 头图高度，屏幕百分比<br># Height ratio of banner image<br># Available: 0 - 100<br>banner_img_height: 100</p><p># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明<br># Opacity of the banner mask, 1.0 is completely opaque<br># Available: 0 - 1.0<br>banner_mask_alpha: 0.3</p><p># 首页副标题的独立设置<br># Independent config of home page subtitle<br>slogan:<br>enable: true</p><p># 为空则按 hexo config.subtitle 显示<br># If empty, text based on <code>subtitle</code> in hexo config<br>text: “An elegant Material-Design theme for Hexo”</p><p>这里的text改成你想改的</p><p>text: “我叫阿怼，南方阿怼，一个热爱计算机更热爱祖国的南方人。”</p></blockquote><blockquote><p>修改icons或者其他图片，找到blog\themes\hexo-theme-fluid\source\img目录下（注意不是blog\public\img目录下的，public的目录文件不需要改，因为每次hexo clean都会删除了，然后hexo g再重新创建）</p><p>在这里面替换成你想要的图片、icon就好了。</p></blockquote><h1 id="【-md文件博客上传】"><a href="#【-md文件博客上传】" class="headerlink" title="【.md文件博客上传】"></a>【.md文件博客上传】</h1><blockquote><p>首先，写好一个.md，作为你的博客了。</p><p>也可以直接在blog目录下，执行以下指令生成.md，再进行对该.md进行完善内容。</p><p>hexo new “《我的第一个日记》”</p><p>这时候就生成在blog\source_posts目录下了</p><p>你已经写好了.md，也可以直接移动到这里，然后再重新启动hexo三件套就好了。（hexo clean、hexo g、hexo s）</p></blockquote><blockquote><p>标签添加</p><p>在你想添加标签的.md文件中，添加tags: “标签名”</p><p>-–<br>title: 《个人博客搭建》<br>date: 2021-10-01 15:35:44<br>tags: “《博客搭建相关》”<br>-–</p></blockquote><h1 id="【宠物插件】"><a href="#【宠物插件】" class="headerlink" title="【宠物插件】"></a>【宠物插件】</h1><blockquote><p>npm install –save hexo-helper-live2d<br>或<br>cnpm install –save hexo-helper-live2d</p><p>1、cnpm install –save hexo-helper-live2d<br>2、<a href="https://www.npmjs.com/package/hexo-helper-live2d">live2d插件</a><br>3、安装合适的宠物cnpm install live2d-widget-model-chitose<br>4、在博客_config.yml配置文件中（不是themes里的）添加即可</p></blockquote><h1 id="【提交搭建的博客到Gitee上，正式完成博客搭建】"><a href="#【提交搭建的博客到Gitee上，正式完成博客搭建】" class="headerlink" title="【提交搭建的博客到Gitee上，正式完成博客搭建】"></a>【提交搭建的博客到Gitee上，正式完成博客搭建】</h1><blockquote><p>修改blog_config.yml配置文件的站点地址（找到deploy）：</p><p>deploy:<br>type: git<br>repo:<br>branch: master<br>live2d: <a href="https://gitee.com/southern-adui/southern-adui.git">https://gitee.com/southern-adui/southern-adui.git</a><br>enable: true</p><p>安装git上传助手（如果有git设置过有帐号密码，就去先对git进行操作）</p><p>npm install hexo-deployer-git –save<br>或<br>cnpm install hexo-deployer-git –save</p><p>完成后，输入</p><p>hexo d</p></blockquote><blockquote><p>git的操作<br>查看配置信息： $ git config –list<br>修改用户名<br>git config –global user.name “xxxx(新的用户名)”<br>修改密码<br>git config –global user.password “xxxx(新的密码)”<br>修改邮箱<br>git config –global user.email “<a href="mailto:xxxx@xxx.com">xxxx@xxx.com</a>(新的邮箱)”<br>清除掉缓存在git中的用户名和密码<br>git credential-manager uninstall</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记+日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/yuwork-%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/yuwork-%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="开发记录和分析工作的工具"><a href="#开发记录和分析工作的工具" class="headerlink" title="开发记录和分析工作的工具"></a>开发记录和分析工作的工具</h1><blockquote><p>by 程序员鱼皮 <a href="https://yupi.icu/">知识星球</a></p><p>直播回放会发布到编程学习圈子：<a href="https://yupi.icu/">https://yupi.icu</a></p><p>直播回放 + 项目源码 + 笔记：<a href="https://t.zsxq.com/03J6URbem">https://t.zsxq.com/03J6URbem</a> （加入星球可见）</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>个人可以记录自己每日的工作、工作时长、工作打标签（工作进度、目标）</li><li>可以根据日历查看自己的工作（视图）</li><li>可以对一定周期内的工作进行分析（饼图、折线图、柱状图）</li></ol><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><h4 id="第一次开发"><a href="#第一次开发" class="headerlink" title="第一次开发"></a>第一次开发</h4><p>完整基本前后端搭建和联调，实现任务创建和查询功能</p><h4 id="第二次开发"><a href="#第二次开发" class="headerlink" title="第二次开发"></a>第二次开发</h4><ol><li>优化样式</li><li>分页检索</li></ol><h3 id="第三次开发"><a href="#第三次开发" class="headerlink" title="第三次开发"></a>第三次开发</h3><ol><li>增删改 <strong>查</strong>（搜索 &#x2F; 排序）</li></ol><h3 id="下次开发"><a href="#下次开发" class="headerlink" title="下次开发"></a>下次开发</h3><ol><li>登录</li><li>管理员分析，分析所有用户（指定范围用户）的工作情况</li><li>任务拖动</li><li>多种视图布局</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ol><li>前端：Vue 3 + Vite 2 + Ant Design Vue（桌面端为主）<ul><li>数据可视化：AntV G2</li><li>日期处理库：Day.js</li></ul></li><li>后端：SpringBoot + Redis 分布式登录</li></ol><h2 id="前端整合"><a href="#前端整合" class="headerlink" title="前端整合"></a>前端整合</h2><ol><li>Vite 初始化</li><li>Vue Router 整合，添加路由功能</li><li>Ant Design Vue 整合</li><li>整合 AntV G2，支持实例图表</li></ol><h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><ol><li>新增记录：表单页</li><li>展示记录：列表页</li><li>分析</li></ol><h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><ol><li>拉取通用模板，已经整合好了常用框架、用户登录用例等</li><li>设计库表</li></ol><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="工作表"><a href="#工作表" class="headerlink" title="工作表"></a>工作表</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">name:</span> <span class="hljs-type">string</span>;<br><span class="hljs-symbol">description:</span> <span class="hljs-type">string</span>;<br><span class="hljs-symbol">duration:</span> number;<br><span class="hljs-symbol">tags:</span> <span class="hljs-type">string</span>[];<br>planTime?: <span class="hljs-type">Date</span>;<br><span class="hljs-symbol">createTime:</span> <span class="hljs-type">Date</span>;<br><span class="hljs-symbol">updateTime:</span> <span class="hljs-type">Date</span>;<br></code></pre></td></tr></table></figure><p>id bigint</p><p>任务名称 varchar</p><p>描述 varchar</p><p>时长 duration int</p><p>tags  varchar</p><p>planTime 计划时间 datetime</p><p>创建时间  datetime</p><p>更新时间  datetime</p><p>逻辑删除 tinyint 0 &#x2F; 1</p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 任务<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> work<br>(<br>    id          <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name        <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;任务名称&#x27;</span>,<br>    description text               <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    duration    <span class="hljs-type">int</span>                <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;时长（秒）&#x27;</span>,<br>    tags        <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;标签列表json&#x27;</span>,<br>    planTime    datetime comment <span class="hljs-string">&#x27;计划时间&#x27;</span>,<br>    createTime  datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime  datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete    tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>) comment <span class="hljs-string">&#x27;任务&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><ol><li>校验参数</li><li>插入数据到数据库中</li></ol><p>查询任务列表</p><p>直接用接口文档在线测试</p><h3 id="查询列表（分页）"><a href="#查询列表（分页）" class="headerlink" title="查询列表（分页）"></a>查询列表（分页）</h3><p>MyBatis Plus 的 Page 方法</p><h2 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h2><h3 id="分页实现"><a href="#分页实现" class="headerlink" title="分页实现"></a>分页实现</h3><ol><li>前端分页（一次请求全量数据，前端去计算每一页展示什么）</li><li>后端分页（一次请求一页的数据，前端页面时重新发请求去加载）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World练习</title>
    <link href="/chaserblog/2024/04/28/hello-world/"/>
    <url>/chaserblog/2024/04/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>练习测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE%20-%20%E8%87%AA%E5%AA%92%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <url>/chaserblog/2024/04/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE%20-%20%E8%87%AA%E5%AA%92%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员鱼皮-自媒体经验分享"><a href="#程序员鱼皮-自媒体经验分享" class="headerlink" title="程序员鱼皮 - 自媒体经验分享"></a>程序员鱼皮 - 自媒体经验分享</h1><h2 id="环节一"><a href="#环节一" class="headerlink" title="环节一"></a>环节一</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><p>知识区 &#x2F; 科技区 &#x3D;&gt; 计算机 &#x2F; 编程知识 UP，分享在职程序员 &amp; 自媒体创作（两大脱发职业）的经历和干货</p><h3 id="2-拍摄介绍"><a href="#2-拍摄介绍" class="headerlink" title="2. 拍摄介绍"></a>2. 拍摄介绍</h3><p>设备</p><ul><li>摄像头：罗技 Stream Cam</li><li>拍摄：<ul><li>日常：手机足够</li><li>vlog：大疆 pocket 2</li><li>高清视频：相机索尼 a7c</li></ul></li><li>麦克风<ul><li>直播：罗技 Blue Yeti</li><li>录制：Rode Wireless Go II</li></ul></li><li>幕布</li><li>打光<ul><li>桌面打光灯</li><li>落地打光灯</li></ul></li><li>前期可以用提词器</li></ul><p>硬件</p><ul><li>Mac or Windows 电脑均可</li></ul><p>软件</p><ul><li>必剪（做封面）</li><li>剪映</li><li>PR（之前用的多，后来很少用了）</li><li>爱提词</li></ul><h3 id="3-做-UP-有意思的事-——-带节奏、一起快乐"><a href="#3-做-UP-有意思的事-——-带节奏、一起快乐" class="headerlink" title="3. 做 UP 有意思的事 —— 带节奏、一起快乐"></a>3. 做 UP 有意思的事 —— 带节奏、一起快乐</h3><ol><li>直播写代码翻车（让大家集中注意力、无痛学编程）</li><li>网站被攻击（激励大家学习编程、同时感受到网络攻击的危害）</li><li>评论区人才辈出</li></ol><h2 id="环节二"><a href="#环节二" class="headerlink" title="环节二"></a>环节二</h2><h3 id="1-个人创作经历-——-五个阶段"><a href="#1-个人创作经历-——-五个阶段" class="headerlink" title="1. 个人创作经历 —— 五个阶段"></a>1. 个人创作经历 —— 五个阶段</h3><h4 id="1-1-短视频-起因：激励自己准备面试"><a href="#1-1-短视频-起因：激励自己准备面试" class="headerlink" title="1.1 短视频 - 起因：激励自己准备面试"></a>1.1 短视频 - 起因：激励自己准备面试</h4><p>看一道面试题，录一道，一天 3 - 5 期，录了 100 多个视频只有 100 个粉丝。</p><h4 id="1-2-短视频-起因：想试试"><a href="#1-2-短视频-起因：想试试" class="headerlink" title="1.2 短视频 - 起因：想试试"></a>1.2 短视频 - 起因：想试试</h4><p>别人的经历能有那么多点赞？我的经历也挺励志，也值得给大家分享！</p><p>分享了自己大学四年的经历。</p><p>第一次直播的经历（20 多个人聊了半个多小时）</p><p>理念：通过短视频帮大家快速了解某个技术、让知识变得有趣</p><h4 id="1-3-文字创作-公众号-起因：想有个地方写文章、兴趣"><a href="#1-3-文字创作-公众号-起因：想有个地方写文章、兴趣" class="headerlink" title="1.3 文字创作 - 公众号 - 起因：想有个地方写文章、兴趣"></a>1.3 文字创作 - 公众号 - 起因：想有个地方写文章、兴趣</h4><ul><li>一天一更，坚持了 1 个多月</li><li>观念转变，希望更多人看到，激励自己输出</li><li>知乎，每天回答 3 - 5 个问题</li><li>变现</li></ul><h4 id="1-4-中长视频-起因：合成大西瓜小爆款-B-站粘性高"><a href="#1-4-中长视频-起因：合成大西瓜小爆款-B-站粘性高" class="headerlink" title="1.4 中长视频 - 起因：合成大西瓜小爆款 &#x2F; B 站粘性高"></a>1.4 中长视频 - 起因：合成大西瓜小爆款 &#x2F; B 站粘性高</h4><ul><li>之前考虑没做是因为没做起来，时间也不够</li><li>持续做 B 站，氛围好、想做大、想得到大家的认可，排期 &#x3D;&gt; 不出稿难受</li><li>纠结：迎合流量还是专注技术？ &#x3D;&gt; 像稚晖君那样的结合？</li><li>成为习惯 &#x3D;&gt; 爱好</li></ul><h4 id="1-5-私域流量-知识星球"><a href="#1-5-私域流量-知识星球" class="headerlink" title="1.5 私域流量 - 知识星球"></a>1.5 私域流量 - 知识星球</h4><ul><li>粉丝多了后，很多想分享的知识并不适合去做视频分享，不如定制化地帮大家解决问题</li><li>想挑战不依赖第三方平台，打造自己的 IP</li><li>变现</li></ul><h4 id="做自媒体的契机"><a href="#做自媒体的契机" class="headerlink" title="做自媒体的契机"></a>做自媒体的契机</h4><p>自己的契机：兴趣 + 尝试 + 坚持</p><p>过程：随缘 &#x3D;&gt; 尝试 &#x3D;&gt; 兴趣 &#x3D;&gt; 正反馈驱动 &#x3D;&gt; 迷茫 &#x3D;&gt; 不服 &#x3D;&gt; 习惯 &#x3D;&gt; 爱好 &#x3D;&gt; 随缘</p><p>最适合做自媒体的人（没有压力、能持续发展的）：对自己的工作、技能感兴趣，并愿意将它分享给更多的同学。</p><h4 id="创作压力"><a href="#创作压力" class="headerlink" title="创作压力"></a>创作压力</h4><p>如何坚持高产？</p><ol><li>持续思考，认真观察，即时记录自己的灵感并持续发酵。不会为了想稿子而头疼。</li><li>持续做计划，大目标拆解</li><li>给自己找创作激励和正反馈（不行就多立 Flag）</li></ol><p>平衡工作和自媒体创作？</p><ul><li>最理想的状态是把自己工作中的发现、学到的技术进行分享。</li><li>自媒体创作是兴趣，不玩游戏，时间还是足够的</li><li>90% 的同学没时间的原因都是在玩游戏和回消息（水群），个人习惯：集中一个时间段回复，工作的时候认真回复。</li><li>放弃了午休，放弃了游戏，放弃了一些出去玩  &#x2F; 聊天的机会、熬夜，创造每周第 8 天</li></ul><p>会缺乏动力么？</p><ul><li>会，这时要给自己找点刺激</li><li>心态要随缘，刻意会不持久</li></ul><p>同事知道自己做 UP 是怎样的感受？</p><ul><li>替我担心：你不要再吐槽公司了，很危险啊！</li></ul><h3 id="2-如何做有趣有料的干货内容？"><a href="#2-如何做有趣有料的干货内容？" class="headerlink" title="2. 如何做有趣有料的干货内容？"></a>2. 如何做有趣有料的干货内容？</h3><h4 id="2-1-焦虑"><a href="#2-1-焦虑" class="headerlink" title="2.1 焦虑"></a>2.1 焦虑</h4><p>数据：会焦虑，会和别人对比 <del>，一度怀疑自己被限流，我现在依然怀疑</del></p><p>涨粉：不会焦虑，更多关注内容</p><p>从来没有把自媒体当成任务，但依然会有流量焦虑。主要的焦虑是其他 UP 主带来的，太卷了。</p><h4 id="2-2-内容质量的把控"><a href="#2-2-内容质量的把控" class="headerlink" title="2.2 内容质量的把控"></a>2.2 内容质量的把控</h4><p>希望每期视频都能给大家带来一些知识，而不是纯粹的搞笑或闲聊。哪怕是网站被攻击，也能给大家带来一些收获~</p><ul><li>好玩、有趣</li><li>真实、共鸣</li><li>要留下一些东西（知识点、一个作品）</li><li>精简、突出主旨</li></ul><h4 id="2-3-分享干货的套路"><a href="#2-3-分享干货的套路" class="headerlink" title="2.3 分享干货的套路"></a>2.3 分享干货的套路</h4><ol><li>真实最重要，纵观自己和全网，越真实、越自然，越容易爆火。被喷是很正常的，从你做 UP 主开始，就应该做好心理准备。我不会排斥某些内容，他能上热门一定有它的道理，思考背后的原因。</li><li>摸清观众的心理，比如编程深度知识或完整教程，真正要看这些内容的人会主动搜索、或者不需要你来把文字稿整成视频；应该用轻松的方式，让大家在主线学习之余，零碎时间了解新知识。领悟过程一方面是发现自己随着粉丝的增长、受众越来越小白化，更要注重知识的通俗易懂；另一方面是看数据和大家的评论反馈。向大流量区学习。</li><li>不要去跟某一领域更专业的人竞争，比如培训机构（我不会出自己的完整课程）</li></ol><h4 id="2-4-给新人-UP-主的创作建议"><a href="#2-4-给新人-UP-主的创作建议" class="headerlink" title="2.4 给新人 UP 主的创作建议"></a>2.4 给新人 UP 主的创作建议</h4><ul><li>创作<ul><li>随时记录，随时找灵感，不是硬着头皮写稿子</li><li>调研已有视频，分析做得好与不好的地方</li><li>多关注同类 UP 主，学习经验</li><li>有趣 &gt; 干货（优化稿子：去除废话、加一些梗，剪辑时加一些搞笑的动图、搞笑的音乐</li><li>持续产出，而不是三天打鱼两天晒网，坚持才能成功！</li></ul></li><li>如何增加曝光与点击<ul><li>发布时间选择</li><li>标题</li><li>封面</li><li>标签</li><li>活动</li><li>推广（创作激励）</li><li>社群 &#x2F; 私域流量分享</li><li>前期内容在尽可能多的平台发布</li><li>写简介</li><li>引导三连</li><li>评论区的互动</li></ul></li><li>转化<ul><li>有意引导点赞三连</li><li>引流</li><li>制造期待（下期内容，留下自己的标签）</li></ul></li></ul><h3 id="3-意义和未来打算"><a href="#3-意义和未来打算" class="headerlink" title="3. 意义和未来打算"></a>3. 意义和未来打算</h3><h4 id="3-1-给自己的收获"><a href="#3-1-给自己的收获" class="headerlink" title="3.1 给自己的收获"></a>3.1 给自己的收获</h4><ul><li>快乐</li><li>充实和满足</li><li>收益</li><li>尝试和挑战</li><li>有了一定发声的权利</li><li>项目更容易推广，自己给自己打广告</li><li>认识更多有趣的人</li><li>顺应时代，不掉队</li><li>帅气的光头 🧑‍🦲</li></ul><h4 id="3-2-给大家的帮助和沉淀"><a href="#3-2-给大家的帮助和沉淀" class="headerlink" title="3.2 给大家的帮助和沉淀"></a>3.2 给大家的帮助和沉淀</h4><ul><li>新人入门</li><li>大家的正向反馈（找到工作之类的）</li><li>留下自己的作品</li></ul><h4 id="3-3-未来打算"><a href="#3-3-未来打算" class="headerlink" title="3.3 未来打算"></a>3.3 未来打算</h4><p>走一步算一步吧，继续把自媒体当做爱好，干好本职工作，学习更多技能</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E6%8A%93%E9%B1%BC-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%AF%84%E8%AE%BA%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E6%8A%93%E9%B1%BC-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%AF%84%E8%AE%BA%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="写一个小项目-——-抓鱼"><a href="#写一个小项目-——-抓鱼" class="headerlink" title="写一个小项目 —— 抓鱼"></a>写一个小项目 —— 抓鱼</h1><p><strong>直播回放在知识星球：dogyupi.com，欢迎加入</strong></p><ol><li>获取某个视频的评论 ✔</li><li><strong>实时</strong> 感知到评论的变化（定时去抓屏）-<ol><li><strong>设计算法（顺序、去重、不丢失）</strong>：</li><li>去重：<strong>rpid</strong></li><li>顺序：从接口拿来的数据本来就是按最新shi</li><li>不丢失：提高抓取的频率（不太建议）</li><li><strong>不能太频繁</strong>：定时 10 秒更新</li></ol></li><li>能够把评论输出到其他平台（网页）✔</li></ol><p>技术选型：</p><p>后端：Node.js + Express  + axios 请求库 + socket.io 实时通讯，nodemon 热更新</p><p>前端：JavaScript + moment.js</p><p>socket + websocket</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心直播笔记（完整版）"><a href="#用户中心直播笔记（完整版）" class="headerlink" title="用户中心直播笔记（完整版）"></a>用户中心直播笔记（完整版）</h1><p>目标：完整了解做项目的思路，接触一些企业级的开发技术，让大家之后都能轻松做出管理系统！</p><h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><p>用户中心前端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-frontend">http://gitlab.code-nav.cn/root/user-center-frontend</a></p><p>用户中心后端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-backend">http://gitlab.code-nav.cn/root/user-center-backend</a></p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt; 初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试、系统测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署 &#x3D;&gt; 发布上线</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>登录 &#x2F; 注册</li><li>用户管理（仅管理员可见）对用户的查询或者修改</li><li>用户校验（仅星球用户可见）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="3-种初始化-Java-项目的方式"><a href="#3-种初始化-Java-项目的方式" class="headerlink" title="3 种初始化 Java 项目的方式"></a>3 种初始化 Java 项目的方式</h2><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库？程序代替人工</p><h3 id="什么是设计数据库表？"><a href="#什么是设计数据库表？" class="headerlink" title="什么是设计数据库表？"></a>什么是设计数据库表？</h3><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？</p><p>举例：性别是否需要加索引？</p><h3 id="用户表设计"><a href="#用户表设计" class="headerlink" title="用户表设计"></a>用户表设计</h3><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p>MyBatisX 插件，自动根据数据库生成：</p><ul><li>domain：实体对象</li><li>mapper：操作数据库的对象</li><li>mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL</li><li>service：包含常用的增删改查</li><li>serviceImpl：具体实现 service</li></ul><p>从而提高开发效率！</p><h2 id="注册逻辑设计"><a href="#注册逻辑设计" class="headerlink" title="注册逻辑设计"></a>注册逻辑设计</h2><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度不小于 4 位</li><li>密码就不小于 8 位</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>控制层 Controller 封装请求</p><p>application.yml 指定接口全局路径前缀：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><p>控制器注解：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>校验写在哪里？</p><ul><li>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</li><li>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</li></ul><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><blockquote><p>javaweb 这一块的知识</p></blockquote><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>接口设计关键：必须鉴权！！！</p><ol><li>查询用户（允许根据用户名查询）</li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><ol><li>先做设计</li><li>代码实现</li><li>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</li></ol><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求才能获取数据 &#x2F; 执行操作。</p><p>怎么发请求：前端使用 ajax 来请求后端</p><h3 id="前端请求库及封装关系"><a href="#前端请求库及封装关系" class="headerlink" title="前端请求库及封装关系"></a>前端请求库及封装关系</h3><ul><li><p>axios 封装了 ajax</p></li><li><p>request 是 ant design 项目又封装了一次</p></li></ul><p>追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么实现代理？</p><ul><li>Nginx 服务器</li><li>Node.js 服务器</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="前端框架介绍"><a href="#前端框架介绍" class="headerlink" title="前端框架介绍"></a>前端框架介绍</h2><h3 id="Ant-Design-Pro（Umi-框架）权限管理"><a href="#Ant-Design-Pro（Umi-框架）权限管理" class="headerlink" title="Ant Design Pro（Umi 框架）权限管理"></a>Ant Design Pro（Umi 框架）权限管理</h3><ul><li>app.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</li><li>access.ts 控制用户的访问权限</li></ul><p>获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="框架关系"><a href="#框架关系" class="headerlink" title="框架关系"></a>框架关系</h3><p>Ant Design 组件库 &#x3D;&gt; 基于 React 实现</p><p>Ant Design Procomponents &#x3D;&gt; 基于 Ant Design 实现</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现</p><h3 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h3><p>MFSU：前端编译优化</p><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><h3 id="通用返回对象"><a href="#通用返回对象" class="headerlink" title="通用返回对象"></a>通用返回对象</h3><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>自定义错误码，返回类支持返回正常和错误</p><h3 id="封装全局异常处理器"><a href="#封装全局异常处理器" class="headerlink" title="封装全局异常处理器"></a>封装全局异常处理器</h3><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）</p></li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><blockquote><p>直播的 0：00 - 0：35 为踩坑过程，可跳过</p></blockquote><h3 id="全局响应处理"><a href="#全局响应处理" class="headerlink" title="全局响应处理"></a>全局响应处理</h3><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p><p>优势：不用在每个接口请求中都去写相同的逻辑</p><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用</a> <strong>axios</strong>，参考 axios 的文档。</p><p>创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，全凭自觉。</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端。</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端托管"><a href="#前端托管" class="headerlink" title="前端托管"></a>前端托管</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后端</span><br>docker build -t user-center-backend:v0.0.1 .<br><br><span class="hljs-comment"># 前端</span><br>docker build -t user-center-front:v0.0.1 .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理的作用：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如何解决跨域？</p><p>最直接的方式：把域名、端口改成相同的</p><h3 id="添加跨域头"><a href="#添加跨域头" class="headerlink" title="添加跨域头"></a>添加跨域头</h3><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><h4 id="1-网关支持（Nginx）"><a href="#1-网关支持（Nginx）" class="headerlink" title="1. 网关支持（Nginx）"></a>1. 网关支持（Nginx）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改后端服务"><a href="#2-修改后端服务" class="headerlink" title="2. 修改后端服务"></a>2. 修改后端服务</h4><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E9%B1%BC%E7%A5%A8-%E5%8F%91%E5%88%B8%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E9%B1%BC%E7%A5%A8-%E5%8F%91%E5%88%B8%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="直播开发【发券系统】-鱼票"><a href="#直播开发【发券系统】-鱼票" class="headerlink" title="直播开发【发券系统】 鱼票"></a>直播开发【发券系统】 鱼票</h1><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>给星球的小伙伴发布一个兑换券，凭借兑换券可以充值积分。</strong></p><h4 id="传统思路"><a href="#传统思路" class="headerlink" title="传统思路"></a>传统思路</h4><p>在现有的系统上加功能？在同一个代码上去开发，或者就是该数据库。</p><hr><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>【腾讯文档】鱼票-发券中心项目流程图<br><a href="https://docs.qq.com/flowchart/DUGlDTmZja05MUW12">https://docs.qq.com/flowchart/DUGlDTmZja05MUW12</a></p><h4 id="发兑换券（可以理解为激活码）的系统"><a href="#发兑换券（可以理解为激活码）的系统" class="headerlink" title="发兑换券（可以理解为激活码）的系统"></a>发兑换券（可以理解为激活码）的系统</h4><ol><li>管理员<ol><li>创建兑换券（设置规则 —— <strong>一人一券</strong> &#x2F; 抢）</li><li>发券（设置数量、设置单个用户可以使用的次数）</li></ol></li><li>用户<ol><li>输入券码来兑换奖品</li><li>查看自己用过的券码</li></ol></li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue</li><li>Vite</li><li>Tencent UI</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java</li><li>SpringBoot + SSM + MyBatis Plus</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><ol><li>管理员 √<ol><li>创建兑换券，定义规则<ol><li>兑换券的名称</li><li>兑换券的描述</li><li>回调接口地址</li><li>回调接口信息（json）</li></ol></li><li>发券<ol><li>选择已经定义好的券</li><li>数量</li><li>开始时间</li><li>过期时间</li></ol></li><li>管理已发的券<ol><li>查看所有类型的券</li><li>查看每个券的发放情况</li></ol></li></ol></li><li>用户<ol><li>输入券码来兑换奖品</li><li>查看自己用过的券码</li></ol></li></ol><h3 id="Vue3-的几种事件传递方式"><a href="#Vue3-的几种事件传递方式" class="headerlink" title="Vue3 的几种事件传递方式"></a>Vue3 的几种事件传递方式</h3><ol><li>父组件通过 props 将方法传递给子组件</li><li>子组件直接 emit，触发父组件的事件</li></ol><h2 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h2><h3 id="设计库表"><a href="#设计库表" class="headerlink" title="设计库表"></a>设计库表</h3><h4 id="ticket（定义了一类券的信息）"><a href="#ticket（定义了一类券的信息）" class="headerlink" title="ticket（定义了一类券的信息）"></a>ticket（定义了一类券的信息）</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">id <span class="hljs-type">int</span> 主键<br>ticketName <span class="hljs-type">varchar</span> 券名称<br>ticketDesc <span class="hljs-type">varchar</span> 券描述<br>callbackUrl <span class="hljs-type">varchar</span> 回调地址,<br>callbackInfo <span class="hljs-type">text</span> 回调信息 <span class="hljs-type">json</span>,<br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="sendTicket（发券情况）"><a href="#sendTicket（发券情况）" class="headerlink" title="sendTicket（发券情况）"></a>sendTicket（发券情况）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-type">int</span> 主键<br>ticketId <span class="hljs-type">int</span> 券的类型<br>sendNum <span class="hljs-type">int</span> 发圈数量<br>sendStatus <span class="hljs-type">int</span> 发放状态（<span class="hljs-number">0</span> <span class="hljs-operator">-</span> 关闭，<span class="hljs-number">1</span> <span class="hljs-operator">-</span>开启）<br>expireTime <span class="hljs-type">date</span> 过期时间 <br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="ticketDetail（每张券的信息）"><a href="#ticketDetail（每张券的信息）" class="headerlink" title="ticketDetail（每张券的信息）"></a>ticketDetail（每张券的信息）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-type">int</span> 主键<br>ticketId <span class="hljs-type">int</span> 主键<br>sendTicketId <span class="hljs-type">int</span> 所属发券批次<br>token <span class="hljs-type">varchar</span> 券码<br>useStatus <span class="hljs-type">int</span> 使用状态 <span class="hljs-number">0</span> <span class="hljs-operator">-</span> 未使用 <span class="hljs-number">1</span><span class="hljs-operator">-</span> 已使用 <span class="hljs-number">2</span> <span class="hljs-operator">-</span> 使用失败<br>useInfo text 使用信息（用户自主输入）<br>useMessage text 用券情况信息 userId<br>useTime <span class="hljs-type">date</span> 使用时间<br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="创建券"><a href="#创建券" class="headerlink" title="创建券"></a>创建券</h4><p>校验券的信息</p><p>插入券</p><h4 id="发券"><a href="#发券" class="headerlink" title="发券"></a>发券</h4><ol><li>校验请求参数是否合法</li><li>校验这种券是否存在</li><li>创建发券批次信息</li><li>根据数量去创建多张券</li></ol><h3 id="优化发券-两个问题"><a href="#优化发券-两个问题" class="headerlink" title="优化发券 - 两个问题"></a>优化发券 - 两个问题</h3><ol><li>稳定性 —— 事务（可以解决不一致问题，保证原子性，要么都成功，要么都不成功）</li><li>性能 —— 多线程 &#x2F; 批量操作 - 减少重复创建连接</li></ol><blockquote><p>想要领取资料，跟着鱼皮直播做项目、1 对 1 交流答疑、和小伙伴一起交流学习的话：</p><p>欢迎加入鱼皮的编程星球 👉：<a href="http://dogyupi.com/">http://dogyupi.com</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E9%B1%BC%E6%B3%A1%20-%20%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E9%B1%BC%E6%B3%A1%20-%20%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="鱼泡-伙伴匹配系统"><a href="#鱼泡-伙伴匹配系统" class="headerlink" title="鱼泡 - 伙伴匹配系统"></a>鱼泡 - 伙伴匹配系统</h1><p>介绍：帮助大家找到志同道合的伙伴，移动端 H5 网页（尽量兼容 PC 端）</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>用户去添加标签，标签的分类（要有哪些标签、怎么把标签进行分类）学习方向 java &#x2F; c++，工作 &#x2F; 大学</li><li>主动搜索：允许用户根据标签去搜索其他用户<ol><li>Redis 缓存</li></ol></li><li>组队<ol><li>创建队伍</li><li>加入队伍</li><li>根据标签查询队伍</li><li>邀请其他人</li></ol></li><li>允许用户去修改标签</li><li>推荐<ol><li>相似度计算算法 + 本地分布式计算</li></ol></li></ol><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue 3 开发框架（提高页面开发的效率）</li><li>Vant UI（基于 Vue 的移动端组件库）（React 版 Zent）</li><li>Vite 2（打包工具，快！）</li><li>Nginx 来单机部署</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java 编程语言 + SpringBoot 框架</li><li>SpringMVC + MyBatis + MyBatis Plus（提高开发效率）</li><li>MySQL 数据库</li><li>Redis 缓存</li><li>Swagger + Knife4j 接口文档</li></ol><h2 id="第一期计划"><a href="#第一期计划" class="headerlink" title="第一期计划"></a>第一期计划</h2><ol><li>前端项目初始化 15 min √</li><li>前端主页 + 组件概览 15 min √</li><li>数据库表设计 15 min √<ol><li>标签表</li><li>用户表</li></ol></li><li>初始化后端项目</li><li>开发后端 - 根据标签搜索用户 30 min</li><li>开发前端 - 根据标签搜索用户 20 min</li></ol><h2 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><p>用脚手架初始化项目</p><ul><li>Vue CLI <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li><li><strong>Vite 脚手架</strong> ：<a href="https://vitejs.cn/guide/#scaffolding-your-first-vite-project">https://vitejs.cn/guide/#scaffolding-your-first-vite-project</a></li></ul><p>整合组件库 Vant：</p><ul><li>安装 Vant</li><li>按需引入 npm i <a href="mailto:&#118;&#x69;&#116;&#101;&#45;&#112;&#108;&#x75;&#103;&#x69;&#110;&#x2d;&#x73;&#x74;&#121;&#108;&#101;&#45;&#105;&#109;&#112;&#x6f;&#x72;&#x74;&#64;&#49;&#46;&#x34;&#46;&#49;">&#118;&#x69;&#116;&#101;&#45;&#112;&#108;&#x75;&#103;&#x69;&#110;&#x2d;&#x73;&#x74;&#121;&#108;&#101;&#45;&#105;&#109;&#112;&#x6f;&#x72;&#x74;&#64;&#49;&#46;&#x34;&#46;&#49;</a> -D</li></ul><p>开发页面经验：</p><ol><li>多参考</li><li>从整体到局部</li><li>先想清楚页面要做成什么样子，再写代码</li></ol><h2 id="前端主页-组件概览-15-min"><a href="#前端主页-组件概览-15-min" class="headerlink" title="前端主页 + 组件概览 15 min"></a>前端主页 + 组件概览 15 min</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>导航条：展示当前页面名称</p><p>主页搜索框 &#x3D;&gt; 搜索页 &#x3D;&gt; 搜索结果页（标签筛选页）</p><p>内容</p><p>tab 栏：</p><ul><li>主页（推荐页 + <strong>广告</strong> ）<ul><li>搜索框</li><li>banner</li><li>推荐信息流</li></ul></li><li>队伍页</li><li>用户页（消息 - 暂时考虑发邮件）</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>很多页面要复用组件 &#x2F; 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）</p><p>组件化</p><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p>标签的分类（要有哪些标签、怎么把标签进行分类）</p><h3 id="新增标签表（分类表）"><a href="#新增标签表（分类表）" class="headerlink" title="新增标签表（分类表）"></a>新增标签表（分类表）</h3><p>建议用标签，不要用分类，更灵活。</p><p>性别：男、女</p><p>方向：Java、C++、Go、前端</p><p>正在学：Spring</p><p>目标：考研、春招、秋招、社招、考公、竞赛（蓝桥杯）、转行、跳槽</p><p>段位：初级、中级、高级、王者</p><p>身份：小学、初中、高中、大一、大二、大三、大四、学生、待业、已就业、研一、研二、研三</p><p>状态：乐观、有点丧、一般、单身、已婚、有对象</p><p><strong>【用户自己定义标签】？</strong></p><p>字段：</p><p>id int 主键</p><p>标签名 varchar 非空（必须唯一，唯一索引）</p><p>上传标签的用户 userId int（如果要根据 userId 查已上传标签的话，最好加上，普通索引）</p><p>父标签 id ，parentId，int（分类）</p><p>是否为父标签 isParent, tinyint（0 不是父标签、1 - 父标签）</p><p>创建时间 createTime，datetime</p><p>更新时间 updateTime，datetime</p><p>是否删除 isDelete， tinyint（0、1）</p><p>怎么查询所有标签，并且把标签分好组？按父标签 id 分组，能实现 √</p><p>根据父标签查询子标签？根据 id 查询，能实现 √</p><p>SQL 语言分类：</p><p>DDL define 建表、操作表</p><p>DML manage 更新删除数据，影响实际表里的内容</p><p>DCL control 控制，权限</p><p>DQL query 查询，select</p><p><a href="https://www.cnblogs.com/fan-yuan/p/7879353.html">https://www.cnblogs.com/fan-yuan/p/7879353.html</a></p><h3 id="修改用户表"><a href="#修改用户表" class="headerlink" title="修改用户表"></a>修改用户表</h3><p>用户有哪些标签？</p><p><strong>根据自己的实际需求来！！！</strong> 此处选择第一种</p><ol><li><p>直接在用户表补充 tags 字段，**[‘Java’, ‘男’] 存 json 字符串 ** </p><p>优点：查询方便、不用新建关联表，标签是用户的固有属性（除了该系统、其他系统可能要用到，标签是用户的固有属性）节省开发成本</p><p><strong>查询用户列表，查关系表拿到这 100 个用户有的所有标签 id，再根据标签 id 去查标签表。</strong></p><p>哪怕性能低，可以用缓存。</p><p>缺点：用户表多一列，会有点</p></li><li><p>加一个关联表，记录用户和标签的关系</p><p>关联表的应用场景：查询灵活，可以正查反查</p><p>缺点：要多建一个表、多维护一个表</p><p>重点：企业大项目开发中尽量减少关联查询，很影响扩展性，而且会影响查询性能</p></li></ol><h3 id="开发后端接口"><a href="#开发后端接口" class="headerlink" title="开发后端接口"></a>开发后端接口</h3><h4 id="搜索标签"><a href="#搜索标签" class="headerlink" title="搜索标签"></a>搜索标签</h4><ol><li>允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%Java%’ and like ‘%C++%’。</li><li>允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’</li></ol><p>两种方式：</p><ol><li>SQL 查询（实现简单，可以通过拆分查询进一步优化）</li><li>内存查询（灵活，可以通过并发进一步优化）</li></ol><ul><li><p>如果参数可以分析，根据用户的参数去选择查询方式，比如标签数</p></li><li><p>如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁。</p></li><li><p>还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag</p></li></ul><p>建议通过实际测试来分析哪种查询比较快，数据量大的时候验证效果更明显！</p><p>解析 JSON 字符串：</p><p>序列化：java对象转成 json</p><p>反序列化：把 json 转为 java 对象</p><p>java  json 序列化库有很多：</p><ol><li><p><strong>gson</strong>（google 的）</p></li><li><p>fastjson alibaba（ali 出品，快，但是漏洞太多）</p></li><li><p>jackson</p></li><li><p>kryo</p></li></ol><h2 id="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"><a href="#用户中心来集中提供用户的检索、操作、注册、登录、鉴权" class="headerlink" title="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"></a>用户中心来集中提供用户的检索、操作、注册、登录、鉴权</h2><h2 id="中-2022-05-29"><a href="#中-2022-05-29" class="headerlink" title="中 2022-05-29"></a>中 2022-05-29</h2><p>本次直播内容（计划）： </p><ol><li><strong>上次的标签接口调试</strong> 5 min √</li><li>前端整合路由 5min √</li><li>前端开发（搜索页面、用户信息页、用户信息修改页）30 - 50min √</li><li>后端整合 Swagger + Knife4j 接口文档 10 - 15min</li><li>存量用户信息导入及同步（爬虫） 40 min</li></ol><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ol><li>stream &#x2F; parallelStream 流失处理</li><li>Optional 可选类</li></ol><h3 id="前端整合路由"><a href="#前端整合路由" class="headerlink" title="前端整合路由"></a>前端整合路由</h3><p>Vue-Router：<a href="https://router.vuejs.org/zh/guide/#html%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%BC%95%E5%85%A5">https://router.vuejs.org/zh/guide/#html，直接看官方文档引入</a></p><p>Vue-Router 其实就是帮助你根据不同的 url 来展示不同的页面（组件），不用自己写 if &#x2F; else</p><p>路由配置影响整个项目，所以建议单独用 config 目录、单独的配置文件去集中定义和管理。</p><p>有些组件库可能自带了和 Vue-Router 的整合，所以尽量先看组件文档、省去自己写的时间。</p><h2 id="下-2022-06-05"><a href="#下-2022-06-05" class="headerlink" title="下 2022-06-05"></a>下 2022-06-05</h2><ol><li>Java 后端整合 Swagger + Knife4j 接口文档 10 min √</li><li>存量用户信息导入及同步（爬虫） 30 min - 40 min</li><li></li><li>前后端联调：搜索页面、用户信息页、用户信息修改页 30 - 40 min</li><li>标签内容整理 15 min</li><li>部分细节优化  todo</li></ol><h2 id="后端整合-Swagger-Knife4j-接口文档"><a href="#后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="后端整合 Swagger + Knife4j 接口文档"></a>后端整合 Swagger + Knife4j 接口文档</h2><p>什么是接口文档？写接口信息的文档，每条接口包括：</p><ul><li>请求参数</li><li>响应参数<ul><li>错误码</li></ul></li><li>接口地址</li><li>接口名称</li><li>请求类型</li><li>请求格式</li><li>备注</li></ul><p>who 谁用？一般是后端或者负责人来提供，后端和前端都要使用</p><p>为什么需要接口文档？</p><ul><li>有个书面内容（背书或者归档），便于大家参考和查阅，便于 <strong>沉淀和维护</strong> ，拒绝口口相传</li><li>接口文档便于前端和后端开发对接，前后端联调的 <strong>介质</strong> 。后端 &#x3D;&gt; 接口文档 &lt;&#x3D; 前端</li><li>好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发测试效率</li></ul><p>怎么做接口文档？</p><ul><li>手写（比如腾讯文档、Markdown 笔记）</li><li>自动化接口文档生成：自动根据项目代码生成完整的文档或在线调试的网页。Swagger，Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国产）</li></ul><p>接口文档有哪些技巧？</p><p>Swagger 原理：</p><ol><li>引入依赖（Swagger 或 Knife4j：<a href="https://doc.xiaominfo.com/knife4j/documentation/get_start.html%EF%BC%89">https://doc.xiaominfo.com/knife4j/documentation/get_start.html）</a></li><li>自定义 Swagger 配置类</li><li>定义需要生成接口文档的代码位置（Controller）</li><li>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</li><li>启动即可</li><li>可以通过在 controller 方法上添加 @Api、@ApiImplicitParam(name &#x3D; “name”,value &#x3D; “姓名”,required &#x3D; true)    @ApiOperation(value &#x3D; “向客人问好”) 等注解来自定义生成的接口描述信息</li></ol><p>如果 springboot version &gt;&#x3D; 2.6，需要添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><p>todo 怎么隐藏</p><h2 id="存量用户信息导入及同步"><a href="#存量用户信息导入及同步" class="headerlink" title="存量用户信息导入及同步"></a>存量用户信息导入及同步</h2><ol><li>把所有星球用户的信息导入</li><li>把写了自我介绍的同学的标签信息导入</li></ol><p>FeHelper 前端辅助插件，推荐安装</p><h3 id="看上了网页信息，怎么抓到？"><a href="#看上了网页信息，怎么抓到？" class="headerlink" title="看上了网页信息，怎么抓到？"></a>看上了网页信息，怎么抓到？</h3><ol><li>分析原网站是怎么获取这些数据的？哪个接口？</li></ol><p>按 F 12 打开控制台，查看网络请求，复制 curl 代码便于查看和执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;https://api.zsxq.com/v2/hashtags/48844541281228/topics?count=20&quot;</span> ^<br>  -H <span class="hljs-string">&quot;authority: api.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept: application/json, text/plain, */*&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept-language: zh-CN,zh;q=0.9&quot;</span> ^<br>  -H <span class="hljs-string">&quot;cache-control: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;origin: https://wx.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;pragma: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;referer: https://wx.zsxq.com/&quot;</span> ^<br>  --compressed<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>用程序去调用接口</strong> （java okhttp httpclient &#x2F; python 都可以）</li><li>处理（清洗）一下数据，之后就可以写到数据库里</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>从 excel 中导入全量用户数据，<strong>判重</strong> 。 easy excel：<a href="https://alibaba-easyexcel.github.io/index.html">https://alibaba-easyexcel.github.io/index.html</a></li><li>抓取写了自我介绍的同学信息，提取出用户昵称、用户唯一 id、自我介绍信息</li><li>从自我介绍中提取信息，然后写入到数据库中</li></ol><h4 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h4><p>两种读对象的方式：</p><ol><li>确定表头：建立对象，和表头形成映射关系</li><li>不确定表头：每一行数据映射为 Map&lt;String, Object&gt;</li></ol><p>两种读取模式：</p><ol><li>监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。</li><li>同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。</li></ol><h2 id="2022-06-12-【4】"><a href="#2022-06-12-【4】" class="headerlink" title="2022-06-12 【4】"></a>2022-06-12 【4】</h2><ol><li>页面和功能开发<ol><li>搜索页面</li><li>用户信息</li><li>用户修改页面</li></ol></li><li>改造用户中心，把单机登录改为分布式 session 登录</li><li>标签的整理、细节的优化</li></ol><h3 id="前端页面跳转传值"><a href="#前端页面跳转传值" class="headerlink" title="前端页面跳转传值"></a>前端页面跳转传值</h3><ol><li>query &#x3D;&gt; url searchParams，url 后附加参数，传递的值长度有限</li><li>vuex（全局状态管理），搜索页将关键词塞到状态中，搜索结果页从状态取值</li></ol><h2 id="Session-共享"><a href="#Session-共享" class="headerlink" title="Session 共享"></a>Session 共享</h2><p>种 session 的时候注意范围，cookie.domain</p><p>比如两个域名：</p><p>aaa.yupi.com</p><p>bbb.yupi.com</p><p>如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com</p><h3 id="为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？"><a href="#为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？" class="headerlink" title="为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？"></a>为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？</h3><p>用户在 A 登录，所以 session（用户登录信息）存在了 A 上</p><p>结果请求 B 时，B 没有用户信息，所以不认识。</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234247152.png"></p><p>解决方案：<strong>共享存储</strong> ，而不是把数据放到单台服务器的内存中</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234335539.png"></p><p>如何共享存储？</p><ol><li>Redis（基于内存的 K &#x2F; V 数据库）此处选择 Redis，因为用户信息读取 &#x2F; 是否登录的判断极其<strong>频繁</strong> ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w</li><li>MySQL </li><li>文件服务器 ceph</li></ol><h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>windows 下载：</p><p>Redis 5.0.14 下载：</p><p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p><p>提取码：vkoi </p><p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p><ol start="2"><li>引入 redis，能够操作 redis：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p><p>默认是 none，表示存储在单台服务器</p><p>store-type: redis，表示从 redis 读写 session</p></li></ol><p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p><h2 id="todo-待优化"><a href="#todo-待优化" class="headerlink" title="todo 待优化"></a>todo 待优化</h2><p>前端：动态展示页面标题、微调格式</p><h2 id="2022-07-03-伙伴匹配系统-5"><a href="#2022-07-03-伙伴匹配系统-5" class="headerlink" title="2022-07-03 伙伴匹配系统 5"></a>2022-07-03 伙伴匹配系统 5</h2><ol><li>用户修改页面前端、后端开发和联调</li></ol><h2 id="2022-07-17-伙伴匹配系统-6"><a href="#2022-07-17-伙伴匹配系统-6" class="headerlink" title="2022-07-17 伙伴匹配系统 6"></a>2022-07-17 伙伴匹配系统 6</h2><ol><li>开发主页（默认推荐和自己兴趣相当的用户）</li><li>优化主页的性能（缓存 + 定时任务 + 分布式锁）</li></ol><h3 id="开发主页"><a href="#开发主页" class="headerlink" title="开发主页"></a>开发主页</h3><p>最简单：直接 list 列表</p><p>模拟 1000 万个用户，再去查询</p><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><ol><li><p>用可视化界面：适合一次性导入、数据量可控</p></li><li><p>写程序：for 循环，建议分批，不要一把梭哈（可以用接口来控制）<strong>要保证可控、幂等，注意线上环境和测试环境是有区别的</strong></p><p>导入 1000 万条，for i 1000w</p></li><li><p>执行 SQL 语句：适用于小数据量</p></li></ol><h4 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h4><p>for 循环插入数据的问题：</p><ol><li>建立和释放数据库链接（批量查询解决）</li><li>for 循环是绝对线性的（并发）</li></ol><p>并发要注意执行的先后顺序无所谓，不要用到非并发类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">16</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10000</span>));<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// <span class="hljs-meta">CPU</span> 密集型：分配的核心线程数 = <span class="hljs-meta">CPU</span> - <span class="hljs-number">1</span><br>// IO 密集型：分配的核心线程数可以大于 <span class="hljs-meta">CPU</span> 核数<br></code></pre></td></tr></table></figure><p>数据库慢？预先把数据查出来，放到一个更快读取的地方，不用再查数据库了。（缓存）</p><p>预加载缓存，定时更新缓存。（定时任务）</p><p>多个机器都要执行任务么？（分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了）</p><h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><p>用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快地读写。</p><h3 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h3><ul><li>Redis（分布式缓存）</li><li>memcached（分布式）</li><li>Etcd（云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li></ul><hr><ul><li><p>ehcache（单机）</p></li><li><p>本地缓存（Java 内存 Map）</p></li><li><p>Caffeine（Java 内存缓存，高性能）</p></li><li><p>Google Guava</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>NoSQL 数据库</p></blockquote><p>key - value 存储系统（区别于 MySQL，他存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>String 字符串类型： name: “yupi”</p><p>List 列表：names: [“yupi”, “dogyupi”, “yupi”]</p><p>Set 集合：names: [“yupi”, “dogyupi”]（值不能重复）</p><p>Hash 哈希：nameAge: {  “yupi”: 1, “dogyupi”: 2 }</p><p>Zset 集合：names: {  yupi - 9,   dogyupi - 12  }（适合做排行榜）</p><hr><p>bloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）</p><p>geo（计算地理位置）</p><p>hyperloglog（pv &#x2F; uv）</p><p>pub &#x2F; sub（发布订阅，类似消息队列）</p><p>BitMap （1001010101010101010101010101）</p><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yupao.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTemplateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(connectionFactory);<br>        redisTemplate.setKeySerializer(RedisSerializer.string());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引入一个库时，先写测试类</p></blockquote><h3 id="Java-里的实现方式"><a href="#Java-里的实现方式" class="headerlink" title="Java 里的实现方式"></a>Java 里的实现方式</h3><h4 id="Spring-Data-Redis（推荐）"><a href="#Spring-Data-Redis（推荐）" class="headerlink" title="Spring Data Redis（推荐）"></a>Spring Data Redis（推荐）</h4><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong> 的接口</p><p>mysql、redis、jpa</p><p><a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">spring-data-redis</a></p><p>1）引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># redis 配置</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立于 Spring 操作 Redis 的 Java 客户端</p><p>要配合 Jedis Pool 使用</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong> 的操作 Redis 的 Java 客户端</p><p>异步、连接池</p><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，让你像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）</p><h4 id="JetCache"><a href="#JetCache" class="headerlink" title="JetCache"></a>JetCache</h4><p>对比</p><ol><li>如果你用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li><li>如果你用的不是 SPring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool</li><li>如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池</li></ol><hr><ul><li>如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson</li></ul><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>不同用户看到的数据不同</p><p>systemId:moduleId:func:options（不要和别人冲突）</p><p>yupao:user:recommed:userId</p><p><strong>redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库</p><p>缓存预热的优点：</p><ol><li>解决上面的问题，可以让用户始终访问很快</li></ol><p>缺点：</p><ol><li>增加开发成本（你要额外的开发、设计）</li><li>预热的时机和时间如果错了，有可能你缓存的数据不对或者太老</li><li>需要占用额外空间</li></ol><h4 id="怎么缓存预热？"><a href="#怎么缓存预热？" class="headerlink" title="怎么缓存预热？"></a>怎么缓存预热？</h4><ol><li>定时</li><li>模拟触发（手动触发）</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处每天一次）</li></ol><blockquote><p>分析优缺点的时候，要打开思路，从整个项目从 0 到 1 的链路上去分析</p></blockquote><h3 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h3><ol><li><strong>Spring Scheduler（spring boot 默认整合了）</strong> </li><li>Quartz（独立于 Spring 存在的定时任务框架）</li><li>XXL-Job 之类的分布式任务调度平台（界面 + sdk）</li></ol><p>第一种方式：</p><ol><li>主类开启 @EnableScheduling</li><li>给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率</li></ol><p>不要去背 cron 表达式！！！！！</p><ul><li><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></li></ul><hr><h3 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h3><p>为啥？</p><ol><li>浪费资源，想象 10000 台服务器同时 “打鸣”</li><li>脏数据，比如重复插入</li></ol><p><strong>要控制定时任务在同一时间只有 1 个服务器能执行。</strong></p><p>怎么做？</p><ol><li><p>分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大</p></li><li><p>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低；但是我们的 IP 可能是不固定的，把 IP 写的太死了</p></li><li><p>动态配置，配置是可以轻松的、很方便地更新的（<strong>代码无需重启</strong>），但是只有 ip 符合配置的服务器才真实执行业务逻辑。</p><ul><li>数据库</li><li>Redis</li><li>配置中心（Nacos、Apollo、Spring Cloud Config）</li></ul><p>问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改</p></li><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。</p></li></ol><p><strong>单机就会存在单点故障。</strong></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</p><p>Java 实现锁：synchronized 关键字、并发包的类</p><p>问题：只对单个 JVM 有效</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>为啥需要分布式锁？</p><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</li><li>单个锁只对单个 JVM 有效</li></ol><h3 id="分布式锁实现的关键"><a href="#分布式锁实现的关键" class="headerlink" title="分布式锁实现的关键"></a>分布式锁实现的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 个服务器能抢到锁？</p><p><strong>核心思想</strong> 就是：先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。</p><p>等先来的人执行方法结束，把标识清空，其他的人继续抢锁。</p><p>MySQL 数据库：select for update 行级锁（最简单）</p><p>（乐观锁）</p><p>✔ Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。</p><p>setnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>用完锁要释放（腾地方）√</p></li><li><p><strong>锁一定要加过期时间 √</strong></p></li><li><p>如果方法执行时间过长，锁提前过期了？</p><p>问题：</p><ol><li>连锁效应：释放掉别人的锁</li><li>这样还是会存在多个方法同时执行的情况</li></ol></li></ol><p>​解决方案：续期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!end)&#125;&#123;<br>    续期<br>&#125;)<br><br>end = <span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure><ol start="4"><li><p>释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子操作</span><br><span class="hljs-keyword">if</span>(get lock == A) &#123;<br>    <span class="hljs-comment">// set lock B</span><br>    del lock<br>&#125;<br></code></pre></td></tr></table></figure><p>Redis + lua 脚本实现</p></li><li><p>Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p></li></ol><p><a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p><h4 id="拒绝自己写！！！"><a href="#拒绝自己写！！！" class="headerlink" title="拒绝自己写！！！"></a>拒绝自己写！！！</h4><h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Java 客户端，数据网格</p><p>实现了很多 Java 里支持的接口和数据结构</p><p>Redisson 是一个 java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。</strong></p><h4 id="2-种引入方式"><a href="#2-种引入方式" class="headerlink" title="2 种引入方式"></a>2 种引入方式</h4><ol><li>spring boot starter 引入（不推荐，版本迭代太快，容易冲突）<a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs setnx">// list，数据存在本地 JVM 内存中<br>List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;yupi&quot;);<br>System.out.println(&quot;list:&quot; + list.get(0));<br><br>list.remove(0);<br><br>// 数据存在 redis 的内存中<br>RList&lt;String&gt; rList = redissonClient.getList(&quot;test-list&quot;);<br>rList.add(&quot;yupi&quot;);<br>System.out.println(&quot;rlist:&quot; + rList.get(0));<br>rList.remove(0);<br></code></pre></td></tr></table></figure><h3 id="定时任务-锁"><a href="#定时任务-锁" class="headerlink" title="定时任务  + 锁"></a>定时任务  + 锁</h3><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>注意释放锁要写在 finally 中</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testWatchDog</span>()</span> &#123;<br>    RLock <span class="hljs-keyword">lock</span> = redissonClient.getLock(<span class="hljs-string">&quot;yupao:precachejob:docache:lock&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 只有一个线程能获取到锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>.tryLock(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-comment">// todo 实际要执行的方法</span><br>            doSomeThings();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;getLock: &quot;</span> + Thread.currentThread().getId());<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(e.getMessage());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 只能释放自己的锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>.isHeldByCurrentThread()) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;unLock: &quot;</span> + Thread.currentThread().getId());<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h3><blockquote><p>redisson 中提供的续期机制</p></blockquote><p>开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。</p><p>原理：</p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p><a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p><hr><p>Zookeeper 实现（不推荐）</p><h3 id="组队功能-1h"><a href="#组队功能-1h" class="headerlink" title="组队功能 1h"></a>组队功能 1h</h3><p>理解为王者荣耀</p><h4 id="理想的应用场景"><a href="#理想的应用场景" class="headerlink" title="理想的应用场景"></a>理想的应用场景</h4><p>我要跟别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍</p><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p><strong>用户创建队伍最多 5 个</strong></p></blockquote><p>展示队伍列表，根据名称搜索队伍  P0，信息流中不展示已过期的队伍</p><p>修改队伍信息 P0 ~ P1</p><p>用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限  P0</p><blockquote><p>是否需要队长同意？筛选审批？</p></blockquote><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 —— 先来后到） P1</p><p>队长可以解散队伍 P0</p><hr><p>分享队伍 &#x3D;》 邀请其他用户加入队伍 P1</p><p>业务流程：</p><ol><li>生成分享链接（分享二维码）</li><li>用户访问链接，可以点击加入</li></ol><p>队伍人满后发送消息通知 P1</p><h4 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h4><h5 id="1、创建队伍"><a href="#1、创建队伍" class="headerlink" title="1、创建队伍"></a>1、创建队伍</h5><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p>信息流中不展示已过期的队伍</p></blockquote><ol><li>请求参数是否为空？</li><li>是否登录，未登录不允许创建</li><li>校验信息<ol><li>队伍人数 &gt; 1 且 &lt;&#x3D; 20</li><li>队伍标题 &lt;&#x3D; 20</li><li>描述 &lt;&#x3D; 512</li><li>status 是否公开（int）不传默认为 0（公开）</li><li>如果 status 是加密状态，一定要有密码，且密码 &lt;&#x3D; 32</li><li>超时时间 &gt; 当前时间</li><li>校验用户最多创建 5 个队伍</li></ol></li><li>插入队伍信息到队伍表</li><li>插入用户  &#x3D;&gt; 队伍关系到关系表</li></ol><h5 id="2、查询队伍列表"><a href="#2、查询队伍列表" class="headerlink" title="2、查询队伍列表"></a>2、查询队伍列表</h5><p>分页展示队伍列表，根据名称、最大人数等搜索队伍  P0，信息流中不展示已过期的队伍</p><ol><li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li><li>不展示已过期的队伍（根据过期时间筛选）</li><li>可以通过某个<strong>关键词</strong>同时对名称和描述查询</li><li><strong>只有管理员才能查看加密还有非公开的房间</strong></li><li>关联查询已加入队伍的用户信息</li><li><strong>关联查询已加入队伍的用户信息（可能会很耗费性能，建议大家用自己写 SQL 的方式实现）</strong></li></ol><p><strong>实现方式</strong></p><p>1）自己写 SQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">// 1. 自己写 SQL<br>// 查询队伍和创建人的信息<br>// <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> team t <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">on</span> t.userId = u.id<br>// 查询队伍和已加入队伍成员的信息<br>// <span class="hljs-keyword">select</span> *<br>// <span class="hljs-keyword">from</span> team t<br>//         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_team ut <span class="hljs-keyword">on</span> t.id = ut.teamId<br>//         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">on</span> ut.userId = u.id;<br></code></pre></td></tr></table></figure><h5 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3. 修改队伍信息"></a>3. 修改队伍信息</h5><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者队伍的创建者可以修改</li><li>如果用户传入的新值和老值一致，就不用 update 了（可自行实现，降低数据库使用次数）</li><li><strong>如果队伍状态改为加密，必须要有密码</strong></li><li>更新成功</li></ol><h5 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4. 用户可以加入队伍"></a>4. 用户可以加入队伍</h5><p>其他人、未满、未过期，允许加入多个队伍，但是要有个上限  P0</p><ol><li>用户最多加入 5 个队伍</li><li>队伍必须存在，只能加入未满、未过期的队伍</li><li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入的队伍是加密的，必须密码匹配才可以</li><li>新增队伍 - 用户关联信息</li></ol><p><strong>注意，一定要加上事务注解！！！！</strong></p><h5 id="5-用户可以退出队伍"><a href="#5-用户可以退出队伍" class="headerlink" title="5. 用户可以退出队伍"></a>5. 用户可以退出队伍</h5><p>请求参数：队伍 id</p><ol><li><p>校验请求参数</p></li><li><p>校验队伍是否存在</p></li><li><p>校验我是否已加入队伍</p></li><li><p>如果队伍</p><ol><li><p>只剩一人，队伍解散</p></li><li><p>还有其他人</p><ol><li><p>如果是队长退出队伍，权限转移给第二早加入的用户 —— 先来后到</p><blockquote><p>只用取 id 最小的 2 条数据</p></blockquote></li><li><p>非队长，自己退出队伍</p></li></ol></li></ol></li></ol><h5 id="6-队长可以解散队伍"><a href="#6-队长可以解散队伍" class="headerlink" title="6. 队长可以解散队伍"></a>6. 队长可以解散队伍</h5><p>请求参数：队伍 id</p><p>业务流程：</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验你是不是队伍的队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><h5 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7. 获取当前用户已加入的队伍"></a>7. 获取当前用户已加入的队伍</h5><h5 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8. 获取当前用户创建的队伍"></a>8. 获取当前用户创建的队伍</h5><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p><hr><h4 id="事务注解"><a href="#事务注解" class="headerlink" title="事务注解"></a>事务注解</h4><p>@Transactional(rollbackFor &#x3D; Exception.class)</p><p>要么数据操作都成功，要么都失败</p><h3 id="数据库表设计-1"><a href="#数据库表设计-1" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>队伍表 team</p><p>字段：</p><ul><li>id 主键 bigint（最简单、连续，放 url 上比较简短，但缺点是爬虫）</li><li>name 队伍名称</li><li>description 描述</li><li>maxNum 最大人数</li><li>expireTime 过期时间</li><li>userId 创建人 id</li><li>status 0 - 公开，1 - 私有，2 - 加密</li><li>password 密码</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    name   <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)                   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;队伍名称&#x27;</span>,<br>    description <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>)                      <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    maxNum    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;最大人数&#x27;</span>,<br>    expireTime    datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;过期时间&#x27;</span>,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    status    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;0 - 公开，1 - 私有，2 - 加密&#x27;</span>,<br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)                       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>    <br>        createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;队伍&#x27;</span>;<br></code></pre></td></tr></table></figure><p>用户  - 队伍表 user_team</p><p>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    teamId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;队伍id&#x27;</span>,<br>    joinTime datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;加入时间&#x27;</span>,<br>    createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;用户队伍关系&#x27;</span>;<br></code></pre></td></tr></table></figure><p>两个关系：</p><ol><li>用户加了哪些队伍？</li><li>队伍有哪些用户？</li></ol><p>方式：</p><ol><li>建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）</li></ol><h4 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h4><ol><li><p>请求参数名称 &#x2F; 类型和实体类不一样</p></li><li><p>有一些参数用不到，如果要自动生成接口文档，会增加理解成本</p></li><li><p>对个实体类映射到同一个对象</p></li></ol><h4 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h4><p>可能有些字段需要隐藏，不能返回给前端</p><p>或者有些字段某些方法是不关心的</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>库表设计 5 - 10min</p><p>增删改查 5 - 10 min</p><p>业务逻辑开发（P0）30 min</p><h2 id="2022-09-18-12-期"><a href="#2022-09-18-12-期" class="headerlink" title="2022-09-18 12 期"></a>2022-09-18 12 期</h2><ol><li>开发前端的功能<ol><li>搜索队伍 √</li><li>更新队伍（仅队伍的创始人可见） √</li><li>查看个人已加入队伍 √</li><li>查看个人创建的队伍 √</li><li>解散队伍 √</li><li>退出队伍 √</li></ol></li><li>随机匹配 30 - 40 min</li><li>完成之前的遗留问题 todo</li></ol><h3 id="前端不同页面怎么传递数据？"><a href="#前端不同页面怎么传递数据？" class="headerlink" title="前端不同页面怎么传递数据？"></a>前端不同页面怎么传递数据？</h3><ol><li><strong>url querystring（xxx?id&#x3D;1）</strong> 比较适用于页面跳转</li><li><strong>url（&#x2F;team&#x2F;:id，xxx&#x2F;1）</strong></li><li>hash (&#x2F;team#1)</li><li>localStorage</li><li><strong>context（全局变量，同页面或整个项目要访问公共变量）</strong></li></ol><h3 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h3><blockquote><p>为了帮大家更快地发现和自己兴趣相同的朋友</p></blockquote><p>匹配 1 个还是匹配多个？</p><p>答：匹配多个，并且按照匹配的相似度从高到低排序</p><p>怎么匹配？（根据什么匹配）</p><p>答：标签 tags</p><blockquote><p>还可以根据 user_team 匹配加入相同队伍的用户</p></blockquote><p>本质：找到有相似标签的用户</p><p>举例：</p><p>用户 A：[Java, 大一, 男]</p><p>用户 B：[Java, 大二, 男]</p><p>用户 C：[Python, 大二, 女]</p><p>用户 D：[Java, 大一, 女]</p><h4 id="1-怎么匹配"><a href="#1-怎么匹配" class="headerlink" title="1. 怎么匹配"></a>1. 怎么匹配</h4><ol><li>找到有共同标签最多的用户（TopN）</li><li>共同标签越多，分数越高，越排在前面</li><li>如果没有匹配的用户，随机推荐几个（降级方案）</li></ol><p>编辑距离算法：<a href="https://blog.csdn.net/DBC_121/article/details/104198838">https://blog.csdn.net/DBC_121/article/details/104198838</a></p><blockquote><p>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2</p></blockquote><p>余弦相似度算法：<a href="https://blog.csdn.net/m0_55613022/article/details/125683937%EF%BC%88%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B8%A6%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%A6%E4%BB%80%E4%B9%88%E6%96%B9%E5%90%91%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%8C%E6%80%A7%E5%88%AB%E7%9B%B8%E5%AF%B9%E6%AC%A1%E8%A6%81%EF%BC%89">https://blog.csdn.net/m0_55613022/article/details/125683937（如果需要带权重计算，比如学什么方向最重要，性别相对次要）</a></p><h4 id="2-怎么对所有用户匹配，取-TOP"><a href="#2-怎么对所有用户匹配，取-TOP" class="headerlink" title="2. 怎么对所有用户匹配，取 TOP"></a>2. 怎么对所有用户匹配，取 TOP</h4><p>直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）</p><p>优化方法：</p><ol><li><p>切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒）</p></li><li><p>Map 存了所有的分数信息，占用内存</p><p>解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）</p><p>e.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了</p></li><li><p>细节：剔除自己 √</p></li><li><p>尽量只查需要的数据：</p><ol><li>过滤掉标签为空的用户 √</li><li>根据部分标签取用户（前提是能区分出来哪个标签比较重要）</li><li>只查需要的数据（比如 id 和 tags） √（7.0s）</li></ol></li><li><p>提前查？（定时任务）</p><ol><li>提前把所有用户给缓存（不适用于经常更新的数据）</li><li>提前运算出来结果，缓存（针对一些重点用户，提前缓存）</li></ol></li></ol><p>大数据推荐，比如说有几亿个商品，难道要查出来所有的商品？</p><p>难道要对所有的数据计算一遍相似度？</p><p>检索 &#x3D;&gt; 召回 &#x3D;&gt; 粗排 &#x3D;&gt; 精排 &#x3D;&gt; 重排序等等</p><p>检索：尽可能多地查符合要求的数据（比如按记录查）</p><p>召回：查询可能要用到的数据（不做运算）</p><p>粗排：粗略排序，简单地运算（运算相对轻量）</p><p>精排：精细排序，确定固定排位</p><h3 id="分表学习建议"><a href="#分表学习建议" class="headerlink" title="分表学习建议"></a>分表学习建议</h3><p>mycat、sharding sphere 框架</p><p>一致性 hash</p><h3 id="队伍操作权限控制"><a href="#队伍操作权限控制" class="headerlink" title="队伍操作权限控制"></a>队伍操作权限控制</h3><p>加入队伍： 仅非队伍创建人、且未加入队伍的人可见</p><p>更新队伍：仅创建人可见</p><p>解散队伍：仅创建人可见</p><p>退出队伍：创建人不可见，仅已加入队伍的人可见</p><p>加载骨架屏特效 ✔</p><p>解决：van-skeleton 组件</p><p>仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态） ✔</p><p>方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）</p><p>方案 2：在后端去做上述事情（推荐）</p><p>前端导航栏死【标题】问题 ✔</p><p>解决：使用 router.beforeEach，根据要跳转页面的 url 路径 匹配 config&#x2F;routes 配置的 title 字段。</p><h2 id="14-优化、上线"><a href="#14-优化、上线" class="headerlink" title="14 优化、上线"></a>14 优化、上线</h2><p>1、强制登录，自动跳转到登录页</p><p>解决：axios 全局配置响应拦截、并且添加重定向</p><p>2、区分公开和加密房间；加入有密码的房间，要指定密码</p><p>3、展示已加入队伍人数</p><p>4、重复加入队伍的问题（加锁、分布式锁）并发请求时可能出现问题</p><p><strong>分布式锁</strong></p><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><p>先区分多环境：前端区分开发和线上接口，后端 prod 改为用线上公网可访问的数据库</p><p>前端：Vercel（免费）</p><p><a href="https://vercel.com/">https://vercel.com/</a></p><p>后端：微信云托管（部署容器的平台，付费）</p><p><a href="https://cloud.weixin.qq.com/cloudrun/service">https://cloud.weixin.qq.com/cloudrun/service</a></p><p><strong>（免备案！！！）</strong></p><h2 id="如何改造成小程序？"><a href="#如何改造成小程序？" class="headerlink" title="如何改造成小程序？"></a>如何改造成小程序？</h2><p><strong>cordova、跨端开发框架 taro、uniapp</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
