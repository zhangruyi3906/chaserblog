<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024-5-6</title>
    <link href="/chaserblog/2024/05/06/2024-5-6/"/>
    <url>/chaserblog/2024/05/06/2024-5-6/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo图片显示问题"><a href="#Hexo图片显示问题" class="headerlink" title="Hexo图片显示问题"></a>Hexo图片显示问题</h1><p>刚刚在写博客时碰到了一个问题，就是为啥图片放上去后发现不显示呢？😣还给我报个错：The requested content cannot be loaded，Please try again later.</p><p>首先我直接 F12 看了图片的地址，由于我写的是相对地址，所以这显示的就是我写的相对地址😐。我直接给我头一拍，真混蛋，相对地址只能在本地 .md 上看见，这怎么能写相对地址呢！但是我又不想每张图片都整绝对地址(<del>绝对不是懒😁</del>)，那必须是得有帮手来代理一下路径，由此引发出今天这篇博客。</p><h3 id="让创建博客时顺便创建同名文件夹"><a href="#让创建博客时顺便创建同名文件夹" class="headerlink" title="让创建博客时顺便创建同名文件夹"></a>让创建博客时顺便创建同名文件夹</h3><p>如果要存储博客的图片，那必是要找个文件夹，那么同目录下的同名文件夹肯定是最好的，便于查找和管理嘛。对于这个需求，其实只需要修改 Hexo 的配置即可。</p><p>我们来到根目录下打开 Hexo 的配置文件 ——config.yml，在这里面查找一个属性：<code>post_asset_folder</code>，</p><p>就是他</p><p><a href="http://106.14.41.16/2024/04/26/hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/post_assert_folder.png"><img src="/chaserblog/chaserblog/2024/05/06/2024-5-6/Hexo/blog/source/_posts/2024-5-6/post_assert_folder.png" alt="post_assert_folder"></a></p><p>post_assert_folder</p><p>将他的值改为 true，就可实现创建文章同时创建同名文件夹。</p><h3 id="安装代理路径的插件"><a href="#安装代理路径的插件" class="headerlink" title="安装代理路径的插件"></a>安装代理路径的插件</h3><p>上面讲了如果不用绝对路径，那么就得安装一个代理路径的插件，在博客的路径下打开 cmd 输入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image<br><br>BASH<br></code></pre></td></tr></table></figure><p>这样就可以了。嗯，对，你没看错，就可以了🤪</p><p>其实还得执行一步，这就是老生常谈的三步走啦：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo s<br><br>BASH<br></code></pre></td></tr></table></figure><p>OK，这样的话你只要在插入图片时直接输入图片文件名就好了，就像这样：</p><p><a href="http://106.14.41.16/2024/04/26/hexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87.png"><img src="/chaserblog/chaserblog/2024/05/06/2024-5-6/Hexo/blog/source/_posts/2024-5-6/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87.png" alt="插入图片"></a></p><p>插入图片</p><p>不过这样的话在本地是看不见的，只能在博客上看见，因此不用担心。这样的话博客图片问题就解决啦！😊</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-5.3</title>
    <link href="/chaserblog/2024/05/03/2024-5-3/"/>
    <url>/chaserblog/2024/05/03/2024-5-3/</url>
    
    <content type="html"><![CDATA[<ol><li><p>pnpm create vue ERROR: This version of pnpm requires at least Node.js v18.12 The current version of Node.js is v16.17.1 Visit <a href="https://r.pnpm.io/comp">https://r.pnpm.io/comp</a>  to see the list of past pnpm versions with respective Node.js version support.</p><p>解决办法：</p><p>npm install -g pnpm@8</p></li><li><p>今天购买了鱼皮的课程，这也是值得的。听了一下鱼皮讲解的简历如何写。</p></li><li><p>学习了js相关的语法，自己再总结一下相关的内容。</p></li><li><p>今天开始写智慧手环的前端页面，安装了fitten code AI插件，提高书写效率&#x3D;》性能堪比copilot。</p></li><li><p>今天看了一下MQTT协议的内容，是知识星球上一个up主分享的。</p></li></ol><h1 id="开始今天的前端项目搭建"><a href="#开始今天的前端项目搭建" class="headerlink" title="开始今天的前端项目搭建"></a>开始今天的前端项目搭建</h1><ol><li><h2 id="pnpm-包管理器-创建项目"><a href="#pnpm-包管理器-创建项目" class="headerlink" title="pnpm 包管理器 - 创建项目"></a>pnpm 包管理器 - 创建项目</h2><p>安装方式：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g pnpm<br></code></pre></td></tr></table></figure><p>创建项目：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pnpm create vue</span><br></code></pre></td></tr></table></figure></li><li><h2 id="ESLint-prettier-配置代码风格"><a href="#ESLint-prettier-配置代码风格" class="headerlink" title="ESLint &amp; prettier 配置代码风格"></a>ESLint &amp; prettier 配置代码风格</h2><p><strong>环境同步：</strong></p><ol><li><strong>安装了插件 ESlint，开启保存自动修复</strong></li><li><strong>禁用了插件 Prettier，并关闭保存自动格式化</strong></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// ESlint插件 + Vscode配置 实现自动格式化修复</span><br><span class="hljs-string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;source.fixAll&quot;</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-string">&quot;editor.formatOnSave&quot;</span>: <span class="hljs-literal">false</span>,<br></code></pre></td></tr></table></figure><p><strong>配置文件 .eslintrc.cjs</strong></p><ol><li><p>prettier 风格配置 <a href="https://prettier.io/docs/en/options.html">https://prettier.io</a></p><ol><li><p>单引号</p></li><li><p>不使用分号</p></li><li><p>每行宽度至多80字符</p></li><li><p>不加对象|数组最后逗号</p></li><li><p>换行符号不限制（win mac 不一致）</p></li></ol></li><li><p>vue组件名称多单词组成（忽略index.vue）</p></li><li><p>props解构（关闭）</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">rules</span>: &#123;<br>  <span class="hljs-string">&#x27;prettier/prettier&#x27;</span>: [<br>    <span class="hljs-string">&#x27;warn&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">singleQuote</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 单引号</span><br>      <span class="hljs-attr">semi</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 无分号</span><br>      <span class="hljs-attr">printWidth</span>: <span class="hljs-number">80</span>, <span class="hljs-comment">// 每行宽度至多80字符</span><br>      <span class="hljs-attr">trailingComma</span>: <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-comment">// 不加对象|数组最后逗号</span><br>      <span class="hljs-attr">endOfLine</span>: <span class="hljs-string">&#x27;auto&#x27;</span> <span class="hljs-comment">// 换行符号不限制（win mac 不一致）</span><br>    &#125;<br>  ],<br>  <span class="hljs-string">&#x27;vue/multi-word-component-names&#x27;</span>: [<br>    <span class="hljs-string">&#x27;warn&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">ignores</span>: [<span class="hljs-string">&#x27;index&#x27;</span>] <span class="hljs-comment">// vue组件名称多单词组成（忽略index.vue）</span><br>    &#125;<br>  ],<br>  <span class="hljs-string">&#x27;vue/no-setup-props-destructure&#x27;</span>: [<span class="hljs-string">&#x27;off&#x27;</span>], <span class="hljs-comment">// 关闭 props 解构的校验</span><br>  <span class="hljs-comment">// 💡 添加未定义变量错误提示，create-vue@3.6.3 关闭，这里加上是为了支持下一个章节演示。</span><br>  <span class="hljs-string">&#x27;no-undef&#x27;</span>: <span class="hljs-string">&#x27;error&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-基于-husky-的代码检查工作流"><a href="#3-基于-husky-的代码检查工作流" class="headerlink" title="3. 基于 husky  的代码检查工作流"></a>3. 基于 husky  的代码检查工作流</h2><p>husky 是一个 git hooks 工具  ( git的钩子工具，可以在特定时机执行特定的命令 )</p><p><strong>husky 配置</strong></p><ol><li><p>git初始化 git init</p></li><li><p>初始化 husky 工具配置  <a href="https://typicode.github.io/husky/">https://typicode.github.io/husky/</a></p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">pnpm dlx husky-init &amp;&amp; pnpm install<br></code></pre></td></tr></table></figure><ol start="3"><li>修改 .husky&#x2F;pre-commit 文件</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">pnpm lint<br></code></pre></td></tr></table></figure><p><strong>问题：</strong>默认进行的是全量检查，耗时问题，历史问题。</p><p><strong>lint-staged 配置</strong></p><ol><li>安装</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">pnpm i lint-staged -D<br></code></pre></td></tr></table></figure><ol start="2"><li>配置 <code>package.json</code></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&#123;<br>  <span class="hljs-comment">// ... 省略 ...</span><br>  <span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;*.&#123;js,ts,vue&#125;&quot;</span>: [<br>      <span class="hljs-string">&quot;eslint --fix&quot;</span><br>    ]<br>  &#125;<br>&#125;<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-comment">// ... 省略 ...</span><br>    <span class="hljs-string">&quot;lint-staged&quot;</span>: <span class="hljs-string">&quot;lint-staged&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改 .husky&#x2F;pre-commit 文件</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">pnpm lint-staged<br></code></pre></td></tr></table></figure></li><li><h2 id="调整项目目录"><a href="#调整项目目录" class="headerlink" title="调整项目目录"></a>调整项目目录</h2><p>默认生成的目录结构不满足我们的开发需求，所以这里需要做一些自定义改动。主要是两个工作：</p><ul><li>删除初始化的默认文件</li><li>修改剩余代码内容</li><li>新增调整我们需要的目录结构</li><li>拷贝初始化资源文件，安装预处理器插件</li></ul><ol><li>删除文件</li><li>修改内容</li></ol></li><li><h2 id="引入-element-ui-组件库"><a href="#引入-element-ui-组件库" class="headerlink" title="引入 element-ui 组件库"></a>引入 element-ui 组件库</h2><p><strong>官方文档：</strong> <a href="https://element-plus.org/zh-CN/">https://element-plus.org/zh-CN/</a></p><ul><li>安装</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">$ pnpm add element-plus<br></code></pre></td></tr></table></figure><p><strong>自动按需：</strong></p><ol><li>安装插件</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">pnpm add -D unplugin-vue-components unplugin-auto-<span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure><ol start="2"><li>然后把下列代码插入到你的 <code>Vite</code> 或 <code>Webpack</code> 的配置文件中</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx">...<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    ...<br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()]<br>    &#125;),<br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()]<br>    &#125;)<br>  ]<br>&#125;)<br><br></code></pre></td></tr></table></figure><ol start="3"><li>直接使用</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>Primary<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>Success<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>Info<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;warning&quot;</span>&gt;</span>Warning<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;danger&quot;</span>&gt;</span>Danger<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">    ...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li><h2 id="pinia仓库配置"><a href="#pinia仓库配置" class="headerlink" title="pinia仓库配置"></a>pinia仓库配置</h2></li><li><h2 id="完成axios配置"><a href="#完成axios配置" class="headerlink" title="完成axios配置"></a>完成axios配置</h2></li><li><h2 id="首页整体路由设计"><a href="#首页整体路由设计" class="headerlink" title="首页整体路由设计"></a>首页整体路由设计</h2></li></ol></li></ol><p><strong>实现目标:</strong></p><ul><li>完成整体路由规划【搞清楚要做几个页面，它们分别在哪个路由下面，怎么跳转的…..】</li><li>通过观察,  点击左侧导航,  右侧区域在切换,  那右侧区域内容一直在变,  那这个地方就是一个路由的出口</li><li>我们需要搭建嵌套路由</li></ul><p>目标：</p><ul><li>把项目中所有用到的组件及路由表, 约定下来</li></ul><p><strong>约定路由规则</strong></p><table><thead><tr><th>path</th><th>文件</th><th>功能</th><th>组件名</th><th>路由级别</th></tr></thead><tbody><tr><td>登录</td><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;login</td><td>views&#x2F;login&#x2F;LoginPage.vue</td><td>登录&amp;注册</td><td>LoginPage</td><td>一级路由</td></tr><tr><td>布局</td><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;</td><td>views&#x2F;layout&#x2F;LayoutContainer.vue</td><td>布局架子</td><td>LayoutContainer</td><td>一级路由</td></tr><tr><td>工作台：数据展示</td><td></td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;dashboard</td><td>views&#x2F;index&#x2F;DashBoard.vue</td><td>数据展示</td><td>dashboard</td><td>二级路由</td></tr><tr><td>关爱人管理</td><td>添加关爱人、关爱人列表、关爱人详情、关爱人历史信息</td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;guadian&#x2F;addGuadian</td><td>views&#x2F;guadian&#x2F;AddGuadian.vue</td><td>添加关爱人</td><td>addGuadian</td><td>二级路由</td></tr><tr><td>├─ &#x2F;guadian&#x2F;GuadianList</td><td>views&#x2F;guadian&#x2F;GuadianList.vue</td><td>关爱人列表</td><td>GuadianList</td><td>二级路由</td></tr><tr><td>├─ &#x2F;guadian&#x2F;GuadianDetail</td><td>views&#x2F;guadian&#x2F;GuadianDetail</td><td>关爱人详情</td><td>GuadianDetail</td><td></td></tr><tr><td>├─ &#x2F;guadian&#x2F;Guardianhistory</td><td>views&#x2F;guadian&#x2F;GuadianHistory</td><td>关爱人历史信息</td><td>Guardianhistory</td><td></td></tr><tr><td>用户管理</td><td>退出、修改密码、编辑、用户信息</td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;user&#x2F;profile</td><td>views&#x2F;user&#x2F;UserProfile.vue</td><td>用户信息</td><td>UserProfile</td><td>二级路由</td></tr><tr><td>├─ &#x2F;user&#x2F;Edit</td><td>views&#x2F;user&#x2F;UserEdit.vue</td><td>编辑</td><td>UserEdit</td><td>二级路由</td></tr><tr><td>├─ &#x2F;user&#x2F;password</td><td>views&#x2F;user&#x2F;UserPassword.vue</td><td>修改密码</td><td>UserPassword</td><td>二级路由</td></tr><tr><td>├─ &#x2F;user&#x2F;logout</td><td>views&#x2F;user&#x2F;UserLogout.vue</td><td>登出</td><td>UserLogout</td><td>二级路由</td></tr><tr><td>设备管理</td><td>添加设备、删除设备</td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;device&#x2F;addDevice</td><td>views&#x2F;device&#x2F;AddDevice</td><td>添加设备</td><td>addDevice</td><td>二级路由</td></tr><tr><td>├─ &#x2F;device&#x2F;deleteDevice</td><td>views&#x2F;device&#x2F;DeleteDevice</td><td>删除设备</td><td>deleteDevice</td><td>二级路由</td></tr><tr><td>预警管理</td><td>预警记录、预警提醒</td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;emergency&#x2F;emergencyRecord</td><td>views&#x2F;emergency&#x2F;EmergencyRecord</td><td>预警记录</td><td>emergencyRecord</td><td>二级路由</td></tr><tr><td>├─ &#x2F;emergency&#x2F;emergencyRemind</td><td>views&#x2F;emergency&#x2F;EmergencyRemind</td><td>预警提醒</td><td>emergencyRemind</td><td>二级路由</td></tr><tr><td>数据管理</td><td>数据导出、数据分析</td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;data&#x2F;dataExport</td><td>views&#x2F;data&#x2F;DataExport</td><td>数据导出</td><td>dataExport</td><td>二级路由</td></tr><tr><td>├─ &#x2F;data&#x2F;dataAnalysis</td><td>views&#x2F;data&#x2F;DataAnalysis</td><td>数据分析</td><td>dataAnalysis</td><td>二级路由</td></tr><tr><td>系统操作日志</td><td></td><td></td><td></td><td></td></tr><tr><td>├─ &#x2F;log&#x2F;logOperation</td><td>views&#x2F;log&#x2F;LogOperation</td><td>操作日志</td><td>logOperation</td><td>二级路由</td></tr></tbody></table><p>明确了路由规则，可以全部配完，也可以边写边配。</p><p>ngrok 内网穿透</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247550173&idx=1&sn=f28b5a6601ab8a5ab95ddad274e4b5ca&scene=21#wechat_redirect">不用服务器，1 分钟上线网站！ (qq.com)</a></p><p>想要让面试官相信项目是你自己做的，那么一定要能回答出以下几个问题：</p><ol><li>请介绍一下你这个项目的业务流程？包含的主要模块以及自己负责的工作。</li><li>你在做这个项目中，遇到的最大的难点、或者解决过的最复杂的 Bug 是什么？</li><li>你的项目有实际上线么？使用哪种方式进行部署？</li></ol><p>如果能答出来，那么就可以放心啦~ 答不出来就继续去准</p><p>我的搜索习惯是：<br>·搜学习资源：鱼皮的编程导航知识星球、鱼皮的编程导航、B站、网盘聚合搜索平台、CSDN<br>·搜学习路线：鱼皮的编程导航知识星球、知乎、掘金<br>·搜项目：GitHub、Npm官网、掘金、Gitee、百度开发者搜索<br>·搜资讯：InfoQ、掘金、开源中国、微信搜一搜、51CTO<br>·搜图片：百度、Google、Bing、Pexel、.Pixiv、识图软件<br>·搜Bug:百度、官方文档、Stack Overflow、GitHub Issues区、百度开发者搜索、CSDN</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024.5.2</title>
    <link href="/chaserblog/2024/05/02/2024-5-2/"/>
    <url>/chaserblog/2024/05/02/2024-5-2/</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派的使用"><a href="#树莓派的使用" class="headerlink" title="树莓派的使用"></a>树莓派的使用</h1><pre><code class="hljs">      1. 板子，散热套装，外壳，电源，内存卡32g（单买的品牌的，闪迪），配置好的完整系统，可以直接上手用</code></pre><p>  有配套文档，其他的是B站自己找的学的<br>          2. 好嘞。我看看都有啥啊，发你，其实也没多少东西。<br>          3. 树莓派就是个微型电脑 ，系统搭好之后，你在里面就可以使用命令行开发了，所以说你会Python，玩这个贼简单。<br>  这个里面最复杂的就是搭建系统，我也已经搭建好了，所以你拿到手后直接开发就行。</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502100817360.png" alt="image-20240502100817360"></p><p>这个软件投射屏幕的</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502100925126.png" alt="image-20240502100925126"></p><p>这个可以编写代码</p><ol start="4"><li><p>树莓派通过局域网和pc连接，ip（连接wifi教程B站）</p></li><li><p>同学，其实树莓派入门最难得地方就是配环境，那个视频我翻不出来了。你可以b站随便搜就行，而且你不需要配环境了。<br>其次复杂的地方就是和电脑通讯，按照我发的视频来做。</p><p>这两步做完之后，剩下就自己开发了，自己需要做什么写代码做就可以了。如果没做过这一类，你可以百度搜一下Linux指令，在命令行练一练就可以。</p></li><li><p>你之前做过Linux吗？学过的话，你做这个树莓派就贼简单，没学过的话，你就需要先了解下都有哪些指令了，记住一些常见指令。</p></li><li><p>（新）树莓派4B系统镜像ssh及WIFI远程配置资料<br>链接：<a href="https://pan.baidu.com/s/1Jan7v6DuHxY6VmYcLNfTHQ">https://pan.baidu.com/s/1Jan7v6DuHxY6VmYcLNfTHQ</a><br>提取码：tmsr</p></li><li><p>【淘宝】<a href="https://m.tb.cn/h.g0PjF29jFfqtBuU?tk=4jY6Ws2euJr">https://m.tb.cn/h.g0PjF29jFfqtBuU?tk=4jY6Ws2euJr</a> HU0854 「树莓派5 Raspberry Pi 5代 套件 4g 8g 开发板 Arm Cortex-A76 5b」<br>点击链接直接打开 或者 淘宝搜索直接打开（这是我买东西的链接。）</p></li><li><p>我觉得你可以网上找个现成的简单项目代码，然后一行一行查，那段代码学会了你也就会Python了</p></li><li><p>推荐一个嘛。我现在手里也没有。<br>你可以这样，csdn上搜卷积神经网络Python代码，然后成套代码，然后里面代码使用gtp辅助帮你理解每一行代码。<br>一行一样学，学完了就大概知道了啥意思了，再捋两边，至少你就能读懂Python了，然后可以自己尝试写个简单代码试试。</p></li><li><p>这只我个人学习方法，可以试试适合你不。我最开始学的c，然后学的c#，后来发现这些语言看书学的贼慢，直接看代码效率高很多，所以后来的Python，JAVA啥的都是这样学的。自我感觉这方法还可以。</p></li><li><p>看书学编程是最慢的方法，学了好几天，还在前几页呆着呢，合上书，还是啥也不会</p></li><li><p>方法就这么方法，利用好csdn，github这些平台。不会就差，现在嘛，啥都能查到，可能有的方法不对，那就换下一个。代码不明白了，找gtp辅助</p></li><li><p>多简单啊，但是总得自己动手。自己能顺利完成一个了，之后就顺利多了</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><p>首先保证电脑和树莓派连一个无线网（不要连校园网，使用路由器那种，或者手机流量开热点）</p></li><li><p>树莓派第一次连接无线网，我发的资料聊有设置默认链接WIFI教程</p></li><li><p>也可以使用网线连接路由器进行有线连接   <a href="https://blog.csdn.net/bhniunan/article/details/104814904">树莓派入门（七）—— 树莓派4Bwifi无线上网配置</a></p><p>先要将sd卡插入到usb3.0读卡器上，再将读卡器插入到电脑上，增加两个文件，用cd. &gt; ssh添加一个ssh文件</p><p>注意：添加文件时一定要右键以管理员方式打开cmd，添加才会有效</p><p>用 cd. &gt; upclient 添加一个文件，在这个文件中添加语句，使树莓派能开机就连接到wifi。</p><p>ARP（<a href="https://so.csdn.net/so/search?q=%E5%9C%B0%E5%9D%80&spm=1001.2101.3001.7020">地址</a>解析协议）</p><p>地址解析协议，即ARP（Address <a href="https://so.csdn.net/so/search?q=Resolution&spm=1001.2101.3001.7020">Resolution</a> Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。arp -a参数的含义就是通过询问当前协议数据，显示当前 ARP 项。如果指定 inet_addr，则只显示指定计算机的 IP 地址和物理地址。如果不止一个网络接口使用 ARP，则显示每个 ARP 表的项。</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502104205355.png" alt="image-20240502104205355"></p><p>win+R</p><p>ARP -A</p><p>树莓派ip地址</p></li><li><p>然后在cmd中输入图片中命令，查找树莓派ip</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502101456385.png" alt="image-20240502101456385"></p></li><li><p>然后打开mobaxterm软件</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502101518931.png" alt="image-20240502101518931"></p></li><li><p>这个界面输入ip就可以。然后进入一个界面，输入账户   pi。密码 raspberry  输的时候不显示，然后进入下面的界面。</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502101608812.png" alt="image-20240502101608812"></p></li><li><p>就跟Linux一样了，操作编程就可以了</p></li><li><p>显示，打开vnc</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502101646241.png" alt="image-20240502101646241"></p></li><li><p>点这里，然后输入ip，就可以看到屏幕了。</p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502101723199.png" alt="image-20240502101723199"></p><p><img src="/chaserblog/chaserblog/2024/05/02/2024-5-2/Hexo/blog/source/_posts/assets/image-20240502101751007.png" alt="image-20240502101751007"></p></li><li><p>风扇我接好了，以后需要屏幕，买块屏幕接上就可以，具体引脚接口啥的，你可以查下之前发的资料或百度。</p></li></ol></li></ol><p>查看磁盘空间：df -h </p><p>&#x2F;dev&#x2F;root 7.2G 5.9G 955M 87% &#x2F;<br>devtmpfs 458M 0 458M 0% &#x2F;dev<br>tmpfs 462M 0 462M 0% &#x2F;dev&#x2F;shm<br>tmpfs 462M 6.4M 456M 2% &#x2F;run<br>tmpfs 5.0M 4.0K 5.0M 1% &#x2F;run&#x2F;lock<br>tmpfs 462M 0 462M 0% &#x2F;sys&#x2F;fs&#x2F;cgroup<br>&#x2F;dev&#x2F;sda1 22G 23M 22G 1% &#x2F;boot<br>tmpfs 93M 0 93M 0% &#x2F;run&#x2F;user&#x2F;1000<br>root@raspberrypi:&#x2F;home#</p><p>vnc要连接上的话，要在mobaXterm中输入vncserver，</p><p>树莓派换源：</p><p><a href="https://blog.csdn.net/qq_45396672/article/details/121616103?ops_request_misc=%7B%22request_id%22:%22171464903116800185850591%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171464903116800185850591&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-121616103-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E8%BF%90%E8%A1%8Cpython&spm=1018.2226.3001.4187">树莓派服务器自动执行python脚本_树莓派python两个程序,如何一个先进行后一个自动进行-CSDN博客</a></p><p>树莓派vi编辑操作<a href="https://blog.csdn.net/ShenZhen_zixian/article/details/119343622?ops_request_misc=%7B%22request_id%22:%22171464930216800182755761%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171464930216800182755761&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-119343622-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BEvi%E5%A6%82%E4%BD%95%E7%BC%96%E8%BE%91&spm=1018.2226.3001.4187">树莓派从零开始快速入门第3讲——文件编辑_树莓派编辑文件的指令-CSDN博客</a></p><h1 id="树莓派运行sudo-apt-get-update报错"><a href="#树莓派运行sudo-apt-get-update报错" class="headerlink" title="树莓派运行sudo apt-get update报错"></a>树莓派运行sudo apt-get update报错</h1><p>[树莓派运行sudo apt-get update报错_树莓派 sudo apt upgrade 时内核崩溃-CSDN博客](<a href="https://blog.csdn.net/dps2023502/article/details/131882671?ops_request_misc=%7B%22request_id%22:%22171465086116800197047453%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171465086116800197047453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-131882671-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E6%AD%A3%E5%9C%A8%E8%AF%BB%E5%8F%96%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8">https://blog.csdn.net/dps2023502/article/details/131882671?ops_request_misc=%7B%22request%5Fid%22%3A%22171465086116800197047453%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171465086116800197047453&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-131882671-null-null.142^v100^pc_search_result_base4&amp;utm_term=正在读取软件包列表</a>… 完成                                             E%3A 仓库http%3A%2F%2Fraspbian.raspberrypi.org%2Fraspbian buster InRelease将其Suite值从stable修改到了oldoldstable N%3A 为了让这个仓库能够应用，这必须在更新之前显式接受。更多细节请参阅 ap&amp;spm&#x3D;1018.2226.3001.4187)</p><p>修复方法</p><p>运行 ：</p><p>sudo apt-get -y update –allow-releaseinfo-change</p><p>2、查看镜像源</p><p>sudo vi &#x2F;etc&#x2F;apt&#x2F;sources.list</p><p>更新镜像源</p><p>deb <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>deb-src <a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi<br>——————</p><p>[树莓派安装scratch3时，更新系统失败_debian安装 scratch3.0-CSDN博客](<a href="https://blog.csdn.net/u012611963/article/details/127025846?ops_request_misc=%7B%22request_id%22:%22171465086116800197047453%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=171465086116800197047453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127025846-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E6%AD%A3%E5%9C%A8%E8%AF%BB%E5%8F%96%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%88%97%E8%A1%A8">https://blog.csdn.net/u012611963/article/details/127025846?ops_request_misc=%7B%22request%5Fid%22%3A%22171465086116800197047453%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171465086116800197047453&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127025846-null-null.142^v100^pc_search_result_base4&amp;utm_term=正在读取软件包列表</a>… 完成                                             E%3A 仓库http%3A%2F%2Fraspbian.raspberrypi.org%2Fraspbian buster InRelease将其Suite值从stable修改到了oldoldstable N%3A 为了让这个仓库能够应用，这必须在更新之前显式接受。更多细节请参阅 ap&amp;spm&#x3D;1018.2226.3001.4187)</p><p>使用conda配置python环境</p><p><a href="https://blog.csdn.net/qq_45396672/article/details/121616103?ops_request_misc=%7B%22request_id%22:%22171464903116800185850591%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171464903116800185850591&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-121616103-null-null.142%5Ev100%5Epc_search_result_base4&utm_term=%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E8%BF%90%E8%A1%8Cpython&spm=1018.2226.3001.4187">树莓派服务器自动执行python脚本_树莓派python两个程序,如何一个先进行后一个自动进行-CSDN博客</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/"/>
    <url>/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>总结：你用什么技术，解决了什么问题，达到了什么效果，优化提高了效率。</p><p><img src="/chaserblog/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427192526166.png" alt="image-20240427192526166"></p><p><img src="/chaserblog/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427193048993.png" alt="image-20240427193048993"></p><p>简历应该怎么写才能吸引面试官呢？</p><p>在我的简历中，包含几部分：个人基本信息、个人描述、荣誉奖项、科研学术经历、实习经历、项目经历、技术栈，这些都是一份优质程序员简历上都该有的关键信息。</p><p><img src="/chaserblog/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427191643229.png" alt="image-20240427191643229"></p><p>凭着这份简历，我也是百投百中，秋招时很多公司的笔试都没参与就收到了面试邀约。这份简历也曾经被同事、B 站知名 UP 主拿去分享，帮助大家学习写简历的技巧。</p><p>但事实上，人外有人，天外有天。至今为止，我已经向腾讯内推了 300 多名 同学，每一位投递人的简历我都有阅读，看了这么多，也发现了很多让我拍案叫绝的简历。我不禁感慨，自己的简历的确还有待提高啊，要不是堆了一些奖项，估计也就被其他大佬压在地上摩擦了。</p><p>其中有一份简历让我印象深刻，不仅是因为他的主人，正是我的 同校直系 学弟，我大四在学校举办腾讯云开发校园作坊时，他还主动和我交流了一段时间。当然，更重要的是，他的这份简历，在我看来是非常非常优秀的，即使简历上没有任何一个竞赛奖项或科研成果，但通过一些小技巧，依旧能够吸引面试官！</p><p>后来学弟果然被发起了面试邀约，最后也成功通过了面试，拿到了腾讯的 offer，现在是我的同事哈哈~</p><p>所以我把他的简历称为 “标杆简历”，我认为所有同学都能够且应该学习和参考他的简历，从而增加你进入面试的概率。</p><p>在征得学弟的同意后，脱敏分享给大家~</p><p>简历内容<br>这份简历只有一页，非常精简，内容分为 教育经历、技术栈、实习经历、项目经历 四部分。</p><p>学弟的简历<br>教育经历<br>学校：上海 XXX 工程院校 本科在读</p><p>专业：软件工程</p><p>外语：大一时通过 CET4􏰉、CET􏰅6 考试</p><p>技术栈<br>后端</p><p>熟悉: Java</p><p>了解：SpringCloud、Express.js、Node.js、Python</p><p>数据库</p><p>熟悉：MySQL</p><p>了解：MongoDB</p><p>中间件</p><p>了解：Redis、RabbitMQ、Elasticsearch</p><p>DevOps</p><p>了解：微服务、Jenkins、Gitlab CI &#x2F; CD、Nginx、Traefik、Linux</p><p>云计算</p><p>了解:  Docker、Kubernetes</p><p>前端</p><p>了解:  React、React Native、Javascript、HTML、CSS、Grafana</p><p>实习经历<br>腾讯科技有限公司 后端开发工程师（实习）</p><p>在腾讯 XX 部门从事 管理系统 开发，主要参与故障处理平台建设</p><p>完成故障处理流程灰度、流程版本升级功能的需求分析、数据库设计、界面原型设计以及前后端实现，加快了运营团队的迭代速度</p><p>为方便团队掌握大规模故障的情况，参与了大规模告警机制的开发流程，并为其开发前端交互界面</p><p>使用 Grafana 开发运营监控视图，使团队成员可以快速掌握运营状况，及时做出调整</p><p>项目经历<br>Roga Developer</p><p>展示地址：<a href="https://xxx.live(暂不公开哈)/">https://xxx.live（暂不公开哈）</a></p><p>独立开发的基于 MERN 技术栈的 新媒体信息流整合 平台，采用 前后端分离架构</p><p>使用 React 构建前端，对手机端 交互模式 进行了 专门优化 ，使用 Cloudflare 作为 CDN</p><p>使用 React Native 开发了 跨平台 的移动端应用，提高了开发效率，减少了 50% 的开发时间</p><p>为适应产品特性，加快迭代速度，后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB ，实现了前后一体的 集中式配置中心 ，提高了接近 1 倍 的开发效率</p><p>使用 JWT 用户鉴权实现了 平台内容分级机制 ，用户可自定义界面，用户设置 云端同步</p><p>采用 Redis 实现了 高频信息缓存 ，加快了 请求响应速度 ，降低了 90% 以上的数据库压力</p><p>使用 Elasticsearch 实现 全站内容搜索 ，相比 MongoDB 搜索效率提升 80% 以上</p><p>利用 RabbitMQ 的队列机制进行 削峰 ，缓解了 高并发 情况下的 系统资源短缺 问题</p><p>为加强爬虫系统灵活性，将其由 Scrapy 重写为 Node.js ，实现了分批分时、错峰爬取</p><p>为提升开发效率，使用 Gitlab CI&#x2F;CD 进行 持续集成 和 持续部署 ，实现了 构建部署自动化</p><p>采用 Nginx 和 Traefik 进行 前端部署 和 反向代理 ，增强了软件系统的 安全性</p><p>为配合 集群化部署 ，前后端均以 Docker 作为容器，可在任一陌生机器 迅速启动应用</p><p>曾使用 VPS 测试搭建了拥有 10 个节点的 K8s 集群，可进行应用的 快速扩容 和 集中式管理</p><p>RubbishQ Developer</p><p>垃圾分类查询工具，负责 技术选型 、架构设计 和 前后端开发 工作</p><p>为适应产品特性，使用 MongoDB 作为数据库，实现了垃圾分类、讨论区等功能</p><p>为减轻数据库压力，使用 Redis 对搜索结果进行 缓存 ，同时 极大缩短了应用响应时间</p><p><img src="/chaserblog/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427191801377.png" alt="image-20240427191801377"></p><p>简历技巧<br>我不知道大家看完学弟的简历后有什么感受，反正给我最明显的感觉就是两点：</p><p>他会的技术很多</p><p>自主性很强，并且善于用技术解决问题</p><p>而且呢，看完他的简历后，他的 Roga 新媒体信息流整合 项目给我留下了深刻的印象，为啥呢？</p><p>首先显而易见，这个项目经历占据了他简历的大部分内容（50 % 左右）。虽然很长，但是有关这个项目的介绍却字字珠玑，句句精华！</p><p>比如这句：为适应产品特性，加快迭代速度，后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB ，实现了前后一体的 集中式配置中心 ，提高了接近 1 倍 的开发效率。</p><p>和大多数同学介绍项目时直接简单写一句 “用什么技术实现了什么功能” 不同，这句话点明了四个关键：</p><p>为什么要做？（为适应产品特性，加快迭代速度）</p><p>怎么做？用什么技术？（后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB）</p><p>实现了什么？（前后一体的 集中式配置中心）</p><p>达到了怎样的效果？（提高了接近 1 倍 的开发效率）</p><p>有前因、有技术、有后果，给人的感觉就是这位同学做事有目的、有自主性、又善于分析和总结，这些正是很多面试官都看中的特质。再加上介绍中使用大量的 加粗 强调了重点，使用具体数据（如 50%）量化了效果，再次给人加深了印象。我觉得这种写法非常值得大家学习！</p><p>很多同学担心自己简历上没东西写，那不妨认认真真做一个项目，然后按照他的项目经历写法，展示到简历上。</p><p>结合这位学弟和我的简历，鱼皮给大家总结了 撰写简历的一些技巧 ：</p><p>内容完整全面，简历通常包括几个部分：个人简介（基本信息、照片、学校、专业、成绩、证书等）、个人描述（专业特长）、个人技能（技术栈）、项目经历、科研学术经历、实习经历等。</p><p>简历必须一页，排版整洁，且色调不宜过暗或过亮，推荐蓝色或淡灰色。</p><p>依据个人优势对板块排序，把最有亮点的部门放上面。</p><p>文字内容精炼，拒绝口语化，用词尽量专业，体现专业性。</p><p>项目 &#x2F; 实习经历介绍中，可用 STAR 分析（场景、任务、行动、成果）来梳理自己的核心工作。比如，在 xx 公司 xx 项目中，在 xx 情况下，运用 xx 技术，解决了 xx，优化了 xx，带来 xx 收益。每段介绍不宜过长，给面试官提问的空间。</p><p>最好给项目附上可直接访问的链接，有个人博客的话也最好列举上去，并且在博客中记录和总结一些自己学到的知识技能，让面试官感受到你的努力积累、脚踏实地。</p><p>利用简历去引导面试官。很多面试官都会针对简历中提到的技术去展开提问，因此必须熟悉简历中的项目和技术，提前想好对策（比如项目中用了哪些技术，为什么用，有什么亮点，怎么去优化等）。</p><p>写完简历后，自己通读几遍，有机会可以多阅读借鉴他人的简历。</p><p>针对不同的岗位和 JD（岗位描述），准备不同的简历，在部分细节和工作内容上调整。比如投递产品和运营岗，你的项目和实习介绍就要分别侧重这两种不同的职位。</p><p>内容允许夸大，尤其是对于没有特别多的项目的同学，在简历的项目部分是需要适度包装的。但是杜绝欺骗，尤其是工作年限等有准确数字、可被调查的问题，请实事求是，否则后果自负。</p><p> 作者：程序员鱼皮 <a href="https://www.bilibili.com/read/cv11757591/">https://www.bilibili.com/read/cv11757591/</a> 出处：bilibili</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/chaserblog/2024/04/29/markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>一、标题</p><h1 id><a href="#" class="headerlink" title></a></h1><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h1 id="1-一级标题"><a href="#1-一级标题" class="headerlink" title="1 一级标题"></a>1 一级标题</h1><h2 id="2-二级标题"><a href="#2-二级标题" class="headerlink" title="2 二级标题"></a>2 二级标题</h2><p>二、段落</p><p>斜体、<em>1</em></p><p>粗体、<strong>粗体</strong></p><p>粗斜体、<em><strong>1</strong></em></p><p>分隔线、</p><hr><hr><p>删除线、<del>baidu</del></p><p>下划线、<u>xia</u></p><p>脚注1[^2]</p><p>三、列表</p><p>无序列表</p><ul><li>第一项</li><li>第二项</li></ul><p>有序列表</p><ol><li>第一项</li><li>第二项</li></ol><p>列表嵌套</p><ol><li>第一<ul><li>嵌套1</li><li>嵌套2</li></ul></li><li>第二</li></ol><p>四、区块（&gt;)</p><blockquote><p>区块引用</p></blockquote><blockquote><p>菜鸟笔记</p><hr></blockquote><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>区块中使用列表</p><blockquote><p>区块</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><p>列表中使用区块</p><ol><li><p>第一项</p><blockquote><p>区块</p><ol><li>第一项</li></ol></blockquote></li><li><p>第二项</p></li></ol><ul><li><p>第一项</p><blockquote><p>区块</p></blockquote></li><li><p>第二项</p></li></ul><p>五、代码</p><p>段落上的一个函数或片段的代码可以用反引号把它包起来（**&#96;**）</p><p><code>printf()</code></p><p>代码区块</p><ol><li>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>(我没有用起)</li><li>用 <strong>&#96;&#96;&#96;</strong> 包裹一段代码，并指定一种语言（也可以不指定）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>六、链接</p><p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><p>七、图片</p><p><img src="https://static.jyshare.com/images/runoob-logo.png" alt="alt 属性文本"></p><p>八、表格</p><table><thead><tr><th>左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td>单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td>单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><table><thead><tr><th align="center">dfasd</th><th align="center">dfadsfsd</th><th align="center">fdafdf</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>九、支持html元素</p><p>1</p><p>大幅</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/2024.4.27/"/>
    <url>/chaserblog/2024/04/29/2024.4.27/</url>
    
    <content type="html"><![CDATA[<p><strong>一、Textile</strong> <strong>格式</strong><br>Textile是一种简单的文本标记，简单的符号标记要强调的单词。文本块可轻易标记为头部、引用或列表。Textile文档能转换成HTML文档用于Web浏览。</p><p>今天总体的完成学习情况</p><ul><li><input disabled type="checkbox"> 学习了阿里云盘上鱼皮的分享视频  2小时</li><li><input disabled type="checkbox"> 学习了utools这个功能强大的插件库，有很多功能强大的插件</li><li><input disabled type="checkbox"> 在有道云笔记上记了一下学习笔记</li><li><input disabled type="checkbox"> 准备根据视频搭建自己的博客，不知能否成功。</li><li><input disabled type="checkbox"> 玩了一下语雀，团队项目的协作平台</li></ul><p><img src="/chaserblog/chaserblog/2024/04/29/2024.4.27/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427170153026.png" alt="image-20240427170153026"></p><p>在学习文件夹下的程序员鱼皮中有我今天所收集的信息</p><p>还有就是知识星球和[编程导航](<a href="https://www.code-nav.cn/user/1698590357501091841">用户信息 - 编程导航 (code-nav.cn)</a>)、面试鸭这个项目的面试经验的学习一部分</p><h1 id="1-鱼皮学习体会和感受"><a href="#1-鱼皮学习体会和感受" class="headerlink" title="1 鱼皮学习体会和感受"></a>1 鱼皮学习体会和感受</h1><p>从实习至今，我已经在腾讯工作两年了。今天分享下我自从入职腾讯就一直在坚持的习惯，说出来可能会有点土哈哈，这个习惯就是 <strong>写日报</strong> 。</p><p>没错，每天下班前，我都会用 <code>Typora</code> 软件在自己电脑上记录一下当天完成的工作，并且计划好第二天要做的事，其实有点像写日记。</p><p><img src="/chaserblog/chaserblog/2024/04/29/2024.4.27/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/640.png" alt="图片"></p><ul><li><p><input disabled type="checkbox"> <strong>程序员鱼皮开发的软件变成导航：地址<a href="https://www.code-nav.cn/">主页 - 编程导航 (code-nav.cn)</a></strong></p><p>重要网站</p></li></ul><p><img src="/chaserblog/chaserblog/2024/04/29/2024.4.27/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427103716775.png" alt="image-20240427103716775"></p><p>练习了使用html内嵌样式，更改文字颜色。</p><p><span style="color:文字颜色;background:red;font-size:文字大小;font-family:字体;">你要改色的文字</span></p><p>别人所做的计划安排：</p><p>日报中都写了什么呢？给大家看我实习期间写的一篇：</p><p><img src="/chaserblog/chaserblog/2024/04/29/2024.4.27/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/1.png" alt="图片"></p><p>先说说 <strong>今日计划</strong> 部分，除了列举要做的事，我还会给每项工作一个预期完成时间，有点类似之前提到的目标拆解，可以帮助自己更好地把握整体工作进度。</p><p>再说说 <strong>实际工作</strong> 部分，记录了自己完成计划所做的事项以及耗费的时间，可以帮助自己事后复盘。比如这一天我计划 1 个小时完成本地项目搭建，但实际消耗了 2.5 个小时，我就会在另一个文档记录工作中遇到的问题，并且思考：如果再让我做这件事，用什么方法能按预期时间完成呢？</p><p>通过坚持记录，我很轻松地做出了转正答辩 PPT，并且顺利通过。而如果没有写日报的这个习惯，可能我要再想破脑袋去梳理自己的工作内容了，要额外花费很多时间精力。</p><p>所以在转正后，我会在日报上记录更多的内容，比如在工作中的思考、收获感悟、导师的教诲等。</p><p>比如之前有段时间，我投入了大量精力去调研某个系统的各种技术实现方案，结果到最后也没给出一个确定的结论。后面冷静分析了下，确实从高层的视角来看，这段时间我啥代码都没写、零产出。所以有了如下思考：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYKs01zOKIicx0Llibe9BfhdV5MQHEAict8FlI4Oia8ySDwwX0JcGUricAduVohPquMtv7dqqK0QqDibKZrQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>把这点记录下来，在之后的工作中，我会更注重 <strong>结果导向</strong> ，调整自己在不重要事情上投入的时间，不要为了学技术而学技术。</p><p>不得不说，写日报真的给我带来了很大的价值。因此，即使后来换部门后老板要求写周报就行了，但我始终保持写日报的习惯，每周再对日报汇总，提炼出有价值的工作，周报自然就轻松完成。</p><p>很多同学抱怨自己工作效率低，日复一日，很是迷茫。那不妨试试写日报，当你持续总结和计划后，会发现每一天都有盼头，每一天都无比充实。</p><p>万事开头难，刚开始写日报时，我会花不少时间，有时候也会偷懒随便写写。但当养成习惯后，每天只需要花 2 - 3 分钟就能完成。</p><p>不要觉得写日报浪费时间！一般公司内每次评估绩效和晋级前，都需要汇报自己的工作内容。这种时候，我只需掏出日报，两年内的工作尽收眼底、历历在目，有了平日点滴的积累，何愁没有东西写呢？</p><p>最后，其实我真正的坚持的是 <strong>计划</strong> 和 <strong>总结</strong> ，写日报只是一种方式罢了。除了总结工作内容，我还会总结用过的技术和平台、读过的文章、写过的 Bug 等。比如我在公司两年总结的所有内部平台和技术，做了分类：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYKs01zOKIicx0Llibe9BfhdV5QtBLxro0iaXN1HWBSpwBpgT7SCJXnwc3lAJQPXt9dxJyAHEwxFFiblRQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="自我感想"><a href="#自我感想" class="headerlink" title="自我感想"></a>自我感想</h1><p>​        从今天起，自己一定要改掉以前的手写笔记的习惯，要紧跟时代的步伐，用高科技的手段技术来革新自己，武装自己，提高自己的学习效率。不断地学习新工具。</p><p>​       不断地吸收新思想，新观点，新方法。</p><p>interest</p><p>我觉得大学前三年的学习完全没有找到重心，有点遗憾，但从今天做起，加油！</p><p>可以日报周报结合，周报也分计划和实际。 有时候我们不太容易确定“明天做什么”，频繁修改计划又会让你的计划变得没有意义。这个时候周报的“计划”就会让你知道你这个星期的侧重点是什么，不至于只看重“明天”而忽视了“未来”，更好地去规划“明天”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/2022-05-15%20%E9%9D%A2%E8%AF%95%E9%B8%AD%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/29/2022-05-15%20%E9%9D%A2%E8%AF%95%E9%B8%AD%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="面试鸭分享"><a href="#面试鸭分享" class="headerlink" title="面试鸭分享"></a>面试鸭分享</h1><p>做着玩和真正上线有很大的区别</p><p><a href="https://github.com/liyupi/mianshiya-public">https://github.com/liyupi/mianshiya-public</a></p><h3 id="创作原因"><a href="#创作原因" class="headerlink" title="创作原因"></a>创作原因</h3><ol><li>挖掘需求：自己遇到的问题，看别人的项目并且找出别人项目的缺点</li></ol><p>验证需求是否有价值：能解决别人的问题，<strong>能否解决通用的问题</strong>（对内 - 对自己、对外 - 对其他用户）</p><h4 id="这个项目能给我们带来什么？"><a href="#这个项目能给我们带来什么？" class="headerlink" title="这个项目能给我们带来什么？"></a>这个项目能给我们带来什么？</h4><ol><li>对别人的价值</li><li>兴趣</li><li>引流</li><li>做项目出视频、分享</li><li><strong>巩固所学知识</strong>、学习知识</li></ol><p><strong>程序员面试刷题讨论平台</strong></p><p>竞品：</p><ul><li>A 知乎：问答 | <strong>不垂直</strong></li><li>B LeetCode：算法刷题 | 主打的不是面试题，大家很少在上面讨论某一道题目</li><li>C 牛客网：讨论面经 + 刷题 |  主打的不是面试题，大家很少在上面讨论某一道题目，不能集中搜索面试题</li><li>D 其他现成的面试题库 | 不能讨论、个人维护（更新慢）</li></ul><p>A + B + C 进行融合，取长补短、精简化</p><p><strong>为什么轮子多？</strong></p><ol><li>每个产品都有优点、优缺点，面向的需求不一样</li><li>卷：API Fox、API Post、Eolink，竞争</li><li>大佬的任性</li></ol><h3 id="需求篇"><a href="#需求篇" class="headerlink" title="需求篇"></a>需求篇</h3><p>千万不要一上来就大而全，要先把核心功能 <strong>快速上线和验证</strong>，得到用户反馈</p><p>再进行下一步操作。</p><p><strong>不要闷头开发。</strong></p><p><strong>敏捷开发，小步快跑，慢慢加功能。</strong></p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>搜索面试题</p><p>分类查看面试题</p><p>在线查看题解、讨论题目</p><p>自由上传题目</p><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p>试卷功能</p><p>语音读题</p><p>视频题解</p><p>讨论区</p><p>调研、按优先级排期</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p><strong>人力成本</strong></p><p><strong>稳定</strong></p><ul><li><p>项目的量级（用户数、频率、做到什么地步？）</p></li><li><p>成本</p><ul><li>价格</li><li><strong>人力成本</strong> ：围绕着人来，团队对技术的熟悉程度；团队内要有一个问题解决者、领导者</li></ul></li><li><p><strong>生态</strong></p><p>怎么判断：去网上搜 github 的 star 数<strong>（开源）</strong>、业内的认可、文章</p><ul><li>Spring</li><li>Vue、React</li></ul></li><li><p>看作者（看公司）</p><ul><li>稳定性</li></ul></li><li><p><strong>目的</strong>：学习</p></li></ul><p>为什么选某些技术？</p><p>后端为啥不用 Java？</p><ul><li>效率第一：选用云开发，对 node.js</li><li>redis： 限流</li><li>Elasticsearch 搜索引擎技术：提高搜索的灵活性<strong>（贵）</strong></li><li>对象存储：存文件（用户图片、静态文件）</li></ul><p>为什么后来对技术架构做了升级？！将云开发重构为 Express？</p><ul><li>开发框架：Express（Express Session）</li></ul><p>云开发 Serverless 架构：每个函数都是一个系统，独立开发、独立更新、独立维护。多个函数共同组成完整系统。</p><blockquote><p>粒度比为服务更新。清晰、互不影响，云开发对云函数的支持很好。</p></blockquote><p>随着系统量级增大：</p><ol><li>云函数数量太多</li><li>云函数之间要共享变量比较麻烦</li><li>不方便增加统一的逻辑（比如增加请求拦截）</li></ol><p><strong>为什么重构为 Node 而不是 Java？</strong></p><p>方便迁移，降低成本</p><p>CDN 加速：<strong>如果是自己的项目，尽量不要用付费的</strong></p><p><strong>没有必要过度去技术选型</strong></p><p>用 Java 的 SpringBoot 做了一些微信公众号登录服务。</p><p>主要原因：有现成的 WxJava 库。</p><blockquote><p>对技术不了解的话，看下星球的用户中心项目。</p></blockquote><h3 id="设计篇"><a href="#设计篇" class="headerlink" title="设计篇"></a>设计篇</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>我使用云开发可视化界面操作，没有写 SQL 语句。</p><p>类型在 TypeScript 中也有定义，所以不会丢失。</p><blockquote><p>liyupi&#x2F;mianshiya-public&#x2F;src&#x2F;models&#x2F;类型定义</p></blockquote><h4 id="ES-索引-设计"><a href="#ES-索引-设计" class="headerlink" title="ES 索引 设计"></a>ES 索引 设计</h4><blockquote><p>搜索性能更好、更灵活的数据库</p></blockquote><p>es 安装 ik 中文分词器（免费）</p><p>有自己的词库。</p><p>索引 &#x3D;&gt; 理解为 MySQL 的表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;aliases&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;question&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-string">&quot;search_analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;keyword&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>            <span class="hljs-string">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-string">&quot;search_analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;keyword&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>            <span class="hljs-string">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-string">&quot;reviewStatus&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;link&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;tags&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;links&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;userId&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;params&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;type&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;difficulty&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;meetNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;favourNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;shareNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;commentNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;thumbNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;viewNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;reviewMessage&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;priority&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;reviewerId&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;reviewTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;publishTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;_createTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;_updateTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;isDelete&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ES-和-MySQL-怎么同步（保证一致性）？"><a href="#ES-和-MySQL-怎么同步（保证一致性）？" class="headerlink" title="ES 和 MySQL 怎么同步（保证一致性）？"></a>ES 和 MySQL 怎么同步（保证一致性）？</h4><p>强一致性：</p><ol><li>事务双写：插入数据时两个库里都必须插入成功，才算成功，有任何一个失败就回滚（写入性能低）</li></ol><p>稍强一致性：</p><ol><li>监听 binlog：mySQL 在插入数据成功后，会写入 binlog 日志，我们只开一个程序（线程）需要监听 binlog 的变化，如果发现有插入，就也插入到 es（canal 技术）</li></ol><p>弱一致性：</p><ol><li>定时同步：每分钟读取 MySQL 中近 5 分钟内新增的数据，然后写入 ES（根据 id 判断已写入）</li></ol><p>定时检测和补偿程序：每天 &#x2F; 每小时去对比两个库，如果发现不一致，自动以数据库为主，或者发送告警，人工处理。</p><h3 id="团队开发篇"><a href="#团队开发篇" class="headerlink" title="团队开发篇"></a>团队开发篇</h3><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol><li>群众的力量（钞能力）</li></ol><p>公开招人帮忙上传题目、审核题目。</p><p><strong>定制规范很重要！</strong> 统一标准</p><ol start="2"><li>CV 的力量</li></ol><h3 id="团队怎么开发和管理"><a href="#团队怎么开发和管理" class="headerlink" title="团队怎么开发和管理"></a>团队怎么开发和管理</h3><ol><li><p>要有一个协作文档 &#x2F; 平台</p><p>分场景：小团队建议直接用腾讯文档。平台有使用成本、没有使用习惯、没那么方便。</p></li><li><p>日常沟通：了解成员工作情况、代码编写信息</p></li><li><p>团队代码怎么管理：</p><ol><li><p>GitHub 组织功能，私有仓库</p></li><li><p>不能所有同学都把直接提交到一起，要划分分支来区分每个人的代码</p><p>分支：</p><ol><li>每个人一个分支</li><li>每个需求一个分支（大项目）</li></ol></li><li><p>提交前 MR <strong>代码审查</strong></p></li></ol></li></ol><h3 id="技术源码篇"><a href="#技术源码篇" class="headerlink" title="技术源码篇"></a>技术源码篇</h3><p>前端</p><p>后端</p><p>其他服务</p><h3 id="上线篇"><a href="#上线篇" class="headerlink" title="上线篇"></a>上线篇</h3><ol><li><p>选择 Docker 方式部署，原因：</p><ol><li>腾讯云云开发支持快速 Docker 部署，很方便。</li><li>分布式部署，Docker 弹性伸缩很方便，不用自己输命令。</li></ol></li><li><p>测试</p><ol><li>拉了个 500 人内测群</li><li>产品反馈平台 —— 腾讯图小巢：</li></ol></li><li><p>开源前：写好 README.md 项目介绍文档，参考知名项目的文档仿写，可以复制别人的 README 改写</p><blockquote><p>小图标网站：<a href="https://shields.io/">https://shields.io/</a></p></blockquote></li></ol><h3 id="运营篇"><a href="#运营篇" class="headerlink" title="运营篇"></a>运营篇</h3><ol><li><p>关于网站维护，最麻烦的是内容，建议：</p><ol><li>大家找帮手 &#x2F; 合作来维护</li><li>完善系统，开发一些功能来降低维护成本</li></ol></li><li><p>持续看用户反馈</p></li><li><p>给网站添加统计分析功能（比如百度统计），每天查看一下用户访问数、<strong>用户来源</strong></p></li><li><p>关于网络安全</p><ol><li>少用收费的东西（比如 CDN），或者用免费的 CDN，降低不稳定因素</li><li>如果有条件，不要暴露你项目的真实 ip</li><li>DDOS 防不住！！！<strong>轻量级应用防护 31 一块钱一年防 10 G</strong></li></ol></li></ol><h3 id="推广篇"><a href="#推广篇" class="headerlink" title="推广篇"></a>推广篇</h3><p>不细讲。</p><ol><li>自己有流量，自己写文章视频</li><li>如果你完全没有流量，怎么推广？<ol><li>花钱</li><li>找类似的项目，去适当的、找机会去分享自己的项目（介绍你的项目）</li><li>友链</li><li>SEO：搜索引擎优化，别人能搜到你的网站</li></ol></li></ol><p>加入星球的同学，如果你有 <strong>足够好的</strong> 项目和点子，可以来找我</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/2022-04-02%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8&amp;%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%92%8C%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"/>
    <url>/chaserblog/2024/04/29/2022-04-02%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8&amp;%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%92%8C%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建代码托管-前端监控平台"><a href="#搭建代码托管-前端监控平台" class="headerlink" title="搭建代码托管 &amp; 前端监控平台"></a>搭建代码托管 &amp; 前端监控平台</h1><h2 id="0-从-0-开服务器"><a href="#0-从-0-开服务器" class="headerlink" title="0. 从 0 开服务器"></a>0. 从 0 开服务器</h2><p>服务器类别：</p><ol><li>轻量应用服务器：<strong>快速</strong> 搭建应用、简单易用，提供了很多现成的镜像。省去了一些复杂的功能</li><li>云服务器：功能齐全、基础的服务器</li></ol><p>BAT 美团、华为、京东，1 年换一家去买，利用新用户优惠</p><p>宝塔 Linux（ Linux 运维面板 1 C 2 G 能带动）：</p><ol><li>企业：安全性，不建议用</li><li>个人：快速搭建应用（强烈推荐）</li></ol><p>怎么算带宽：</p><p>4 MB &#x3D;&gt; 1 MB</p><p>1MB * 1000，1.25MBps</p><h2 id="SSH-连接服务器"><a href="#SSH-连接服务器" class="headerlink" title="SSH 连接服务器"></a>SSH 连接服务器</h2><p>XShell</p><p>Putty（轻量，相对专业）</p><p>MobaXterm</p><p>FinalShell</p><h2 id="操作服务器"><a href="#操作服务器" class="headerlink" title="操作服务器"></a>操作服务器</h2><p>下载文件</p><h2 id="1-代码托管平台"><a href="#1-代码托管平台" class="headerlink" title="1. 代码托管平台"></a>1. 代码托管平台</h2><p>企业中，往往不会把项目放到公开的平台，一般自己搭建。</p><p>GitLab（占用资源比较多，功能丰富）、Gitea、Gogs</p><p>估计要装 10 分钟左右</p><p>平台对比：</p><ul><li><a href="https://about.gitlab.com/devops-tools/github-vs-gitlab/">https://about.gitlab.com/devops-tools/github-vs-gitlab/</a></li><li><a href="https://about.gitlab.com/devops-tools/gitea-vs-gitlab/">https://about.gitlab.com/devops-tools/gitea-vs-gitlab/</a></li><li><a href="https://about.gitlab.com/devops-tools/gogs-vs-gitlab/">https://about.gitlab.com/devops-tools/gogs-vs-gitlab/</a></li></ul><p>系统要求：CPU &gt;&#x3D; 2C，内存 &gt;&#x3D; 4 G</p><h2 id="2-前端监控系统（目前搭建未成功，大家学理论就好）"><a href="#2-前端监控系统（目前搭建未成功，大家学理论就好）" class="headerlink" title="2. 前端监控系统（目前搭建未成功，大家学理论就好）"></a>2. 前端监控系统（目前搭建未成功，大家学理论就好）</h2><p>监控的作用：</p><ol><li>监测系统的正常运行</li><li>还原案发现场，<strong>帮助定位和排查问题</strong></li><li>即时感知到系统的问题（告警），防止用户流失</li></ol><p>监控分类：</p><ol><li>系统性能监控（CPU、内存、带宽）偏底层，关注整体资源情况</li><li>网站运行情况（页面是否正常？当前访问人数？加载时长？当前消耗带宽等）应用层，关注网站运行情况</li><li>网站 <strong>数据</strong> 收集 &#x2F; 监控（网站 PV、UV、用户分布、年龄分布等），关注网站的用户情况，数据分析</li><li>行为监控（点了哪些按钮，操作路径），关注网站用户具体的行为，数据分析</li><li>错误监控（页面哪些内容报错了）帮助定位和排查问题，防止用户流失</li></ol><p>2、3、4 百度统计 &#x2F; Aegis</p><p>5 错误监控：Sentry（开源），badjs</p><p>Sentry 官网：<a href="https://sentry.io/welcome/">https://sentry.io/welcome/</a></p><p>Sandbox 可体验</p><p>自行搭建 Sentry：<a href="https://github.com/getsentry/self-hosted">https://github.com/getsentry/self-hosted</a></p><p>安装教程：<a href="https://blog.csdn.net/weixin_40230682/article/details/120737684">https://blog.csdn.net/weixin_40230682/article/details/120737684</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>容器技术，我们可以把应用（比如 jar 包）和应用依赖的环境（比如 java）都打包（封装）成镜像，想要使用 &#x2F; 部署应用时只需要下载镜像。而不需要自己重新准备环境。</p><p>镜像是死的，可分发（安装包）</p><p>容器应用是活的，根据安装包来启动容器</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>我们要启动多个 <strong>Docker</strong>，比如 MySQL + Java SpringBoot + Redis，自己一个个启动很麻烦</p><p>使用 Docker Compose 可以同时启动，节省时间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2024.4.29</title>
    <link href="/chaserblog/2024/04/29/2024-4-29/"/>
    <url>/chaserblog/2024/04/29/2024-4-29/</url>
    
    <content type="html"><![CDATA[<ol><li>从今天开始，每一天总结自己所学习的心得体会、及时的复盘与汇总，</li><li>每一周星期都要有一个周总结，因为自己看到了太多与别人的差距，特别是在青春榜样上看到了计算机学院宋杨同学的努力，报名了多个计算机算法赛事。</li></ol><p>定期（不定、可能会1个月等等）的维护自己的博客。</p><h1 id="百度搜索技巧"><a href="#百度搜索技巧" class="headerlink" title="百度搜索技巧"></a>百度搜索技巧</h1><p>百度搜索的结果真的太多了，有时候我们可能翻好几页也不一定能找到满意的结果，平白增加不少的工作量。想从这么多信息中筛选出有用的信息，还是需要一定技巧的。</p><h2 id="关键词site：网站"><a href="#关键词site：网站" class="headerlink" title="关键词site：网站"></a>关键词site：网站</h2><p>搜索特定网站中的内容。</p><p>site: apple.com.cn</p><h2 id="关键词filetype：文件格式"><a href="#关键词filetype：文件格式" class="headerlink" title="关键词filetype：文件格式"></a>关键词filetype：文件格式</h2><p>如：教程filetype：pdf</p><p>百度网盘filetype：pdf</p><h2 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h2><p>关键词1*关键词2</p><p>如：快乐*球</p><p>今日学习任务：</p><ul><li><p><input disabled type="checkbox"> 信息检索工具vosviwer工具的使用，学习Vosviewer如何进行文献的可视化+直观感受知识图谱</p><p>web of science：<em>Web of science</em>是大型综合性、多学科、核心期刊引文索引数据库，包括三大引文数据库（科学引文索引（Science citation index，简称SCI）</p><p>（<a href="https://mp.weixin.qq.com/s?__biz=MzAwMTEzOTgzMA==&mid=2650673246&idx=1&sn=f7bef8e63ca18039f847f83a984e766b&chksm=82d48547b5a30c512eeeeee88797a47e570d5a9772ea2a3c4f6d65c0fa04c083157f3d75cbe6&scene=27%EF%BC%89">https://mp.weixin.qq.com/s?__biz=MzAwMTEzOTgzMA==&amp;mid=2650673246&amp;idx=1&amp;sn=f7bef8e63ca18039f847f83a984e766b&amp;chksm=82d48547b5a30c512eeeeee88797a47e570d5a9772ea2a3c4f6d65c0fa04c083157f3d75cbe6&amp;scene=27）</a></p><p>network visualizaion：网络视图</p><p><img src="/chaserblog/chaserblog/2024/04/29/2024-4-29/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240429093215639.png" alt="image-20240429093215639"></p><p>聚类分析：圈大的代表出现的频次越高，且通过颜色可以区分出属于哪一个类别的。</p><p>overlay visulization：标签视图</p><p>通过颜色可以区分出哪些具有前沿性，</p><p>标签的时序性。</p><p><img src="/chaserblog/chaserblog/2024/04/29/2024-4-29/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240429093455716.png" alt="image-20240429093455716"></p><p>越蓝的时间越靠后，越黄的时间越靠前。</p></li><li><p><input disabled type="checkbox"> utools新一代效率工具</p></li></ul><p>移动开发网络通信：</p><p>windows中web服务器的启用</p><p>iis打开Internet information service</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/28/2024.4.28/"/>
    <url>/chaserblog/2024/04/28/2024.4.28/</url>
    
    <content type="html"><![CDATA[<p>(<a href="https://blog.fiveth.cc/p/bb32.html">如何用Hexo搭建个人博客? | Fiveth</a>)</p><p>优点<br>1、不需要服务器，github免费提供的托管服务<br>2、不需要域名，github同样提供了一个.io的域名<br>3、不用自己写xml、<a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a>提供了很多开源的博客模板。<br>4、便于维护更新，换风格直接换模板就行。</p><p>问题：</p><p>使用github作为服务器时，repo包中我用https:*******这个输入账号和密码一直显示连接错误</p><p>我改为用ssh连接时就好了。</p><p>配置SSH Key<br>注册完之后需要添加 SSH Key。 SSH Key是一个认证，让github识别绑定这台机器，允许这台机器无需密码提交，修改项目。执行如下命令：</p><p>生产新的SSH Key配置<br>在Git Bash(在任意文件夹中鼠标右击选择Git Bash Here打开)执行代码：</p><p><code>ssh-keygen -t rsa -C &quot;xxxxxxxxx@qq.com&quot;</code><br>上面的邮箱记得修改成你自己的，成功后会生成两个文件id_rsa（私钥） 以及id_rsa.pub（公钥）。 然后找到这两个文件，默认都在C盘 &gt; 用户 &gt; xxx &gt; .ssh 里面（xxx是计算机名字，我这里是Administrator）</p><p><img src="https://img-blog.csdnimg.cn/648d8c72050c46a9bf7f2dd252b57de6.png" alt="img"></p><p>然后用文本编辑器把id_rsa_pub（公钥）这个文件打开，全选复制出来； 然后打开在github上添加SSH Key，登录github账号，点击右上角用户头像，选择setting（设置）&gt; SSH and GPG keys &gt; NewSSH key</p><p><img src="https://img-blog.csdnimg.cn/1afa3b66e2114b5ba795545fa1bad8b0.png" alt="img"></p><p>然后把刚才复制的内容粘贴到key这里就可以了.</p><p>3.1. 测试是否成功<br><code>$ ssh -T git@github.com</code> # 注意邮箱地址不用改<br>复制</p><p>如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p><code>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</code></p><p>看到这个信息说明SSH已配置成功！<br>————————————————</p><p><img src="/chaserblog/chaserblog/2024/04/28/2024.4.28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428085806628.png" alt="image-20240428085806628"></p><p><img src="/chaserblog/chaserblog/2024/04/28/2024.4.28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428090043539.png" alt="image-20240428090043539"></p><p><img src="/chaserblog/chaserblog/2024/04/28/2024.4.28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428132801443.png" alt="image-20240428132801443"></p><p><img src="/chaserblog/chaserblog/2024/04/28/2024.4.28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428132842085.png" alt="image-20240428132842085"></p><p>搭建个人博客</p><h1 id="项目展示】"><a href="#项目展示】" class="headerlink" title="项目展示】"></a>项目展示】</h1><blockquote><p>【展示地址】：<a href="https://zhangruyi3906.github.io/chaserblog/">chaserblog | 我的博客 (zhangruyi3906.github.io)</a>【注册、下载与安装】</p></blockquote><h2 id="【1】gitee注册"><a href="#【1】gitee注册" class="headerlink" title="【1】gitee注册"></a>【1】gitee注册</h2><blockquote><p>【gitee官方注册地址】：<a href="https://gitee.com/signup">https://gitee.com/signup</a></p></blockquote><h2 id="【2】Typora下载"><a href="#【2】Typora下载" class="headerlink" title="【2】Typora下载"></a>【2】Typora下载</h2><blockquote><p>【下载地址】：<a href="https://www.typora.io/">https://www.typora.io/</a></p></blockquote><h2 id="【3】node安装"><a href="#【3】node安装" class="headerlink" title="【3】node安装"></a>【3】node安装</h2><blockquote><p>【下载地址】：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>【安装过程】：选择磁盘可以切换到其他盘，然后一直下一步就好了。（这里演示是切换D盘）</p></blockquote><h2 id="【4】git安装"><a href="#【4】git安装" class="headerlink" title="【4】git安装"></a>【4】git安装</h2><blockquote><p>【下载地址】：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>【安装过程】：选择磁盘可以切换到其他盘，然后一直下一步就好了。（这里演示是切换D盘）</p></blockquote><h1 id="【本地博客搭建】"><a href="#【本地博客搭建】" class="headerlink" title="【本地博客搭建】"></a>【本地博客搭建】</h1><h2 id="【1】hexo-cli安装"><a href="#【1】hexo-cli安装" class="headerlink" title="【1】hexo-cli安装"></a>【1】hexo-cli安装</h2><blockquote><p>npm install hexo-cli -g</p><p>或</p><p>先安装cnpm，然后利用cnpm安装hexo-cli</p><p>npm install cnpm</p><p>cnpm install hexo-cli -g</p></blockquote><h2 id="【2】初始化hexo项目"><a href="#【2】初始化hexo项目" class="headerlink" title="【2】初始化hexo项目"></a>【2】初始化hexo项目</h2><blockquote><p>hexo init blog</p></blockquote><h2 id="【3】项目启动"><a href="#【3】项目启动" class="headerlink" title="【3】项目启动"></a>【3】项目启动</h2><blockquote><p>永远的hexo三件套：</p><p>-清除生成的页面相关内容</p><p>hexo clean</p><p>-构建生成的页面相关内容</p><p>hexo g</p><p>-项目启动</p><p>hexo s</p></blockquote><p>会看到这样的页面，证明本地hexo默认模板配置成功，<br><img src="https://img-blog.csdnimg.cn/img_convert/b26252eb40bc11f27ab2808484f82dd0.png" alt="wapchief"><br>到这一步如果将hexo放到github page，那么使用github.io访问的将是一个默认的页面。下面我们要把他diy成自己的博客，包括导入模板主题等。</p><p>安装主题<br>关于主题大多都是以压缩包形式，可以去github上搜hexo theme，会出来很多，里面都有介绍。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d99c1f1811f3af2535ab2d92d869563b.png" alt="hexo-theme主题">比如我们比如我们要用第一个。<br>可以通过两种方法，这里我直接使用git命令完成，具体请参考next官方文档：<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a><br>继续在我们的本地hexo目录输入</p><p>git clone <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> themes&#x2F;next</p><h1 id="【添加主题模板Fluid】"><a href="#【添加主题模板Fluid】" class="headerlink" title="【添加主题模板Fluid】"></a>【添加主题模板Fluid】</h1><h2 id="【1】在blog-themes目录下"><a href="#【1】在blog-themes目录下" class="headerlink" title="【1】在blog\themes目录下"></a>【1】在blog\themes目录下</h2><blockquote><p>去gitee上下载Fluid主题模板（github上真的太慢了有时候还下不下来。）</p><p>git clone <a href="https://gitee.com/mirrors/hexo-theme-fluid.git">https://gitee.com/mirrors/hexo-theme-fluid.git</a></p></blockquote><h2 id="【2】修改-conf-yml"><a href="#【2】修改-conf-yml" class="headerlink" title="【2】修改_conf.yml"></a>【2】修改_conf.yml</h2><blockquote><p>找到theme，替换为对应下载主题名字（在themes下载下来的文件夹名）</p><p>theme: hexo-theme-fluid</p><p>此时我出现了以下问题：</p><p><img src="/chaserblog/chaserblog/2024/04/28/2024.4.28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428144618381.png" alt="image-20240428144618381"></p></blockquote><p>不能够通过老老实实的安装上述提及的相关缺失的包来解决问题，</p><p>而是可以通过在命令行中输入npm install 这个命令来解决问题</p><p>这个方法简便且快速和高效。</p><h2 id="【3】修改为主题语言为中文"><a href="#【3】修改为主题语言为中文" class="headerlink" title="【3】修改为主题语言为中文"></a>【3】修改为主题语言为中文</h2><blockquote><p>在blog目录下的_conf.yml，找到文件内容里的language替换为以下</p><p>language: zh-CN #指定语言，会影响主题显示的语言，按需修改</p></blockquote><h2 id="【4】生成about页面"><a href="#【4】生成about页面" class="headerlink" title="【4】生成about页面"></a>【4】生成about页面</h2><blockquote><p>在blog路径下，执行指令（管理员cmd操作）</p><p>hexo new page about</p><p>创建成功后，去到blog\source\about\index.md，添加layout属性，以为为index.md里所有内容</p><p>-–<br>title: about<br>date: 2021-10-01 14:53:12<br>layout: about<br>-–</p></blockquote><p>修改内容<br>内容较多建议参考官方文档<br><a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a><br>修改完之后，可以重新执行hexo s在浏览器查看效果。并确认无误，包括以后需要添加文章，或者更新主题等，都建议先在本地查看无误再远程部署。<br>根_config.yml文件中</p><h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p><code>title: 网站标题</code><br><code>subtitle: 副标题</code><br><code>description: 个人签名</code><br><code>author: 姓名</code><br><code>language: zh-Hans</code><br><code>timezone:</code></p><h1 id="【图片、内容等修改】"><a href="#【图片、内容等修改】" class="headerlink" title="【图片、内容等修改】"></a>【图片、内容等修改】</h1><h2 id="【1】添加友链导航"><a href="#【1】添加友链导航" class="headerlink" title="【1】添加友链导航"></a>【1】添加友链导航</h2><blockquote><p>【参考地址】：<a href="https://hexo.fluid-dev.com/docs/guide/#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5">https://hexo.fluid-dev.com/docs/guide/#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5</a></p><p>在blog\themes\hexo-theme-fluid目录下的_config.yml内容中去掉 navbar导航栏 menu下的link 前的注释</p><p>menu:<br>- { key: “home”, link: “&#x2F;“, icon: “iconfont icon-home-fill” }<br>- { key: “archive”, link: “&#x2F;archives&#x2F;“, icon: “iconfont icon-archive-fill” }<br>- { key: “category”, link: “&#x2F;categories&#x2F;“, icon: “iconfont icon-category-fill” }<br>- { key: “tag”, link: “&#x2F;tags&#x2F;“, icon: “iconfont icon-tags-fill” }<br>- { key: “about”, link: “&#x2F;about&#x2F;“, icon: “iconfont icon-user-fill” }<br>- { key: “links”, link: “&#x2F;links&#x2F;“, icon: “iconfont icon-link-fill” }</p></blockquote><h2 id="【2】改页面标题和页面前的小icons"><a href="#【2】改页面标题和页面前的小icons" class="headerlink" title="【2】改页面标题和页面前的小icons"></a>【2】改页面标题和页面前的小icons</h2><blockquote><p>blog目录下的_config.yml的内容中</p><p>原来是有title: Hexo</p><p>改为title: 阿怼博客</p></blockquote><blockquote><p>blog\themes\hexo-theme-fluid\主题目录下的_config.yml的内容中</p><p>navbar:</p><p> blog_title: “Fluid”</p><p>改为</p><p>navbar:</p><p> blog_title: “阿怼博客”</p><p>同样文件，找到首页（index）</p><p>index:<br># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同<br># Path of Banner image, can be a relative path or an absolute path, the same on other pages<br>banner_img: &#x2F;img&#x2F;default.png</p><p># 头图高度，屏幕百分比<br># Height ratio of banner image<br># Available: 0 - 100<br>banner_img_height: 100</p><p># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明<br># Opacity of the banner mask, 1.0 is completely opaque<br># Available: 0 - 1.0<br>banner_mask_alpha: 0.3</p><p># 首页副标题的独立设置<br># Independent config of home page subtitle<br>slogan:<br>enable: true</p><p># 为空则按 hexo config.subtitle 显示<br># If empty, text based on <code>subtitle</code> in hexo config<br>text: “An elegant Material-Design theme for Hexo”</p><p>这里的text改成你想改的</p><p>text: “我叫阿怼，南方阿怼，一个热爱计算机更热爱祖国的南方人。”</p></blockquote><blockquote><p>修改icons或者其他图片，找到blog\themes\hexo-theme-fluid\source\img目录下（注意不是blog\public\img目录下的，public的目录文件不需要改，因为每次hexo clean都会删除了，然后hexo g再重新创建）</p><p>在这里面替换成你想要的图片、icon就好了。</p></blockquote><h1 id="【-md文件博客上传】"><a href="#【-md文件博客上传】" class="headerlink" title="【.md文件博客上传】"></a>【.md文件博客上传】</h1><blockquote><p>首先，写好一个.md，作为你的博客了。</p><p>也可以直接在blog目录下，执行以下指令生成.md，再进行对该.md进行完善内容。</p><p>hexo new “《我的第一个日记》”</p><p>这时候就生成在blog\source_posts目录下了</p><p>你已经写好了.md，也可以直接移动到这里，然后再重新启动hexo三件套就好了。（hexo clean、hexo g、hexo s）</p></blockquote><blockquote><p>标签添加</p><p>在你想添加标签的.md文件中，添加tags: “标签名”</p><p>-–<br>title: 《个人博客搭建》<br>date: 2021-10-01 15:35:44<br>tags: “《博客搭建相关》”<br>-–</p></blockquote><h1 id="【宠物插件】"><a href="#【宠物插件】" class="headerlink" title="【宠物插件】"></a>【宠物插件】</h1><blockquote><p>npm install –save hexo-helper-live2d<br>或<br>cnpm install –save hexo-helper-live2d</p><p>1、cnpm install –save hexo-helper-live2d<br>2、<a href="https://www.npmjs.com/package/hexo-helper-live2d">live2d插件</a><br>3、安装合适的宠物cnpm install live2d-widget-model-chitose<br>4、在博客_config.yml配置文件中（不是themes里的）添加即可</p></blockquote><p>使用命令下载插件：npm install –save hexo-helper-live2d</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-2.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-2.png" alt="img"></a></p><p>使用命令下载模型：npm install live2d-widget-model-hijiki</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-3.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-3.png" alt="img"></a></p><p>在blog目录下，配置_config.yml，找到deploy，添加以下代码</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-4.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-4.png" alt="img"></a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2dtag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">log:</span> <span class="hljs-literal">false</span> <br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-hijiki</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否在移动设备上显示</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span><br></code></pre></td></tr></table></figure><h1 id="9-鼠标特效"><a href="#9-鼠标特效" class="headerlink" title="9. 鼠标特效"></a>9. 鼠标特效</h1><p>在主题目录下，找到source&#x2F;js文件，打开后创建，一个js文件，名字可以自定义</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-5.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-5.png" alt="img"></a></p><p>然后添加一下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*网页鼠标点击特效（爱心）*/</span><br>!<span class="hljs-keyword">function</span> (<span class="hljs-params">e, t, a</span>) &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">r</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>; e &lt; s.<span class="hljs-property">length</span>; e++) s[e].<span class="hljs-property">alpha</span> &lt;= <span class="hljs-number">0</span> ? (t.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(s[e].<span class="hljs-property">el</span>), s.<span class="hljs-title function_">splice</span>(e, <span class="hljs-number">1</span>)) : (s[e].<span class="hljs-property">y</span>--, s[e].<span class="hljs-property">scale</span> += <span class="hljs-number">.004</span>, s[e].<span class="hljs-property">alpha</span> -= <span class="hljs-number">.013</span>, s[e].<span class="hljs-property">el</span>.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&quot;left:&quot;</span> + s[e].<span class="hljs-property">x</span> + <span class="hljs-string">&quot;px;top:&quot;</span> + s[e].<span class="hljs-property">y</span> + <span class="hljs-string">&quot;px;opacity:&quot;</span> + s[e].<span class="hljs-property">alpha</span> + <span class="hljs-string">&quot;;transform:scale(&quot;</span> + s[e].<span class="hljs-property">scale</span> + <span class="hljs-string">&quot;,&quot;</span> + s[e].<span class="hljs-property">scale</span> + <span class="hljs-string">&quot;) rotate(45deg);background:&quot;</span> + s[e].<span class="hljs-property">color</span> + <span class="hljs-string">&quot;;z-index:99999&quot;</span>);<span class="hljs-title function_">requestAnimationFrame</span>(r)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">n</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">var</span> t = <span class="hljs-string">&quot;function&quot;</span> == <span class="hljs-keyword">typeof</span> e.<span class="hljs-property">onclick</span> &amp;&amp; e.<span class="hljs-property">onclick</span>;e.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;t &amp;&amp; <span class="hljs-title function_">t</span>(), <span class="hljs-title function_">o</span>(e)&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">o</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-keyword">var</span> a = t.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);a.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;heart&quot;</span>, s.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">el</span>: a,<span class="hljs-attr">x</span>: e.<span class="hljs-property">clientX</span> - <span class="hljs-number">5</span>,<span class="hljs-attr">y</span>: e.<span class="hljs-property">clientY</span> - <span class="hljs-number">5</span>,<span class="hljs-attr">scale</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">color</span>: <span class="hljs-title function_">c</span>()&#125;), t.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(a)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">i</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-keyword">var</span> a = t.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;style&quot;</span>);a.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;text/css&quot;</span>;<span class="hljs-keyword">try</span> &#123;a.<span class="hljs-title function_">appendChild</span>(t.<span class="hljs-title function_">createTextNode</span>(e))&#125; <span class="hljs-keyword">catch</span> (t) &#123;a.<span class="hljs-property">styleSheet</span>.<span class="hljs-property">cssText</span> = e&#125;t.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(a)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;rgb(&quot;</span> + ~~(<span class="hljs-number">255</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">&quot;,&quot;</span> + ~~(<span class="hljs-number">255</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">&quot;,&quot;</span> + ~~(<span class="hljs-number">255</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">&quot;)&quot;</span>&#125;<span class="hljs-keyword">var</span> s = [];e.<span class="hljs-property">requestAnimationFrame</span> = e.<span class="hljs-property">requestAnimationFrame</span> || e.<span class="hljs-property">webkitRequestAnimationFrame</span> || e.<span class="hljs-property">mozRequestAnimationFrame</span> || e.<span class="hljs-property">oRequestAnimationFrame</span> || e.<span class="hljs-property">msRequestAnimationFrame</span> || <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<span class="hljs-built_in">setTimeout</span>(e, <span class="hljs-number">1e3</span> / <span class="hljs-number">60</span>)&#125;, <span class="hljs-title function_">i</span>(<span class="hljs-string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>), <span class="hljs-title function_">n</span>(), <span class="hljs-title function_">r</span>()&#125;(<span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">document</span>);<br></code></pre></td></tr></table></figure><p>在footer标签内添加以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/click_lihua.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="【提交搭建的博客到Gitee上，正式完成博客搭建】"><a href="#【提交搭建的博客到Gitee上，正式完成博客搭建】" class="headerlink" title="【提交搭建的博客到Gitee上，正式完成博客搭建】"></a>【提交搭建的博客到Gitee上，正式完成博客搭建】</h1><blockquote><p>修改blog_config.yml配置文件的站点地址（找到deploy）：</p><p>deploy:<br>type: git<br>repo:<br>branch: master<br>live2d: <a href="https://gitee.com/southern-adui/southern-adui.git">https://gitee.com/southern-adui/southern-adui.git</a><br>enable: true</p><p>安装git上传助手（如果有git设置过有帐号密码，就去先对git进行操作）</p><p>npm install hexo-deployer-git –save<br>或<br>cnpm install hexo-deployer-git –save</p><p>完成后，输入</p><p>hexo d</p></blockquote><blockquote><p>git的操作<br>查看配置信息： $ git config –list<br>修改用户名<br>git config –global user.name “xxxx(新的用户名)”<br>修改密码<br>git config –global user.password “xxxx(新的密码)”<br>修改邮箱<br>git config –global user.email “<a href="mailto:xxxx@xxx.com">xxxx@xxx.com</a>(新的邮箱)”<br>清除掉缓存在git中的用户名和密码<br>git credential-manager uninstall</p></blockquote><p>最后注意一下，按照以上核心步骤弄出自己的博客后如果没有加载出来css等，可以稍等片刻再试一下。</p><p>可能会收到网络因素的影响。（至少要2分钟左右）</p><p>问题：</p><p>鼠标点击礼花形状的效果（这个问题我找了很久。。。。）</p><p>最后还是在看了同组中的样例后才发现的，网上没有现成的教程。</p><p>总结：遇到问题还是不能太死板、死磕，要想方设法的去解决问题。</p><p><img src="/chaserblog/chaserblog/2024/04/28/2024.4.28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428155704328.png" alt="image-20240428155704328"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p><strong>登录 &#x2F; 注册</strong> 20min</p><ol><li>前端</li><li>后端</li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol><li>前端</li><li>后端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-11%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-11%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>本次直播内容：</p><ol><li>上次直播问题总结✔</li><li>用户库表设计✔</li><li>完成登录注册的前后端开发</li><li>完成用户管理后台的前后端开发</li><li>其他（根据时间弹性安排）</li></ol><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min</p><ol><li>后端       20min <ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min</li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol><li>前端</li><li>后端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><hr><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>本次直播内容：</p><ol><li>上次直播问题总结✔</li><li>用户库表设计✔</li><li>完成登录注册的前后端开发</li><li>完成用户管理后台的前后端开发</li><li>其他（根据时间弹性安排）</li></ol><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-25%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E7%BB%88%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-25%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E7%BB%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>终 - 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%AB%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-04-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>末 - 直播内容</p><ol><li>开发用户注销前端 7 分钟 &#x2F; 后端 3 分钟 √</li><li>补充用户注册校验逻辑前端 10 分钟 &#x2F; 后端 10 分钟 √</li><li>后端代码优化 20 - 30 min</li><li>前端代码优化 5 - 10 min</li><li>项目部署上线 1h<ol><li>买服务器   10 min</li><li>原生部署20 - 30 min</li><li>容器部署    20 - 30 min</li><li>绑定域名    5 min</li><li><strong>排查问题</strong></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-03%20%E5%B0%9D%E9%B2%9CAI%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6Copilot%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/2022-04-03%20%E5%B0%9D%E9%B2%9CAI%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6Copilot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="体验-AI-自动写代码插件-Copilot"><a href="#体验-AI-自动写代码插件-Copilot" class="headerlink" title="体验 AI 自动写代码插件 Copilot"></a>体验 AI 自动写代码插件 Copilot</h1><p>基于 GitHub 上开源的亿级别的代码，训练 AI 模型，自动生成代码。</p><p>数据量能够决定你 AI 模型精度的上限</p><p>而算法是帮助你不断逼近这个上限</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>自动补全</li><li>根据注释自动生成代码</li><li>自动推断、生成类似的代码</li><li>自动生成测试</li><li>自动生成代码建议，提供选择</li></ol><p>根据注释生成注释？</p><p>插件支持 VS Code、JetBrains 全家桶、Visual Studio</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>申请（<a href="https://copilot.github.com/%EF%BC%89">https://copilot.github.com/）</a></p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><ol><li>逻辑类代码（比如校验，80 分）</li><li>重复代码量越少，推荐越不准</li><li>固定格式的、通用的代码（java 40 分）大家写来写去都是一样的 &#x2F; 类似的代码</li><li>业务逻辑（用处不大)</li></ol><p>提示代码的准确度和模型本身、模型分析依赖的环境 &#x2F; 上下文有关。</p><p>以前：写代码，查百度，开发者</p><p>现在：写注释，翻生成的代码是否靠谱，监管者</p><p><strong>AI 辅助程序员</strong></p><p>自己能掌控代码再用</p><p>适合一些工具类（日期转换、对象转化，校验），提高效率 &#x3D;&gt; 不要拿来生成一些本来就看不懂的代码</p><p>不要在企业和敏感项目中使用，可能有安全隐患！</p><p>欢迎加入鱼皮的编程知识星球：dogyupi.com</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-17%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E9%83%A8%E7%BD%B2%EF%BC%89%20/"/>
    <url>/chaserblog/2024/04/28/2022-04-17%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E9%83%A8%E7%BD%B2%EF%BC%89%20/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>GitLab 地址：<a href="http://gitlab.code-nav.cn/">http://gitlab.code-nav.cn/</a></p><p>部署 - 直播内容</p><ol><li>多环境 5 - 10min</li><li>项目部署上线 1h √<ul><li>原始前端 &#x2F; 后端项目</li><li>宝塔 Linux </li><li>容器</li><li>容器平台</li></ul></li><li>前后端的联调 —— 跨域 15 min</li><li>用户中心项目扩展和规划（优化点）5 - 10 min</li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端部署方式"><a href="#前端部署方式" class="headerlink" title="前端部署方式"></a>前端部署方式</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 后端</span><br><span class="hljs-attribute">docker</span> build -t user-center-backend:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br><br><span class="hljs-comment"># 前端</span><br><span class="hljs-attribute">docker</span> build -t user-center-front:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>前端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; </p><p>服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如果解决跨域</p><ol><li>把域名、端口改成相同的</li></ol><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><ol start="2"><li><p>网关支持（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改后端服务</p><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%E7%BA%BF%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-04-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%E7%BA%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>GitLab 地址：<a href="http://gitlab.code-nav.cn/">http://gitlab.code-nav.cn/</a></p><p>部署 - 直播内容</p><ol><li>多环境 5 - 10min</li><li>项目部署上线 1h √<ul><li>原始前端 &#x2F; 后端项目</li><li>宝塔 Linux </li><li>容器</li><li>容器平台</li></ul></li><li>前后端的联调 —— 跨域 15 min</li><li>用户中心项目扩展和规划（优化点）5 - 10 min</li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端部署方式"><a href="#前端部署方式" class="headerlink" title="前端部署方式"></a>前端部署方式</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 后端</span><br><span class="hljs-attribute">docker</span> build -t user-center-backend:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br><br><span class="hljs-comment"># 前端</span><br><span class="hljs-attribute">docker</span> build -t user-center-front:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>前端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; </p><p>服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如果解决跨域</p><ol><li>把域名、端口改成相同的</li></ol><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><ol start="2"><li><p>网关支持（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改后端服务</p><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World练习</title>
    <link href="/chaserblog/2024/04/28/hello-world/"/>
    <url>/chaserblog/2024/04/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>练习测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/yuwork-%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/yuwork-%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="开发记录和分析工作的工具"><a href="#开发记录和分析工作的工具" class="headerlink" title="开发记录和分析工作的工具"></a>开发记录和分析工作的工具</h1><blockquote><p>by 程序员鱼皮 <a href="https://yupi.icu/">知识星球</a></p><p>直播回放会发布到编程学习圈子：<a href="https://yupi.icu/">https://yupi.icu</a></p><p>直播回放 + 项目源码 + 笔记：<a href="https://t.zsxq.com/03J6URbem">https://t.zsxq.com/03J6URbem</a> （加入星球可见）</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>个人可以记录自己每日的工作、工作时长、工作打标签（工作进度、目标）</li><li>可以根据日历查看自己的工作（视图）</li><li>可以对一定周期内的工作进行分析（饼图、折线图、柱状图）</li></ol><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><h4 id="第一次开发"><a href="#第一次开发" class="headerlink" title="第一次开发"></a>第一次开发</h4><p>完整基本前后端搭建和联调，实现任务创建和查询功能</p><h4 id="第二次开发"><a href="#第二次开发" class="headerlink" title="第二次开发"></a>第二次开发</h4><ol><li>优化样式</li><li>分页检索</li></ol><h3 id="第三次开发"><a href="#第三次开发" class="headerlink" title="第三次开发"></a>第三次开发</h3><ol><li>增删改 <strong>查</strong>（搜索 &#x2F; 排序）</li></ol><h3 id="下次开发"><a href="#下次开发" class="headerlink" title="下次开发"></a>下次开发</h3><ol><li>登录</li><li>管理员分析，分析所有用户（指定范围用户）的工作情况</li><li>任务拖动</li><li>多种视图布局</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ol><li>前端：Vue 3 + Vite 2 + Ant Design Vue（桌面端为主）<ul><li>数据可视化：AntV G2</li><li>日期处理库：Day.js</li></ul></li><li>后端：SpringBoot + Redis 分布式登录</li></ol><h2 id="前端整合"><a href="#前端整合" class="headerlink" title="前端整合"></a>前端整合</h2><ol><li>Vite 初始化</li><li>Vue Router 整合，添加路由功能</li><li>Ant Design Vue 整合</li><li>整合 AntV G2，支持实例图表</li></ol><h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><ol><li>新增记录：表单页</li><li>展示记录：列表页</li><li>分析</li></ol><h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><ol><li>拉取通用模板，已经整合好了常用框架、用户登录用例等</li><li>设计库表</li></ol><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="工作表"><a href="#工作表" class="headerlink" title="工作表"></a>工作表</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">name:</span> <span class="hljs-type">string</span>;<br><span class="hljs-symbol">description:</span> <span class="hljs-type">string</span>;<br><span class="hljs-symbol">duration:</span> number;<br><span class="hljs-symbol">tags:</span> <span class="hljs-type">string</span>[];<br>planTime?: <span class="hljs-type">Date</span>;<br><span class="hljs-symbol">createTime:</span> <span class="hljs-type">Date</span>;<br><span class="hljs-symbol">updateTime:</span> <span class="hljs-type">Date</span>;<br></code></pre></td></tr></table></figure><p>id bigint</p><p>任务名称 varchar</p><p>描述 varchar</p><p>时长 duration int</p><p>tags  varchar</p><p>planTime 计划时间 datetime</p><p>创建时间  datetime</p><p>更新时间  datetime</p><p>逻辑删除 tinyint 0 &#x2F; 1</p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 任务<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> work<br>(<br>    id          <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name        <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;任务名称&#x27;</span>,<br>    description text               <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    duration    <span class="hljs-type">int</span>                <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;时长（秒）&#x27;</span>,<br>    tags        <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;标签列表json&#x27;</span>,<br>    planTime    datetime comment <span class="hljs-string">&#x27;计划时间&#x27;</span>,<br>    createTime  datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime  datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete    tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>) comment <span class="hljs-string">&#x27;任务&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><ol><li>校验参数</li><li>插入数据到数据库中</li></ol><p>查询任务列表</p><p>直接用接口文档在线测试</p><h3 id="查询列表（分页）"><a href="#查询列表（分页）" class="headerlink" title="查询列表（分页）"></a>查询列表（分页）</h3><p>MyBatis Plus 的 Page 方法</p><h2 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h2><h3 id="分页实现"><a href="#分页实现" class="headerlink" title="分页实现"></a>分页实现</h3><ol><li>前端分页（一次请求全量数据，前端去计算每一页展示什么）</li><li>后端分页（一次请求一页的数据，前端页面时重新发请求去加载）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E6%8A%93%E9%B1%BC-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%AF%84%E8%AE%BA%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E6%8A%93%E9%B1%BC-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%AF%84%E8%AE%BA%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="写一个小项目-——-抓鱼"><a href="#写一个小项目-——-抓鱼" class="headerlink" title="写一个小项目 —— 抓鱼"></a>写一个小项目 —— 抓鱼</h1><p><strong>直播回放在知识星球：dogyupi.com，欢迎加入</strong></p><ol><li>获取某个视频的评论 ✔</li><li><strong>实时</strong> 感知到评论的变化（定时去抓屏）-<ol><li><strong>设计算法（顺序、去重、不丢失）</strong>：</li><li>去重：<strong>rpid</strong></li><li>顺序：从接口拿来的数据本来就是按最新shi</li><li>不丢失：提高抓取的频率（不太建议）</li><li><strong>不能太频繁</strong>：定时 10 秒更新</li></ol></li><li>能够把评论输出到其他平台（网页）✔</li></ol><p>技术选型：</p><p>后端：Node.js + Express  + axios 请求库 + socket.io 实时通讯，nodemon 热更新</p><p>前端：JavaScript + moment.js</p><p>socket + websocket</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心直播笔记（完整版）"><a href="#用户中心直播笔记（完整版）" class="headerlink" title="用户中心直播笔记（完整版）"></a>用户中心直播笔记（完整版）</h1><p>目标：完整了解做项目的思路，接触一些企业级的开发技术，让大家之后都能轻松做出管理系统！</p><h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><p>用户中心前端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-frontend">http://gitlab.code-nav.cn/root/user-center-frontend</a></p><p>用户中心后端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-backend">http://gitlab.code-nav.cn/root/user-center-backend</a></p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt; 初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试、系统测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署 &#x3D;&gt; 发布上线</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>登录 &#x2F; 注册</li><li>用户管理（仅管理员可见）对用户的查询或者修改</li><li>用户校验（仅星球用户可见）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="3-种初始化-Java-项目的方式"><a href="#3-种初始化-Java-项目的方式" class="headerlink" title="3 种初始化 Java 项目的方式"></a>3 种初始化 Java 项目的方式</h2><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库？程序代替人工</p><h3 id="什么是设计数据库表？"><a href="#什么是设计数据库表？" class="headerlink" title="什么是设计数据库表？"></a>什么是设计数据库表？</h3><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？</p><p>举例：性别是否需要加索引？</p><h3 id="用户表设计"><a href="#用户表设计" class="headerlink" title="用户表设计"></a>用户表设计</h3><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p>MyBatisX 插件，自动根据数据库生成：</p><ul><li>domain：实体对象</li><li>mapper：操作数据库的对象</li><li>mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL</li><li>service：包含常用的增删改查</li><li>serviceImpl：具体实现 service</li></ul><p>从而提高开发效率！</p><h2 id="注册逻辑设计"><a href="#注册逻辑设计" class="headerlink" title="注册逻辑设计"></a>注册逻辑设计</h2><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度不小于 4 位</li><li>密码就不小于 8 位</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>控制层 Controller 封装请求</p><p>application.yml 指定接口全局路径前缀：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><p>控制器注解：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>校验写在哪里？</p><ul><li>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</li><li>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</li></ul><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><blockquote><p>javaweb 这一块的知识</p></blockquote><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>接口设计关键：必须鉴权！！！</p><ol><li>查询用户（允许根据用户名查询）</li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><ol><li>先做设计</li><li>代码实现</li><li>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</li></ol><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求才能获取数据 &#x2F; 执行操作。</p><p>怎么发请求：前端使用 ajax 来请求后端</p><h3 id="前端请求库及封装关系"><a href="#前端请求库及封装关系" class="headerlink" title="前端请求库及封装关系"></a>前端请求库及封装关系</h3><ul><li><p>axios 封装了 ajax</p></li><li><p>request 是 ant design 项目又封装了一次</p></li></ul><p>追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么实现代理？</p><ul><li>Nginx 服务器</li><li>Node.js 服务器</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="前端框架介绍"><a href="#前端框架介绍" class="headerlink" title="前端框架介绍"></a>前端框架介绍</h2><h3 id="Ant-Design-Pro（Umi-框架）权限管理"><a href="#Ant-Design-Pro（Umi-框架）权限管理" class="headerlink" title="Ant Design Pro（Umi 框架）权限管理"></a>Ant Design Pro（Umi 框架）权限管理</h3><ul><li>app.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</li><li>access.ts 控制用户的访问权限</li></ul><p>获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="框架关系"><a href="#框架关系" class="headerlink" title="框架关系"></a>框架关系</h3><p>Ant Design 组件库 &#x3D;&gt; 基于 React 实现</p><p>Ant Design Procomponents &#x3D;&gt; 基于 Ant Design 实现</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现</p><h3 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h3><p>MFSU：前端编译优化</p><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><h3 id="通用返回对象"><a href="#通用返回对象" class="headerlink" title="通用返回对象"></a>通用返回对象</h3><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>自定义错误码，返回类支持返回正常和错误</p><h3 id="封装全局异常处理器"><a href="#封装全局异常处理器" class="headerlink" title="封装全局异常处理器"></a>封装全局异常处理器</h3><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）</p></li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><blockquote><p>直播的 0：00 - 0：35 为踩坑过程，可跳过</p></blockquote><h3 id="全局响应处理"><a href="#全局响应处理" class="headerlink" title="全局响应处理"></a>全局响应处理</h3><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p><p>优势：不用在每个接口请求中都去写相同的逻辑</p><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用</a> <strong>axios</strong>，参考 axios 的文档。</p><p>创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，全凭自觉。</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端。</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端托管"><a href="#前端托管" class="headerlink" title="前端托管"></a>前端托管</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后端</span><br>docker build -t user-center-backend:v0.0.1 .<br><br><span class="hljs-comment"># 前端</span><br>docker build -t user-center-front:v0.0.1 .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理的作用：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如何解决跨域？</p><p>最直接的方式：把域名、端口改成相同的</p><h3 id="添加跨域头"><a href="#添加跨域头" class="headerlink" title="添加跨域头"></a>添加跨域头</h3><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><h4 id="1-网关支持（Nginx）"><a href="#1-网关支持（Nginx）" class="headerlink" title="1. 网关支持（Nginx）"></a>1. 网关支持（Nginx）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改后端服务"><a href="#2-修改后端服务" class="headerlink" title="2. 修改后端服务"></a>2. 修改后端服务</h4><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE%20-%20%E8%87%AA%E5%AA%92%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <url>/chaserblog/2024/04/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE%20-%20%E8%87%AA%E5%AA%92%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员鱼皮-自媒体经验分享"><a href="#程序员鱼皮-自媒体经验分享" class="headerlink" title="程序员鱼皮 - 自媒体经验分享"></a>程序员鱼皮 - 自媒体经验分享</h1><h2 id="环节一"><a href="#环节一" class="headerlink" title="环节一"></a>环节一</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><p>知识区 &#x2F; 科技区 &#x3D;&gt; 计算机 &#x2F; 编程知识 UP，分享在职程序员 &amp; 自媒体创作（两大脱发职业）的经历和干货</p><h3 id="2-拍摄介绍"><a href="#2-拍摄介绍" class="headerlink" title="2. 拍摄介绍"></a>2. 拍摄介绍</h3><p>设备</p><ul><li>摄像头：罗技 Stream Cam</li><li>拍摄：<ul><li>日常：手机足够</li><li>vlog：大疆 pocket 2</li><li>高清视频：相机索尼 a7c</li></ul></li><li>麦克风<ul><li>直播：罗技 Blue Yeti</li><li>录制：Rode Wireless Go II</li></ul></li><li>幕布</li><li>打光<ul><li>桌面打光灯</li><li>落地打光灯</li></ul></li><li>前期可以用提词器</li></ul><p>硬件</p><ul><li>Mac or Windows 电脑均可</li></ul><p>软件</p><ul><li>必剪（做封面）</li><li>剪映</li><li>PR（之前用的多，后来很少用了）</li><li>爱提词</li></ul><h3 id="3-做-UP-有意思的事-——-带节奏、一起快乐"><a href="#3-做-UP-有意思的事-——-带节奏、一起快乐" class="headerlink" title="3. 做 UP 有意思的事 —— 带节奏、一起快乐"></a>3. 做 UP 有意思的事 —— 带节奏、一起快乐</h3><ol><li>直播写代码翻车（让大家集中注意力、无痛学编程）</li><li>网站被攻击（激励大家学习编程、同时感受到网络攻击的危害）</li><li>评论区人才辈出</li></ol><h2 id="环节二"><a href="#环节二" class="headerlink" title="环节二"></a>环节二</h2><h3 id="1-个人创作经历-——-五个阶段"><a href="#1-个人创作经历-——-五个阶段" class="headerlink" title="1. 个人创作经历 —— 五个阶段"></a>1. 个人创作经历 —— 五个阶段</h3><h4 id="1-1-短视频-起因：激励自己准备面试"><a href="#1-1-短视频-起因：激励自己准备面试" class="headerlink" title="1.1 短视频 - 起因：激励自己准备面试"></a>1.1 短视频 - 起因：激励自己准备面试</h4><p>看一道面试题，录一道，一天 3 - 5 期，录了 100 多个视频只有 100 个粉丝。</p><h4 id="1-2-短视频-起因：想试试"><a href="#1-2-短视频-起因：想试试" class="headerlink" title="1.2 短视频 - 起因：想试试"></a>1.2 短视频 - 起因：想试试</h4><p>别人的经历能有那么多点赞？我的经历也挺励志，也值得给大家分享！</p><p>分享了自己大学四年的经历。</p><p>第一次直播的经历（20 多个人聊了半个多小时）</p><p>理念：通过短视频帮大家快速了解某个技术、让知识变得有趣</p><h4 id="1-3-文字创作-公众号-起因：想有个地方写文章、兴趣"><a href="#1-3-文字创作-公众号-起因：想有个地方写文章、兴趣" class="headerlink" title="1.3 文字创作 - 公众号 - 起因：想有个地方写文章、兴趣"></a>1.3 文字创作 - 公众号 - 起因：想有个地方写文章、兴趣</h4><ul><li>一天一更，坚持了 1 个多月</li><li>观念转变，希望更多人看到，激励自己输出</li><li>知乎，每天回答 3 - 5 个问题</li><li>变现</li></ul><h4 id="1-4-中长视频-起因：合成大西瓜小爆款-B-站粘性高"><a href="#1-4-中长视频-起因：合成大西瓜小爆款-B-站粘性高" class="headerlink" title="1.4 中长视频 - 起因：合成大西瓜小爆款 &#x2F; B 站粘性高"></a>1.4 中长视频 - 起因：合成大西瓜小爆款 &#x2F; B 站粘性高</h4><ul><li>之前考虑没做是因为没做起来，时间也不够</li><li>持续做 B 站，氛围好、想做大、想得到大家的认可，排期 &#x3D;&gt; 不出稿难受</li><li>纠结：迎合流量还是专注技术？ &#x3D;&gt; 像稚晖君那样的结合？</li><li>成为习惯 &#x3D;&gt; 爱好</li></ul><h4 id="1-5-私域流量-知识星球"><a href="#1-5-私域流量-知识星球" class="headerlink" title="1.5 私域流量 - 知识星球"></a>1.5 私域流量 - 知识星球</h4><ul><li>粉丝多了后，很多想分享的知识并不适合去做视频分享，不如定制化地帮大家解决问题</li><li>想挑战不依赖第三方平台，打造自己的 IP</li><li>变现</li></ul><h4 id="做自媒体的契机"><a href="#做自媒体的契机" class="headerlink" title="做自媒体的契机"></a>做自媒体的契机</h4><p>自己的契机：兴趣 + 尝试 + 坚持</p><p>过程：随缘 &#x3D;&gt; 尝试 &#x3D;&gt; 兴趣 &#x3D;&gt; 正反馈驱动 &#x3D;&gt; 迷茫 &#x3D;&gt; 不服 &#x3D;&gt; 习惯 &#x3D;&gt; 爱好 &#x3D;&gt; 随缘</p><p>最适合做自媒体的人（没有压力、能持续发展的）：对自己的工作、技能感兴趣，并愿意将它分享给更多的同学。</p><h4 id="创作压力"><a href="#创作压力" class="headerlink" title="创作压力"></a>创作压力</h4><p>如何坚持高产？</p><ol><li>持续思考，认真观察，即时记录自己的灵感并持续发酵。不会为了想稿子而头疼。</li><li>持续做计划，大目标拆解</li><li>给自己找创作激励和正反馈（不行就多立 Flag）</li></ol><p>平衡工作和自媒体创作？</p><ul><li>最理想的状态是把自己工作中的发现、学到的技术进行分享。</li><li>自媒体创作是兴趣，不玩游戏，时间还是足够的</li><li>90% 的同学没时间的原因都是在玩游戏和回消息（水群），个人习惯：集中一个时间段回复，工作的时候认真回复。</li><li>放弃了午休，放弃了游戏，放弃了一些出去玩  &#x2F; 聊天的机会、熬夜，创造每周第 8 天</li></ul><p>会缺乏动力么？</p><ul><li>会，这时要给自己找点刺激</li><li>心态要随缘，刻意会不持久</li></ul><p>同事知道自己做 UP 是怎样的感受？</p><ul><li>替我担心：你不要再吐槽公司了，很危险啊！</li></ul><h3 id="2-如何做有趣有料的干货内容？"><a href="#2-如何做有趣有料的干货内容？" class="headerlink" title="2. 如何做有趣有料的干货内容？"></a>2. 如何做有趣有料的干货内容？</h3><h4 id="2-1-焦虑"><a href="#2-1-焦虑" class="headerlink" title="2.1 焦虑"></a>2.1 焦虑</h4><p>数据：会焦虑，会和别人对比 <del>，一度怀疑自己被限流，我现在依然怀疑</del></p><p>涨粉：不会焦虑，更多关注内容</p><p>从来没有把自媒体当成任务，但依然会有流量焦虑。主要的焦虑是其他 UP 主带来的，太卷了。</p><h4 id="2-2-内容质量的把控"><a href="#2-2-内容质量的把控" class="headerlink" title="2.2 内容质量的把控"></a>2.2 内容质量的把控</h4><p>希望每期视频都能给大家带来一些知识，而不是纯粹的搞笑或闲聊。哪怕是网站被攻击，也能给大家带来一些收获~</p><ul><li>好玩、有趣</li><li>真实、共鸣</li><li>要留下一些东西（知识点、一个作品）</li><li>精简、突出主旨</li></ul><h4 id="2-3-分享干货的套路"><a href="#2-3-分享干货的套路" class="headerlink" title="2.3 分享干货的套路"></a>2.3 分享干货的套路</h4><ol><li>真实最重要，纵观自己和全网，越真实、越自然，越容易爆火。被喷是很正常的，从你做 UP 主开始，就应该做好心理准备。我不会排斥某些内容，他能上热门一定有它的道理，思考背后的原因。</li><li>摸清观众的心理，比如编程深度知识或完整教程，真正要看这些内容的人会主动搜索、或者不需要你来把文字稿整成视频；应该用轻松的方式，让大家在主线学习之余，零碎时间了解新知识。领悟过程一方面是发现自己随着粉丝的增长、受众越来越小白化，更要注重知识的通俗易懂；另一方面是看数据和大家的评论反馈。向大流量区学习。</li><li>不要去跟某一领域更专业的人竞争，比如培训机构（我不会出自己的完整课程）</li></ol><h4 id="2-4-给新人-UP-主的创作建议"><a href="#2-4-给新人-UP-主的创作建议" class="headerlink" title="2.4 给新人 UP 主的创作建议"></a>2.4 给新人 UP 主的创作建议</h4><ul><li>创作<ul><li>随时记录，随时找灵感，不是硬着头皮写稿子</li><li>调研已有视频，分析做得好与不好的地方</li><li>多关注同类 UP 主，学习经验</li><li>有趣 &gt; 干货（优化稿子：去除废话、加一些梗，剪辑时加一些搞笑的动图、搞笑的音乐</li><li>持续产出，而不是三天打鱼两天晒网，坚持才能成功！</li></ul></li><li>如何增加曝光与点击<ul><li>发布时间选择</li><li>标题</li><li>封面</li><li>标签</li><li>活动</li><li>推广（创作激励）</li><li>社群 &#x2F; 私域流量分享</li><li>前期内容在尽可能多的平台发布</li><li>写简介</li><li>引导三连</li><li>评论区的互动</li></ul></li><li>转化<ul><li>有意引导点赞三连</li><li>引流</li><li>制造期待（下期内容，留下自己的标签）</li></ul></li></ul><h3 id="3-意义和未来打算"><a href="#3-意义和未来打算" class="headerlink" title="3. 意义和未来打算"></a>3. 意义和未来打算</h3><h4 id="3-1-给自己的收获"><a href="#3-1-给自己的收获" class="headerlink" title="3.1 给自己的收获"></a>3.1 给自己的收获</h4><ul><li>快乐</li><li>充实和满足</li><li>收益</li><li>尝试和挑战</li><li>有了一定发声的权利</li><li>项目更容易推广，自己给自己打广告</li><li>认识更多有趣的人</li><li>顺应时代，不掉队</li><li>帅气的光头 🧑‍🦲</li></ul><h4 id="3-2-给大家的帮助和沉淀"><a href="#3-2-给大家的帮助和沉淀" class="headerlink" title="3.2 给大家的帮助和沉淀"></a>3.2 给大家的帮助和沉淀</h4><ul><li>新人入门</li><li>大家的正向反馈（找到工作之类的）</li><li>留下自己的作品</li></ul><h4 id="3-3-未来打算"><a href="#3-3-未来打算" class="headerlink" title="3.3 未来打算"></a>3.3 未来打算</h4><p>走一步算一步吧，继续把自媒体当做爱好，干好本职工作，学习更多技能</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E9%B1%BC%E6%B3%A1%20-%20%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E9%B1%BC%E6%B3%A1%20-%20%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="鱼泡-伙伴匹配系统"><a href="#鱼泡-伙伴匹配系统" class="headerlink" title="鱼泡 - 伙伴匹配系统"></a>鱼泡 - 伙伴匹配系统</h1><p>介绍：帮助大家找到志同道合的伙伴，移动端 H5 网页（尽量兼容 PC 端）</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>用户去添加标签，标签的分类（要有哪些标签、怎么把标签进行分类）学习方向 java &#x2F; c++，工作 &#x2F; 大学</li><li>主动搜索：允许用户根据标签去搜索其他用户<ol><li>Redis 缓存</li></ol></li><li>组队<ol><li>创建队伍</li><li>加入队伍</li><li>根据标签查询队伍</li><li>邀请其他人</li></ol></li><li>允许用户去修改标签</li><li>推荐<ol><li>相似度计算算法 + 本地分布式计算</li></ol></li></ol><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue 3 开发框架（提高页面开发的效率）</li><li>Vant UI（基于 Vue 的移动端组件库）（React 版 Zent）</li><li>Vite 2（打包工具，快！）</li><li>Nginx 来单机部署</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java 编程语言 + SpringBoot 框架</li><li>SpringMVC + MyBatis + MyBatis Plus（提高开发效率）</li><li>MySQL 数据库</li><li>Redis 缓存</li><li>Swagger + Knife4j 接口文档</li></ol><h2 id="第一期计划"><a href="#第一期计划" class="headerlink" title="第一期计划"></a>第一期计划</h2><ol><li>前端项目初始化 15 min √</li><li>前端主页 + 组件概览 15 min √</li><li>数据库表设计 15 min √<ol><li>标签表</li><li>用户表</li></ol></li><li>初始化后端项目</li><li>开发后端 - 根据标签搜索用户 30 min</li><li>开发前端 - 根据标签搜索用户 20 min</li></ol><h2 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><p>用脚手架初始化项目</p><ul><li>Vue CLI <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li><li><strong>Vite 脚手架</strong> ：<a href="https://vitejs.cn/guide/#scaffolding-your-first-vite-project">https://vitejs.cn/guide/#scaffolding-your-first-vite-project</a></li></ul><p>整合组件库 Vant：</p><ul><li>安装 Vant</li><li>按需引入 npm i <a href="mailto:&#x76;&#105;&#116;&#101;&#45;&#112;&#x6c;&#117;&#103;&#x69;&#110;&#45;&#x73;&#116;&#121;&#x6c;&#101;&#45;&#x69;&#x6d;&#112;&#111;&#114;&#116;&#x40;&#x31;&#46;&#x34;&#46;&#49;">&#x76;&#105;&#116;&#101;&#45;&#112;&#x6c;&#117;&#103;&#x69;&#110;&#45;&#x73;&#116;&#121;&#x6c;&#101;&#45;&#x69;&#x6d;&#112;&#111;&#114;&#116;&#x40;&#x31;&#46;&#x34;&#46;&#49;</a> -D</li></ul><p>开发页面经验：</p><ol><li>多参考</li><li>从整体到局部</li><li>先想清楚页面要做成什么样子，再写代码</li></ol><h2 id="前端主页-组件概览-15-min"><a href="#前端主页-组件概览-15-min" class="headerlink" title="前端主页 + 组件概览 15 min"></a>前端主页 + 组件概览 15 min</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>导航条：展示当前页面名称</p><p>主页搜索框 &#x3D;&gt; 搜索页 &#x3D;&gt; 搜索结果页（标签筛选页）</p><p>内容</p><p>tab 栏：</p><ul><li>主页（推荐页 + <strong>广告</strong> ）<ul><li>搜索框</li><li>banner</li><li>推荐信息流</li></ul></li><li>队伍页</li><li>用户页（消息 - 暂时考虑发邮件）</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>很多页面要复用组件 &#x2F; 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）</p><p>组件化</p><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p>标签的分类（要有哪些标签、怎么把标签进行分类）</p><h3 id="新增标签表（分类表）"><a href="#新增标签表（分类表）" class="headerlink" title="新增标签表（分类表）"></a>新增标签表（分类表）</h3><p>建议用标签，不要用分类，更灵活。</p><p>性别：男、女</p><p>方向：Java、C++、Go、前端</p><p>正在学：Spring</p><p>目标：考研、春招、秋招、社招、考公、竞赛（蓝桥杯）、转行、跳槽</p><p>段位：初级、中级、高级、王者</p><p>身份：小学、初中、高中、大一、大二、大三、大四、学生、待业、已就业、研一、研二、研三</p><p>状态：乐观、有点丧、一般、单身、已婚、有对象</p><p><strong>【用户自己定义标签】？</strong></p><p>字段：</p><p>id int 主键</p><p>标签名 varchar 非空（必须唯一，唯一索引）</p><p>上传标签的用户 userId int（如果要根据 userId 查已上传标签的话，最好加上，普通索引）</p><p>父标签 id ，parentId，int（分类）</p><p>是否为父标签 isParent, tinyint（0 不是父标签、1 - 父标签）</p><p>创建时间 createTime，datetime</p><p>更新时间 updateTime，datetime</p><p>是否删除 isDelete， tinyint（0、1）</p><p>怎么查询所有标签，并且把标签分好组？按父标签 id 分组，能实现 √</p><p>根据父标签查询子标签？根据 id 查询，能实现 √</p><p>SQL 语言分类：</p><p>DDL define 建表、操作表</p><p>DML manage 更新删除数据，影响实际表里的内容</p><p>DCL control 控制，权限</p><p>DQL query 查询，select</p><p><a href="https://www.cnblogs.com/fan-yuan/p/7879353.html">https://www.cnblogs.com/fan-yuan/p/7879353.html</a></p><h3 id="修改用户表"><a href="#修改用户表" class="headerlink" title="修改用户表"></a>修改用户表</h3><p>用户有哪些标签？</p><p><strong>根据自己的实际需求来！！！</strong> 此处选择第一种</p><ol><li><p>直接在用户表补充 tags 字段，**[‘Java’, ‘男’] 存 json 字符串 ** </p><p>优点：查询方便、不用新建关联表，标签是用户的固有属性（除了该系统、其他系统可能要用到，标签是用户的固有属性）节省开发成本</p><p><strong>查询用户列表，查关系表拿到这 100 个用户有的所有标签 id，再根据标签 id 去查标签表。</strong></p><p>哪怕性能低，可以用缓存。</p><p>缺点：用户表多一列，会有点</p></li><li><p>加一个关联表，记录用户和标签的关系</p><p>关联表的应用场景：查询灵活，可以正查反查</p><p>缺点：要多建一个表、多维护一个表</p><p>重点：企业大项目开发中尽量减少关联查询，很影响扩展性，而且会影响查询性能</p></li></ol><h3 id="开发后端接口"><a href="#开发后端接口" class="headerlink" title="开发后端接口"></a>开发后端接口</h3><h4 id="搜索标签"><a href="#搜索标签" class="headerlink" title="搜索标签"></a>搜索标签</h4><ol><li>允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%Java%’ and like ‘%C++%’。</li><li>允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’</li></ol><p>两种方式：</p><ol><li>SQL 查询（实现简单，可以通过拆分查询进一步优化）</li><li>内存查询（灵活，可以通过并发进一步优化）</li></ol><ul><li><p>如果参数可以分析，根据用户的参数去选择查询方式，比如标签数</p></li><li><p>如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁。</p></li><li><p>还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag</p></li></ul><p>建议通过实际测试来分析哪种查询比较快，数据量大的时候验证效果更明显！</p><p>解析 JSON 字符串：</p><p>序列化：java对象转成 json</p><p>反序列化：把 json 转为 java 对象</p><p>java  json 序列化库有很多：</p><ol><li><p><strong>gson</strong>（google 的）</p></li><li><p>fastjson alibaba（ali 出品，快，但是漏洞太多）</p></li><li><p>jackson</p></li><li><p>kryo</p></li></ol><h2 id="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"><a href="#用户中心来集中提供用户的检索、操作、注册、登录、鉴权" class="headerlink" title="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"></a>用户中心来集中提供用户的检索、操作、注册、登录、鉴权</h2><h2 id="中-2022-05-29"><a href="#中-2022-05-29" class="headerlink" title="中 2022-05-29"></a>中 2022-05-29</h2><p>本次直播内容（计划）： </p><ol><li><strong>上次的标签接口调试</strong> 5 min √</li><li>前端整合路由 5min √</li><li>前端开发（搜索页面、用户信息页、用户信息修改页）30 - 50min √</li><li>后端整合 Swagger + Knife4j 接口文档 10 - 15min</li><li>存量用户信息导入及同步（爬虫） 40 min</li></ol><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ol><li>stream &#x2F; parallelStream 流失处理</li><li>Optional 可选类</li></ol><h3 id="前端整合路由"><a href="#前端整合路由" class="headerlink" title="前端整合路由"></a>前端整合路由</h3><p>Vue-Router：<a href="https://router.vuejs.org/zh/guide/#html%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%BC%95%E5%85%A5">https://router.vuejs.org/zh/guide/#html，直接看官方文档引入</a></p><p>Vue-Router 其实就是帮助你根据不同的 url 来展示不同的页面（组件），不用自己写 if &#x2F; else</p><p>路由配置影响整个项目，所以建议单独用 config 目录、单独的配置文件去集中定义和管理。</p><p>有些组件库可能自带了和 Vue-Router 的整合，所以尽量先看组件文档、省去自己写的时间。</p><h2 id="下-2022-06-05"><a href="#下-2022-06-05" class="headerlink" title="下 2022-06-05"></a>下 2022-06-05</h2><ol><li>Java 后端整合 Swagger + Knife4j 接口文档 10 min √</li><li>存量用户信息导入及同步（爬虫） 30 min - 40 min</li><li></li><li>前后端联调：搜索页面、用户信息页、用户信息修改页 30 - 40 min</li><li>标签内容整理 15 min</li><li>部分细节优化  todo</li></ol><h2 id="后端整合-Swagger-Knife4j-接口文档"><a href="#后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="后端整合 Swagger + Knife4j 接口文档"></a>后端整合 Swagger + Knife4j 接口文档</h2><p>什么是接口文档？写接口信息的文档，每条接口包括：</p><ul><li>请求参数</li><li>响应参数<ul><li>错误码</li></ul></li><li>接口地址</li><li>接口名称</li><li>请求类型</li><li>请求格式</li><li>备注</li></ul><p>who 谁用？一般是后端或者负责人来提供，后端和前端都要使用</p><p>为什么需要接口文档？</p><ul><li>有个书面内容（背书或者归档），便于大家参考和查阅，便于 <strong>沉淀和维护</strong> ，拒绝口口相传</li><li>接口文档便于前端和后端开发对接，前后端联调的 <strong>介质</strong> 。后端 &#x3D;&gt; 接口文档 &lt;&#x3D; 前端</li><li>好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发测试效率</li></ul><p>怎么做接口文档？</p><ul><li>手写（比如腾讯文档、Markdown 笔记）</li><li>自动化接口文档生成：自动根据项目代码生成完整的文档或在线调试的网页。Swagger，Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国产）</li></ul><p>接口文档有哪些技巧？</p><p>Swagger 原理：</p><ol><li>引入依赖（Swagger 或 Knife4j：<a href="https://doc.xiaominfo.com/knife4j/documentation/get_start.html%EF%BC%89">https://doc.xiaominfo.com/knife4j/documentation/get_start.html）</a></li><li>自定义 Swagger 配置类</li><li>定义需要生成接口文档的代码位置（Controller）</li><li>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</li><li>启动即可</li><li>可以通过在 controller 方法上添加 @Api、@ApiImplicitParam(name &#x3D; “name”,value &#x3D; “姓名”,required &#x3D; true)    @ApiOperation(value &#x3D; “向客人问好”) 等注解来自定义生成的接口描述信息</li></ol><p>如果 springboot version &gt;&#x3D; 2.6，需要添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><p>todo 怎么隐藏</p><h2 id="存量用户信息导入及同步"><a href="#存量用户信息导入及同步" class="headerlink" title="存量用户信息导入及同步"></a>存量用户信息导入及同步</h2><ol><li>把所有星球用户的信息导入</li><li>把写了自我介绍的同学的标签信息导入</li></ol><p>FeHelper 前端辅助插件，推荐安装</p><h3 id="看上了网页信息，怎么抓到？"><a href="#看上了网页信息，怎么抓到？" class="headerlink" title="看上了网页信息，怎么抓到？"></a>看上了网页信息，怎么抓到？</h3><ol><li>分析原网站是怎么获取这些数据的？哪个接口？</li></ol><p>按 F 12 打开控制台，查看网络请求，复制 curl 代码便于查看和执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;https://api.zsxq.com/v2/hashtags/48844541281228/topics?count=20&quot;</span> ^<br>  -H <span class="hljs-string">&quot;authority: api.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept: application/json, text/plain, */*&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept-language: zh-CN,zh;q=0.9&quot;</span> ^<br>  -H <span class="hljs-string">&quot;cache-control: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;origin: https://wx.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;pragma: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;referer: https://wx.zsxq.com/&quot;</span> ^<br>  --compressed<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>用程序去调用接口</strong> （java okhttp httpclient &#x2F; python 都可以）</li><li>处理（清洗）一下数据，之后就可以写到数据库里</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>从 excel 中导入全量用户数据，<strong>判重</strong> 。 easy excel：<a href="https://alibaba-easyexcel.github.io/index.html">https://alibaba-easyexcel.github.io/index.html</a></li><li>抓取写了自我介绍的同学信息，提取出用户昵称、用户唯一 id、自我介绍信息</li><li>从自我介绍中提取信息，然后写入到数据库中</li></ol><h4 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h4><p>两种读对象的方式：</p><ol><li>确定表头：建立对象，和表头形成映射关系</li><li>不确定表头：每一行数据映射为 Map&lt;String, Object&gt;</li></ol><p>两种读取模式：</p><ol><li>监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。</li><li>同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。</li></ol><h2 id="2022-06-12-【4】"><a href="#2022-06-12-【4】" class="headerlink" title="2022-06-12 【4】"></a>2022-06-12 【4】</h2><ol><li>页面和功能开发<ol><li>搜索页面</li><li>用户信息</li><li>用户修改页面</li></ol></li><li>改造用户中心，把单机登录改为分布式 session 登录</li><li>标签的整理、细节的优化</li></ol><h3 id="前端页面跳转传值"><a href="#前端页面跳转传值" class="headerlink" title="前端页面跳转传值"></a>前端页面跳转传值</h3><ol><li>query &#x3D;&gt; url searchParams，url 后附加参数，传递的值长度有限</li><li>vuex（全局状态管理），搜索页将关键词塞到状态中，搜索结果页从状态取值</li></ol><h2 id="Session-共享"><a href="#Session-共享" class="headerlink" title="Session 共享"></a>Session 共享</h2><p>种 session 的时候注意范围，cookie.domain</p><p>比如两个域名：</p><p>aaa.yupi.com</p><p>bbb.yupi.com</p><p>如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com</p><h3 id="为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？"><a href="#为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？" class="headerlink" title="为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？"></a>为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？</h3><p>用户在 A 登录，所以 session（用户登录信息）存在了 A 上</p><p>结果请求 B 时，B 没有用户信息，所以不认识。</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234247152.png"></p><p>解决方案：<strong>共享存储</strong> ，而不是把数据放到单台服务器的内存中</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234335539.png"></p><p>如何共享存储？</p><ol><li>Redis（基于内存的 K &#x2F; V 数据库）此处选择 Redis，因为用户信息读取 &#x2F; 是否登录的判断极其<strong>频繁</strong> ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w</li><li>MySQL </li><li>文件服务器 ceph</li></ol><h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>windows 下载：</p><p>Redis 5.0.14 下载：</p><p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p><p>提取码：vkoi </p><p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p><ol start="2"><li>引入 redis，能够操作 redis：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p><p>默认是 none，表示存储在单台服务器</p><p>store-type: redis，表示从 redis 读写 session</p></li></ol><p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p><h2 id="todo-待优化"><a href="#todo-待优化" class="headerlink" title="todo 待优化"></a>todo 待优化</h2><p>前端：动态展示页面标题、微调格式</p><h2 id="2022-07-03-伙伴匹配系统-5"><a href="#2022-07-03-伙伴匹配系统-5" class="headerlink" title="2022-07-03 伙伴匹配系统 5"></a>2022-07-03 伙伴匹配系统 5</h2><ol><li>用户修改页面前端、后端开发和联调</li></ol><h2 id="2022-07-17-伙伴匹配系统-6"><a href="#2022-07-17-伙伴匹配系统-6" class="headerlink" title="2022-07-17 伙伴匹配系统 6"></a>2022-07-17 伙伴匹配系统 6</h2><ol><li>开发主页（默认推荐和自己兴趣相当的用户）</li><li>优化主页的性能（缓存 + 定时任务 + 分布式锁）</li></ol><h3 id="开发主页"><a href="#开发主页" class="headerlink" title="开发主页"></a>开发主页</h3><p>最简单：直接 list 列表</p><p>模拟 1000 万个用户，再去查询</p><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><ol><li><p>用可视化界面：适合一次性导入、数据量可控</p></li><li><p>写程序：for 循环，建议分批，不要一把梭哈（可以用接口来控制）<strong>要保证可控、幂等，注意线上环境和测试环境是有区别的</strong></p><p>导入 1000 万条，for i 1000w</p></li><li><p>执行 SQL 语句：适用于小数据量</p></li></ol><h4 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h4><p>for 循环插入数据的问题：</p><ol><li>建立和释放数据库链接（批量查询解决）</li><li>for 循环是绝对线性的（并发）</li></ol><p>并发要注意执行的先后顺序无所谓，不要用到非并发类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">16</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10000</span>));<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// <span class="hljs-meta">CPU</span> 密集型：分配的核心线程数 = <span class="hljs-meta">CPU</span> - <span class="hljs-number">1</span><br>// IO 密集型：分配的核心线程数可以大于 <span class="hljs-meta">CPU</span> 核数<br></code></pre></td></tr></table></figure><p>数据库慢？预先把数据查出来，放到一个更快读取的地方，不用再查数据库了。（缓存）</p><p>预加载缓存，定时更新缓存。（定时任务）</p><p>多个机器都要执行任务么？（分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了）</p><h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><p>用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快地读写。</p><h3 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h3><ul><li>Redis（分布式缓存）</li><li>memcached（分布式）</li><li>Etcd（云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li></ul><hr><ul><li><p>ehcache（单机）</p></li><li><p>本地缓存（Java 内存 Map）</p></li><li><p>Caffeine（Java 内存缓存，高性能）</p></li><li><p>Google Guava</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>NoSQL 数据库</p></blockquote><p>key - value 存储系统（区别于 MySQL，他存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>String 字符串类型： name: “yupi”</p><p>List 列表：names: [“yupi”, “dogyupi”, “yupi”]</p><p>Set 集合：names: [“yupi”, “dogyupi”]（值不能重复）</p><p>Hash 哈希：nameAge: {  “yupi”: 1, “dogyupi”: 2 }</p><p>Zset 集合：names: {  yupi - 9,   dogyupi - 12  }（适合做排行榜）</p><hr><p>bloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）</p><p>geo（计算地理位置）</p><p>hyperloglog（pv &#x2F; uv）</p><p>pub &#x2F; sub（发布订阅，类似消息队列）</p><p>BitMap （1001010101010101010101010101）</p><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yupao.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTemplateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(connectionFactory);<br>        redisTemplate.setKeySerializer(RedisSerializer.string());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引入一个库时，先写测试类</p></blockquote><h3 id="Java-里的实现方式"><a href="#Java-里的实现方式" class="headerlink" title="Java 里的实现方式"></a>Java 里的实现方式</h3><h4 id="Spring-Data-Redis（推荐）"><a href="#Spring-Data-Redis（推荐）" class="headerlink" title="Spring Data Redis（推荐）"></a>Spring Data Redis（推荐）</h4><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong> 的接口</p><p>mysql、redis、jpa</p><p><a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">spring-data-redis</a></p><p>1）引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># redis 配置</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立于 Spring 操作 Redis 的 Java 客户端</p><p>要配合 Jedis Pool 使用</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong> 的操作 Redis 的 Java 客户端</p><p>异步、连接池</p><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，让你像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）</p><h4 id="JetCache"><a href="#JetCache" class="headerlink" title="JetCache"></a>JetCache</h4><p>对比</p><ol><li>如果你用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li><li>如果你用的不是 SPring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool</li><li>如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池</li></ol><hr><ul><li>如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson</li></ul><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>不同用户看到的数据不同</p><p>systemId:moduleId:func:options（不要和别人冲突）</p><p>yupao:user:recommed:userId</p><p><strong>redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库</p><p>缓存预热的优点：</p><ol><li>解决上面的问题，可以让用户始终访问很快</li></ol><p>缺点：</p><ol><li>增加开发成本（你要额外的开发、设计）</li><li>预热的时机和时间如果错了，有可能你缓存的数据不对或者太老</li><li>需要占用额外空间</li></ol><h4 id="怎么缓存预热？"><a href="#怎么缓存预热？" class="headerlink" title="怎么缓存预热？"></a>怎么缓存预热？</h4><ol><li>定时</li><li>模拟触发（手动触发）</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处每天一次）</li></ol><blockquote><p>分析优缺点的时候，要打开思路，从整个项目从 0 到 1 的链路上去分析</p></blockquote><h3 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h3><ol><li><strong>Spring Scheduler（spring boot 默认整合了）</strong> </li><li>Quartz（独立于 Spring 存在的定时任务框架）</li><li>XXL-Job 之类的分布式任务调度平台（界面 + sdk）</li></ol><p>第一种方式：</p><ol><li>主类开启 @EnableScheduling</li><li>给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率</li></ol><p>不要去背 cron 表达式！！！！！</p><ul><li><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></li></ul><hr><h3 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h3><p>为啥？</p><ol><li>浪费资源，想象 10000 台服务器同时 “打鸣”</li><li>脏数据，比如重复插入</li></ol><p><strong>要控制定时任务在同一时间只有 1 个服务器能执行。</strong></p><p>怎么做？</p><ol><li><p>分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大</p></li><li><p>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低；但是我们的 IP 可能是不固定的，把 IP 写的太死了</p></li><li><p>动态配置，配置是可以轻松的、很方便地更新的（<strong>代码无需重启</strong>），但是只有 ip 符合配置的服务器才真实执行业务逻辑。</p><ul><li>数据库</li><li>Redis</li><li>配置中心（Nacos、Apollo、Spring Cloud Config）</li></ul><p>问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改</p></li><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。</p></li></ol><p><strong>单机就会存在单点故障。</strong></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</p><p>Java 实现锁：synchronized 关键字、并发包的类</p><p>问题：只对单个 JVM 有效</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>为啥需要分布式锁？</p><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</li><li>单个锁只对单个 JVM 有效</li></ol><h3 id="分布式锁实现的关键"><a href="#分布式锁实现的关键" class="headerlink" title="分布式锁实现的关键"></a>分布式锁实现的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 个服务器能抢到锁？</p><p><strong>核心思想</strong> 就是：先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。</p><p>等先来的人执行方法结束，把标识清空，其他的人继续抢锁。</p><p>MySQL 数据库：select for update 行级锁（最简单）</p><p>（乐观锁）</p><p>✔ Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。</p><p>setnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>用完锁要释放（腾地方）√</p></li><li><p><strong>锁一定要加过期时间 √</strong></p></li><li><p>如果方法执行时间过长，锁提前过期了？</p><p>问题：</p><ol><li>连锁效应：释放掉别人的锁</li><li>这样还是会存在多个方法同时执行的情况</li></ol></li></ol><p>​解决方案：续期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!end)&#125;&#123;<br>    续期<br>&#125;)<br><br>end = <span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure><ol start="4"><li><p>释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子操作</span><br><span class="hljs-keyword">if</span>(get lock == A) &#123;<br>    <span class="hljs-comment">// set lock B</span><br>    del lock<br>&#125;<br></code></pre></td></tr></table></figure><p>Redis + lua 脚本实现</p></li><li><p>Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p></li></ol><p><a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p><h4 id="拒绝自己写！！！"><a href="#拒绝自己写！！！" class="headerlink" title="拒绝自己写！！！"></a>拒绝自己写！！！</h4><h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Java 客户端，数据网格</p><p>实现了很多 Java 里支持的接口和数据结构</p><p>Redisson 是一个 java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。</strong></p><h4 id="2-种引入方式"><a href="#2-种引入方式" class="headerlink" title="2 种引入方式"></a>2 种引入方式</h4><ol><li>spring boot starter 引入（不推荐，版本迭代太快，容易冲突）<a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs setnx">// list，数据存在本地 JVM 内存中<br>List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;yupi&quot;);<br>System.out.println(&quot;list:&quot; + list.get(0));<br><br>list.remove(0);<br><br>// 数据存在 redis 的内存中<br>RList&lt;String&gt; rList = redissonClient.getList(&quot;test-list&quot;);<br>rList.add(&quot;yupi&quot;);<br>System.out.println(&quot;rlist:&quot; + rList.get(0));<br>rList.remove(0);<br></code></pre></td></tr></table></figure><h3 id="定时任务-锁"><a href="#定时任务-锁" class="headerlink" title="定时任务  + 锁"></a>定时任务  + 锁</h3><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>注意释放锁要写在 finally 中</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testWatchDog</span>()</span> &#123;<br>    RLock <span class="hljs-keyword">lock</span> = redissonClient.getLock(<span class="hljs-string">&quot;yupao:precachejob:docache:lock&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 只有一个线程能获取到锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>.tryLock(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-comment">// todo 实际要执行的方法</span><br>            doSomeThings();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;getLock: &quot;</span> + Thread.currentThread().getId());<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(e.getMessage());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 只能释放自己的锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>.isHeldByCurrentThread()) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;unLock: &quot;</span> + Thread.currentThread().getId());<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h3><blockquote><p>redisson 中提供的续期机制</p></blockquote><p>开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。</p><p>原理：</p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p><a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p><hr><p>Zookeeper 实现（不推荐）</p><h3 id="组队功能-1h"><a href="#组队功能-1h" class="headerlink" title="组队功能 1h"></a>组队功能 1h</h3><p>理解为王者荣耀</p><h4 id="理想的应用场景"><a href="#理想的应用场景" class="headerlink" title="理想的应用场景"></a>理想的应用场景</h4><p>我要跟别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍</p><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p><strong>用户创建队伍最多 5 个</strong></p></blockquote><p>展示队伍列表，根据名称搜索队伍  P0，信息流中不展示已过期的队伍</p><p>修改队伍信息 P0 ~ P1</p><p>用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限  P0</p><blockquote><p>是否需要队长同意？筛选审批？</p></blockquote><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 —— 先来后到） P1</p><p>队长可以解散队伍 P0</p><hr><p>分享队伍 &#x3D;》 邀请其他用户加入队伍 P1</p><p>业务流程：</p><ol><li>生成分享链接（分享二维码）</li><li>用户访问链接，可以点击加入</li></ol><p>队伍人满后发送消息通知 P1</p><h4 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h4><h5 id="1、创建队伍"><a href="#1、创建队伍" class="headerlink" title="1、创建队伍"></a>1、创建队伍</h5><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p>信息流中不展示已过期的队伍</p></blockquote><ol><li>请求参数是否为空？</li><li>是否登录，未登录不允许创建</li><li>校验信息<ol><li>队伍人数 &gt; 1 且 &lt;&#x3D; 20</li><li>队伍标题 &lt;&#x3D; 20</li><li>描述 &lt;&#x3D; 512</li><li>status 是否公开（int）不传默认为 0（公开）</li><li>如果 status 是加密状态，一定要有密码，且密码 &lt;&#x3D; 32</li><li>超时时间 &gt; 当前时间</li><li>校验用户最多创建 5 个队伍</li></ol></li><li>插入队伍信息到队伍表</li><li>插入用户  &#x3D;&gt; 队伍关系到关系表</li></ol><h5 id="2、查询队伍列表"><a href="#2、查询队伍列表" class="headerlink" title="2、查询队伍列表"></a>2、查询队伍列表</h5><p>分页展示队伍列表，根据名称、最大人数等搜索队伍  P0，信息流中不展示已过期的队伍</p><ol><li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li><li>不展示已过期的队伍（根据过期时间筛选）</li><li>可以通过某个<strong>关键词</strong>同时对名称和描述查询</li><li><strong>只有管理员才能查看加密还有非公开的房间</strong></li><li>关联查询已加入队伍的用户信息</li><li><strong>关联查询已加入队伍的用户信息（可能会很耗费性能，建议大家用自己写 SQL 的方式实现）</strong></li></ol><p><strong>实现方式</strong></p><p>1）自己写 SQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">// 1. 自己写 SQL<br>// 查询队伍和创建人的信息<br>// <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> team t <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">on</span> t.userId = u.id<br>// 查询队伍和已加入队伍成员的信息<br>// <span class="hljs-keyword">select</span> *<br>// <span class="hljs-keyword">from</span> team t<br>//         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_team ut <span class="hljs-keyword">on</span> t.id = ut.teamId<br>//         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">on</span> ut.userId = u.id;<br></code></pre></td></tr></table></figure><h5 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3. 修改队伍信息"></a>3. 修改队伍信息</h5><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者队伍的创建者可以修改</li><li>如果用户传入的新值和老值一致，就不用 update 了（可自行实现，降低数据库使用次数）</li><li><strong>如果队伍状态改为加密，必须要有密码</strong></li><li>更新成功</li></ol><h5 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4. 用户可以加入队伍"></a>4. 用户可以加入队伍</h5><p>其他人、未满、未过期，允许加入多个队伍，但是要有个上限  P0</p><ol><li>用户最多加入 5 个队伍</li><li>队伍必须存在，只能加入未满、未过期的队伍</li><li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入的队伍是加密的，必须密码匹配才可以</li><li>新增队伍 - 用户关联信息</li></ol><p><strong>注意，一定要加上事务注解！！！！</strong></p><h5 id="5-用户可以退出队伍"><a href="#5-用户可以退出队伍" class="headerlink" title="5. 用户可以退出队伍"></a>5. 用户可以退出队伍</h5><p>请求参数：队伍 id</p><ol><li><p>校验请求参数</p></li><li><p>校验队伍是否存在</p></li><li><p>校验我是否已加入队伍</p></li><li><p>如果队伍</p><ol><li><p>只剩一人，队伍解散</p></li><li><p>还有其他人</p><ol><li><p>如果是队长退出队伍，权限转移给第二早加入的用户 —— 先来后到</p><blockquote><p>只用取 id 最小的 2 条数据</p></blockquote></li><li><p>非队长，自己退出队伍</p></li></ol></li></ol></li></ol><h5 id="6-队长可以解散队伍"><a href="#6-队长可以解散队伍" class="headerlink" title="6. 队长可以解散队伍"></a>6. 队长可以解散队伍</h5><p>请求参数：队伍 id</p><p>业务流程：</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验你是不是队伍的队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><h5 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7. 获取当前用户已加入的队伍"></a>7. 获取当前用户已加入的队伍</h5><h5 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8. 获取当前用户创建的队伍"></a>8. 获取当前用户创建的队伍</h5><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p><hr><h4 id="事务注解"><a href="#事务注解" class="headerlink" title="事务注解"></a>事务注解</h4><p>@Transactional(rollbackFor &#x3D; Exception.class)</p><p>要么数据操作都成功，要么都失败</p><h3 id="数据库表设计-1"><a href="#数据库表设计-1" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>队伍表 team</p><p>字段：</p><ul><li>id 主键 bigint（最简单、连续，放 url 上比较简短，但缺点是爬虫）</li><li>name 队伍名称</li><li>description 描述</li><li>maxNum 最大人数</li><li>expireTime 过期时间</li><li>userId 创建人 id</li><li>status 0 - 公开，1 - 私有，2 - 加密</li><li>password 密码</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    name   <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)                   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;队伍名称&#x27;</span>,<br>    description <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>)                      <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    maxNum    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;最大人数&#x27;</span>,<br>    expireTime    datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;过期时间&#x27;</span>,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    status    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;0 - 公开，1 - 私有，2 - 加密&#x27;</span>,<br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)                       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>    <br>        createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;队伍&#x27;</span>;<br></code></pre></td></tr></table></figure><p>用户  - 队伍表 user_team</p><p>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    teamId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;队伍id&#x27;</span>,<br>    joinTime datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;加入时间&#x27;</span>,<br>    createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;用户队伍关系&#x27;</span>;<br></code></pre></td></tr></table></figure><p>两个关系：</p><ol><li>用户加了哪些队伍？</li><li>队伍有哪些用户？</li></ol><p>方式：</p><ol><li>建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）</li></ol><h4 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h4><ol><li><p>请求参数名称 &#x2F; 类型和实体类不一样</p></li><li><p>有一些参数用不到，如果要自动生成接口文档，会增加理解成本</p></li><li><p>对个实体类映射到同一个对象</p></li></ol><h4 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h4><p>可能有些字段需要隐藏，不能返回给前端</p><p>或者有些字段某些方法是不关心的</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>库表设计 5 - 10min</p><p>增删改查 5 - 10 min</p><p>业务逻辑开发（P0）30 min</p><h2 id="2022-09-18-12-期"><a href="#2022-09-18-12-期" class="headerlink" title="2022-09-18 12 期"></a>2022-09-18 12 期</h2><ol><li>开发前端的功能<ol><li>搜索队伍 √</li><li>更新队伍（仅队伍的创始人可见） √</li><li>查看个人已加入队伍 √</li><li>查看个人创建的队伍 √</li><li>解散队伍 √</li><li>退出队伍 √</li></ol></li><li>随机匹配 30 - 40 min</li><li>完成之前的遗留问题 todo</li></ol><h3 id="前端不同页面怎么传递数据？"><a href="#前端不同页面怎么传递数据？" class="headerlink" title="前端不同页面怎么传递数据？"></a>前端不同页面怎么传递数据？</h3><ol><li><strong>url querystring（xxx?id&#x3D;1）</strong> 比较适用于页面跳转</li><li><strong>url（&#x2F;team&#x2F;:id，xxx&#x2F;1）</strong></li><li>hash (&#x2F;team#1)</li><li>localStorage</li><li><strong>context（全局变量，同页面或整个项目要访问公共变量）</strong></li></ol><h3 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h3><blockquote><p>为了帮大家更快地发现和自己兴趣相同的朋友</p></blockquote><p>匹配 1 个还是匹配多个？</p><p>答：匹配多个，并且按照匹配的相似度从高到低排序</p><p>怎么匹配？（根据什么匹配）</p><p>答：标签 tags</p><blockquote><p>还可以根据 user_team 匹配加入相同队伍的用户</p></blockquote><p>本质：找到有相似标签的用户</p><p>举例：</p><p>用户 A：[Java, 大一, 男]</p><p>用户 B：[Java, 大二, 男]</p><p>用户 C：[Python, 大二, 女]</p><p>用户 D：[Java, 大一, 女]</p><h4 id="1-怎么匹配"><a href="#1-怎么匹配" class="headerlink" title="1. 怎么匹配"></a>1. 怎么匹配</h4><ol><li>找到有共同标签最多的用户（TopN）</li><li>共同标签越多，分数越高，越排在前面</li><li>如果没有匹配的用户，随机推荐几个（降级方案）</li></ol><p>编辑距离算法：<a href="https://blog.csdn.net/DBC_121/article/details/104198838">https://blog.csdn.net/DBC_121/article/details/104198838</a></p><blockquote><p>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2</p></blockquote><p>余弦相似度算法：<a href="https://blog.csdn.net/m0_55613022/article/details/125683937%EF%BC%88%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B8%A6%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%A6%E4%BB%80%E4%B9%88%E6%96%B9%E5%90%91%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%8C%E6%80%A7%E5%88%AB%E7%9B%B8%E5%AF%B9%E6%AC%A1%E8%A6%81%EF%BC%89">https://blog.csdn.net/m0_55613022/article/details/125683937（如果需要带权重计算，比如学什么方向最重要，性别相对次要）</a></p><h4 id="2-怎么对所有用户匹配，取-TOP"><a href="#2-怎么对所有用户匹配，取-TOP" class="headerlink" title="2. 怎么对所有用户匹配，取 TOP"></a>2. 怎么对所有用户匹配，取 TOP</h4><p>直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）</p><p>优化方法：</p><ol><li><p>切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒）</p></li><li><p>Map 存了所有的分数信息，占用内存</p><p>解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）</p><p>e.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了</p></li><li><p>细节：剔除自己 √</p></li><li><p>尽量只查需要的数据：</p><ol><li>过滤掉标签为空的用户 √</li><li>根据部分标签取用户（前提是能区分出来哪个标签比较重要）</li><li>只查需要的数据（比如 id 和 tags） √（7.0s）</li></ol></li><li><p>提前查？（定时任务）</p><ol><li>提前把所有用户给缓存（不适用于经常更新的数据）</li><li>提前运算出来结果，缓存（针对一些重点用户，提前缓存）</li></ol></li></ol><p>大数据推荐，比如说有几亿个商品，难道要查出来所有的商品？</p><p>难道要对所有的数据计算一遍相似度？</p><p>检索 &#x3D;&gt; 召回 &#x3D;&gt; 粗排 &#x3D;&gt; 精排 &#x3D;&gt; 重排序等等</p><p>检索：尽可能多地查符合要求的数据（比如按记录查）</p><p>召回：查询可能要用到的数据（不做运算）</p><p>粗排：粗略排序，简单地运算（运算相对轻量）</p><p>精排：精细排序，确定固定排位</p><h3 id="分表学习建议"><a href="#分表学习建议" class="headerlink" title="分表学习建议"></a>分表学习建议</h3><p>mycat、sharding sphere 框架</p><p>一致性 hash</p><h3 id="队伍操作权限控制"><a href="#队伍操作权限控制" class="headerlink" title="队伍操作权限控制"></a>队伍操作权限控制</h3><p>加入队伍： 仅非队伍创建人、且未加入队伍的人可见</p><p>更新队伍：仅创建人可见</p><p>解散队伍：仅创建人可见</p><p>退出队伍：创建人不可见，仅已加入队伍的人可见</p><p>加载骨架屏特效 ✔</p><p>解决：van-skeleton 组件</p><p>仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态） ✔</p><p>方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）</p><p>方案 2：在后端去做上述事情（推荐）</p><p>前端导航栏死【标题】问题 ✔</p><p>解决：使用 router.beforeEach，根据要跳转页面的 url 路径 匹配 config&#x2F;routes 配置的 title 字段。</p><h2 id="14-优化、上线"><a href="#14-优化、上线" class="headerlink" title="14 优化、上线"></a>14 优化、上线</h2><p>1、强制登录，自动跳转到登录页</p><p>解决：axios 全局配置响应拦截、并且添加重定向</p><p>2、区分公开和加密房间；加入有密码的房间，要指定密码</p><p>3、展示已加入队伍人数</p><p>4、重复加入队伍的问题（加锁、分布式锁）并发请求时可能出现问题</p><p><strong>分布式锁</strong></p><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><p>先区分多环境：前端区分开发和线上接口，后端 prod 改为用线上公网可访问的数据库</p><p>前端：Vercel（免费）</p><p><a href="https://vercel.com/">https://vercel.com/</a></p><p>后端：微信云托管（部署容器的平台，付费）</p><p><a href="https://cloud.weixin.qq.com/cloudrun/service">https://cloud.weixin.qq.com/cloudrun/service</a></p><p><strong>（免备案！！！）</strong></p><h2 id="如何改造成小程序？"><a href="#如何改造成小程序？" class="headerlink" title="如何改造成小程序？"></a>如何改造成小程序？</h2><p><strong>cordova、跨端开发框架 taro、uniapp</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E9%B1%BC%E7%A5%A8-%E5%8F%91%E5%88%B8%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E9%B1%BC%E7%A5%A8-%E5%8F%91%E5%88%B8%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="直播开发【发券系统】-鱼票"><a href="#直播开发【发券系统】-鱼票" class="headerlink" title="直播开发【发券系统】 鱼票"></a>直播开发【发券系统】 鱼票</h1><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>给星球的小伙伴发布一个兑换券，凭借兑换券可以充值积分。</strong></p><h4 id="传统思路"><a href="#传统思路" class="headerlink" title="传统思路"></a>传统思路</h4><p>在现有的系统上加功能？在同一个代码上去开发，或者就是该数据库。</p><hr><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>【腾讯文档】鱼票-发券中心项目流程图<br><a href="https://docs.qq.com/flowchart/DUGlDTmZja05MUW12">https://docs.qq.com/flowchart/DUGlDTmZja05MUW12</a></p><h4 id="发兑换券（可以理解为激活码）的系统"><a href="#发兑换券（可以理解为激活码）的系统" class="headerlink" title="发兑换券（可以理解为激活码）的系统"></a>发兑换券（可以理解为激活码）的系统</h4><ol><li>管理员<ol><li>创建兑换券（设置规则 —— <strong>一人一券</strong> &#x2F; 抢）</li><li>发券（设置数量、设置单个用户可以使用的次数）</li></ol></li><li>用户<ol><li>输入券码来兑换奖品</li><li>查看自己用过的券码</li></ol></li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue</li><li>Vite</li><li>Tencent UI</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java</li><li>SpringBoot + SSM + MyBatis Plus</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><ol><li>管理员 √<ol><li>创建兑换券，定义规则<ol><li>兑换券的名称</li><li>兑换券的描述</li><li>回调接口地址</li><li>回调接口信息（json）</li></ol></li><li>发券<ol><li>选择已经定义好的券</li><li>数量</li><li>开始时间</li><li>过期时间</li></ol></li><li>管理已发的券<ol><li>查看所有类型的券</li><li>查看每个券的发放情况</li></ol></li></ol></li><li>用户<ol><li>输入券码来兑换奖品</li><li>查看自己用过的券码</li></ol></li></ol><h3 id="Vue3-的几种事件传递方式"><a href="#Vue3-的几种事件传递方式" class="headerlink" title="Vue3 的几种事件传递方式"></a>Vue3 的几种事件传递方式</h3><ol><li>父组件通过 props 将方法传递给子组件</li><li>子组件直接 emit，触发父组件的事件</li></ol><h2 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h2><h3 id="设计库表"><a href="#设计库表" class="headerlink" title="设计库表"></a>设计库表</h3><h4 id="ticket（定义了一类券的信息）"><a href="#ticket（定义了一类券的信息）" class="headerlink" title="ticket（定义了一类券的信息）"></a>ticket（定义了一类券的信息）</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">id <span class="hljs-type">int</span> 主键<br>ticketName <span class="hljs-type">varchar</span> 券名称<br>ticketDesc <span class="hljs-type">varchar</span> 券描述<br>callbackUrl <span class="hljs-type">varchar</span> 回调地址,<br>callbackInfo <span class="hljs-type">text</span> 回调信息 <span class="hljs-type">json</span>,<br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="sendTicket（发券情况）"><a href="#sendTicket（发券情况）" class="headerlink" title="sendTicket（发券情况）"></a>sendTicket（发券情况）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-type">int</span> 主键<br>ticketId <span class="hljs-type">int</span> 券的类型<br>sendNum <span class="hljs-type">int</span> 发圈数量<br>sendStatus <span class="hljs-type">int</span> 发放状态（<span class="hljs-number">0</span> <span class="hljs-operator">-</span> 关闭，<span class="hljs-number">1</span> <span class="hljs-operator">-</span>开启）<br>expireTime <span class="hljs-type">date</span> 过期时间 <br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="ticketDetail（每张券的信息）"><a href="#ticketDetail（每张券的信息）" class="headerlink" title="ticketDetail（每张券的信息）"></a>ticketDetail（每张券的信息）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-type">int</span> 主键<br>ticketId <span class="hljs-type">int</span> 主键<br>sendTicketId <span class="hljs-type">int</span> 所属发券批次<br>token <span class="hljs-type">varchar</span> 券码<br>useStatus <span class="hljs-type">int</span> 使用状态 <span class="hljs-number">0</span> <span class="hljs-operator">-</span> 未使用 <span class="hljs-number">1</span><span class="hljs-operator">-</span> 已使用 <span class="hljs-number">2</span> <span class="hljs-operator">-</span> 使用失败<br>useInfo text 使用信息（用户自主输入）<br>useMessage text 用券情况信息 userId<br>useTime <span class="hljs-type">date</span> 使用时间<br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="创建券"><a href="#创建券" class="headerlink" title="创建券"></a>创建券</h4><p>校验券的信息</p><p>插入券</p><h4 id="发券"><a href="#发券" class="headerlink" title="发券"></a>发券</h4><ol><li>校验请求参数是否合法</li><li>校验这种券是否存在</li><li>创建发券批次信息</li><li>根据数量去创建多张券</li></ol><h3 id="优化发券-两个问题"><a href="#优化发券-两个问题" class="headerlink" title="优化发券 - 两个问题"></a>优化发券 - 两个问题</h3><ol><li>稳定性 —— 事务（可以解决不一致问题，保证原子性，要么都成功，要么都不成功）</li><li>性能 —— 多线程 &#x2F; 批量操作 - 减少重复创建连接</li></ol><blockquote><p>想要领取资料，跟着鱼皮直播做项目、1 对 1 交流答疑、和小伙伴一起交流学习的话：</p><p>欢迎加入鱼皮的编程星球 👉：<a href="http://dogyupi.com/">http://dogyupi.com</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/01/08/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/chaserblog/2024/01/08/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="递归和递推"><a href="#递归和递推" class="headerlink" title="递归和递推"></a>递归和递推</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">递归算法在计算机系统中用栈帮助实现，一般常见的算法有深度优先遍历（DFS），可以解决的问题有迷宫问题是否连通的问题，递推会对应一个递归搜索树，递归搜索树可以帮助我们更好的理解递归的流程，递归要注意的有是否可以进行剪枝，在迷宫问题中，也要考虑是否要保存原有的迷宫。<br></code></pre></td></tr></table></figure><h4 id="入门例题"><a href="#入门例题" class="headerlink" title="入门例题"></a>入门例题</h4><h5 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs excel">从 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span> 这 <span class="hljs-built_in">n</span> 个整数中随机选取任意多个，输出所有可能的选择方案。<br><br>输入格式<br>输入一个整数 <span class="hljs-built_in">n</span>。<br><br>输出格式<br>每行输出一种方案。<br><br>同一行内的数必须升序排列，相邻两个数用恰好 <span class="hljs-number">1</span> 个空格隔开。<br><br>对于没有选任何数的方案，输出空行。<br><br>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">15</span><br>输入样例：<br><span class="hljs-number">3</span><br>输出样例：<br><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>题解：</p><p>对于指数型枚举一个数只有选与不选的区分，所以我们从第一个位置，枚举到第n个位置，在第i个位置上，i这个数只有选与不选的区别，选的话我们将st[i]记录为i；不选记录为-1；一直到u&gt;n时枚举了所有的位置，此时输出即可，要注意的是在输出完后要记得return掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u&gt;n)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(st[i]==<span class="hljs-number">1</span>) cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    st[u]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>    <br>    st[u]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tap">把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。<br><br>输入格式<br>一个整数 n。<br><br>输出格式<br>按照从小到大的顺序输出所有方案，每行<span class="hljs-number"> 1 </span>个。<br><br>首先，同一行相邻两个数用一个空格隔开。<br><br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。<br><br>数据范围<br>1≤n≤9<br>输入样例：<br>3<br>输出样例：<br>1<span class="hljs-number"> 2 </span>3<br>1<span class="hljs-number"> 3 </span>2<br>2<span class="hljs-number"> 1 </span>3<br>2<span class="hljs-number"> 3 </span>1<br>3<span class="hljs-number"> 1 </span>2<br>3<span class="hljs-number"> 2 </span>1<br></code></pre></td></tr></table></figure><p>题解</p><p>在排列型枚举中，我们有n个位置，在每个位置上分别枚举这个位置可以放那个数，所以我们有一个path数组来记录排列的方案，使用st的bool数组来判断这个数是否选过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u&gt;n)&#123;<span class="hljs-comment">//所有位置枚举完成</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//在第u个位置上枚举所有方案，这个位置上可以放置所有没有被用过的数字。</span><br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            path[u]=i;<br>            st[i]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//表示这个数被用过了</span><br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            st[i]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//还原状态，保证回溯时下一层递归一致。</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。<br><br>输入格式<br>两个整数 n,m ,在同一行用空格隔开。<br><br>输出格式<br>按照从小到大的顺序输出所有方案，每行<span class="hljs-number"> 1 </span>个。<br><br>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。<br><br>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 5 </span>7 排在<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 6 </span>8 前面）。<br><br>数据范围<br>n&gt;0 ,<br>0≤m≤n ,<br>n+(n−m)≤25<br>输入样例：<br>5 3<br>输出样例：<br>1<span class="hljs-number"> 2 </span>3 <br>1<span class="hljs-number"> 2 </span>4 <br>1<span class="hljs-number"> 2 </span>5 <br>1<span class="hljs-number"> 3 </span>4 <br>1<span class="hljs-number"> 3 </span>5 <br>1<span class="hljs-number"> 4 </span>5 <br>2<span class="hljs-number"> 3 </span>4 <br>2<span class="hljs-number"> 3 </span>5 <br>2<span class="hljs-number"> 4 </span>5 <br>3<span class="hljs-number"> 4 </span>5 <br></code></pre></td></tr></table></figure><p>题解</p><p>在组合数枚举中，我们可以通过认为确定枚举的顺序来通过类似排列数的方法来实现，不同的一点时在排列数枚举时，我们要在传一个参数num表示前一位枚举到那个数字，首先写一个朴素方法，该方法的时间是1601ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(u&gt;m)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i]&amp;&amp;i&gt;num)&#123;<br>            st[i]=<span class="hljs-literal">true</span>;<br>            path[u]=i;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>,i);<br>            st[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面做一个优化</p><p>我们在递归前提前判断一个，上一个位置的数是否合理，如果后面剩的数字不能满足m个位置和递增的条件就直接return掉，进行剪枝，优化时间复杂度。该方法的时间是103ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> path[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(num&gt;n-m+u<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(u&gt;m)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i]&amp;&amp;i&gt;num)&#123;<br>            st[i]=<span class="hljs-literal">true</span>;<br>            path[u]=i;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>,i);<br>            st[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><p>通过深度优先搜索（DFS）方法实现。</p><h5 id="迷宫问题一"><a href="#迷宫问题一" class="headerlink" title="迷宫问题一"></a>迷宫问题一</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs gams">一天蒜头君掉进了一个迷宫里面，蒜头君想逃出去，可怜的蒜头君连迷宫是否有能逃出去的路都不知道。<br><br>看在蒜头君这么可怜的份上，就请聪明的你告诉蒜头君是否有可以逃出去的路。<br><br>输入格式<br>第一行输入两个整数 nn 和 mm，表示这是一个 n \times mn×m 的迷宫。<br><br>接下来的输入一个 nn 行 mm 列的迷宫。其中 <span class="hljs-string">&#x27;S&#x27;</span> 表示蒜头君的位置，<span class="hljs-string">&#x27;*&#x27;</span>表示墙，蒜头君无法通过，<span class="hljs-string">&#x27;.&#x27;</span>表示路，蒜头君可以通过<span class="hljs-string">&#x27;.&#x27;</span>移动，<span class="hljs-string">&#x27;T&#x27;</span>表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。<br><br>输出格式<br>输出一个字符串，如果蒜头君可以逃出迷宫输出<span class="hljs-string">&quot;yes&quot;</span>，否则输出<span class="hljs-string">&quot;no&quot;</span>。<br><br>数据范围<br><span class="hljs-number">1</span> \<span class="hljs-keyword">le</span> n, m \<span class="hljs-keyword">le</span> <span class="hljs-number">101</span>≤n,m≤<span class="hljs-number">10</span>。<br><br>输出时每行末尾的多余空格，不影响答案正确性<br><br>样例输入<span class="hljs-number">1</span>复制<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>S**.<br>..*.<br><span class="hljs-comment">***T</span><br>样例输出<span class="hljs-number">1</span>复制<br><span class="hljs-keyword">no</span><br>样例输入<span class="hljs-number">2</span>复制<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>S**.<br>....<br><span class="hljs-comment">***T</span><br>样例输出<span class="hljs-number">2</span>复制<br><span class="hljs-keyword">yes</span><br></code></pre></td></tr></table></figure><p>题解</p><p>我们读入所有数据，然后获得起点S的坐标。然后深度优先遍历，在迷宫问题中进入DFS后，要先判断是否到中点，在判断是否是障碍物，然后标记该点访问过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;T&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    st[x][y]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i],b=y+dy[i];<br>        <span class="hljs-keyword">if</span>(a&gt;n||a&lt;=<span class="hljs-number">0</span>||b&lt;=<span class="hljs-number">0</span>||b&gt;m)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(a,b))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;g[i][j];<br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)&#123;<br>                x=i;<br>                y=j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(x,y))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;yes&quot;</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;no&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迷宫问题二"><a href="#迷宫问题二" class="headerlink" title="迷宫问题二"></a>迷宫问题二</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml">蒜头君在你的帮助下终于逃出了迷宫，但是蒜头君并没有沉浸于喜悦之中，而是很快的又陷入了思考，从这个迷宫逃出的最少步数是多少呢？<br><br>输入格式<br>第一行输入两个整数 nn 和 mm，表示这是一个 n \times mn×m 的迷宫。<br><br>接下来的输入一个 nn 行 mm 列的迷宫。其中 &#x27;S&#x27; 表示蒜头君的位置，&#x27;*&#x27;表示墙，蒜头君无法通过，&#x27;.&#x27;表示路，蒜头君可以通过&#x27;.&#x27;移动，&#x27;T&#x27;表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。<br><br>输出格式<br>输出整数，表示蒜头君逃出迷宫的最少步数，如果蒜头君无法逃出迷宫输出 -1−1。<br><br>数据范围<br>1 \le n, m \le 101≤n,m≤10。<br><br>输出时每行末尾的多余空格，不影响答案正确性<br><br>样例输入1复制<br>3 4<br>S**.<br>..*.<br>***T<br>样例输出1复制<br>-1<br>样例输入2复制<br>3 4<br>S**.<br>....<br>***T<br>样例输出2复制<br>5<br></code></pre></td></tr></table></figure><p>题解</p><p>本题要求判断是否可以到达并且要计算出最短路径，其实用宽度优先搜索更为合适，因为宽度优先搜索第一次到达目的地就是最短路径，但是我们使用深度优先也可以实现，我们定义一个最短量来储存最短的路径，当每一次到达目的点就比较一下与最短路的大小，交换最短路径长度，因此我们要遍历所有的可行路径，所以就要回溯访问状态，所以在一个遍历后就要复原，将一个点置为未访问，额额额，在 这道题中，我开始忘了读入n和m所以出现了segment段错误，还检查了好久没查到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> Min=<span class="hljs-number">99999</span>;<br><span class="hljs-type">int</span> m,n;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> stmp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stmp&gt;Min) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;T&#x27;</span>)&#123;<br>        Min=<span class="hljs-built_in">min</span>(Min,stmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;  <br>    st[x][y]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(g[x][y]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i],b=y+dy[i];<br>        <span class="hljs-keyword">if</span>(a&gt;n||a&lt;=<span class="hljs-number">0</span>||b&gt;m||b&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(a,b,stmp+<span class="hljs-number">1</span>);<br>        st[a][b]=<span class="hljs-literal">false</span>;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;g[i][j];<br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)&#123;<br>                a=i,b=j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(a,b,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(Min==<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;Min&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="迷宫问题三"><a href="#迷宫问题三" class="headerlink" title="迷宫问题三"></a>迷宫问题三</h5><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs clean">经过思考蒜头君终于解决了怎么计算一个迷宫的最短路问题，于是蒜头君找到一个新的迷宫图，来验证自己是否真的会计算一个迷宫的最短路。<br><br>为了检验自己计算的是否正确，蒜头君特邀你一起来计算。<br><br>输入格式<br>第一行输入两个整数 nn 和 mm，表示这是一个 n \times mn×m 的迷宫。<br><br>接下来的输入一个 nn 行 mm 列的迷宫。其中<span class="hljs-string">&#x27;@&#x27;</span>表示蒜头君的位置，<span class="hljs-string">&#x27;#&#x27;</span>表示墙，蒜头君无法通过，<span class="hljs-string">&#x27;.&#x27;</span>表示路，蒜头君可以通过<span class="hljs-string">&#x27;.&#x27;</span>移动，所有在迷宫最外围的<span class="hljs-string">&#x27;.&#x27;</span>都表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。<br><br>输出格式<br>输出整数，表示蒜头君逃出迷宫的最少步数，如果蒜头君无法逃出迷宫输出 <span class="hljs-number">-1</span>−<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span> \le n,m \le <span class="hljs-number">151</span>≤n,m≤<span class="hljs-number">15</span>。<br><br>输出时每行末尾的多余空格，不影响答案正确性<br><br>样例输入<span class="hljs-number">1</span>复制<br><span class="hljs-number">9</span> <span class="hljs-number">13</span><br>#############<br>#@..........#<br>#####.#.#.#.#<br>#...........#<br>#.#.#.#.#.#.#<br>#.#.......#.#<br>#.#.#.#.#.#.#<br>#...........#<br>#####.#######<br>样例输出<span class="hljs-number">1</span>复制<br><span class="hljs-number">11</span><br>样例输入<span class="hljs-number">2</span>复制<br><span class="hljs-number">4</span> <span class="hljs-number">6</span><br>#.####<br>#.#.##<br>#...@#<br>######<br>样例输出<span class="hljs-number">2</span>复制<br><span class="hljs-number">5</span><br><br></code></pre></td></tr></table></figure><p>题解</p><p>该迷宫问题与第二个迷宫问题类似，我们也要求出最短路径，所以一样要使用minn记录短的路径。</p><p>但是这个题要注意到达的条件，和第二个迷宫终点判断不一样，这个题要观察迷宫的构造，判断终止条件。所以这道题尽量从1开始存储迷宫图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">bool</span> st[N][N];<br><span class="hljs-type">int</span> minn=<span class="hljs-number">99999</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> stmp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stmp&gt;minn)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>||y==<span class="hljs-number">0</span>||x==n+<span class="hljs-number">1</span>||y==m+<span class="hljs-number">1</span>)&#123;<br>        minn=<span class="hljs-built_in">min</span>(minn,stmp);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    st[x][y]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i],b=y+dy[i];<br>        <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(st[a][b])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(a,b,stmp+<span class="hljs-number">1</span>);<br>        st[a][b]=<span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;g[i][j];<br>            <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;@&#x27;</span>)&#123;<br>                x=i;y=j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(x,y,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(minn==<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;minn<span class="hljs-number">-1</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，dfs递归就先写到这里，之后图论的时候我们在聊。</p><h3 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h3><h4 id="入门例题-1"><a href="#入门例题-1" class="headerlink" title="入门例题"></a>入门例题</h4><h5 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入一个整数 <span class="hljs-built_in">n</span> ，求斐波那契数列的第 <span class="hljs-built_in">n</span> 项。<br><br>假定从 <span class="hljs-number">0</span> 开始，第 <span class="hljs-number">0</span> 项为 <span class="hljs-number">0</span>。<br><br>数据范围<br><span class="hljs-number">0</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">39</span><br>样例<br>输入整数 <span class="hljs-built_in">n</span>=<span class="hljs-number">5</span> <br><br>返回 <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>题解</p><p>该题十分基础，我们要理解斐波那契数列的组成，数列中从每一项都是前两项的和，所以如果不要求存下一些数的数值，我们就可以直接使用，几个变量操作不用进行数组创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            t=a+b;<br>            a=b;<br>            b=t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs tap">你玩过“拉灯”游戏吗？<br><br>25 盏灯排成一个 5×5 的方形。<br><br>每一个灯都有一个开关，游戏者可以改变它的状态。<br><br>每一步，游戏者可以改变某一个灯的状态。<br><br>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。<br><br>我们用数字<span class="hljs-number"> 1 </span>表示一盏开着的灯，用数字<span class="hljs-number"> 0 </span>表示关着的灯。<br><br>下面这种状态<br><br>10111<br>01101<br>10111<br>10000<br>11011<br>在改变了最左上角的灯的状态后将变成：<br><br>01111<br>11101<br>10111<br>10000<br>11011<br>再改变它正中间的灯后状态将变成：<br><br>01111<br>11001<br>11001<br>10100<br>11011<br>给定一些游戏的初始状态，编写程序判断游戏者是否可能在<span class="hljs-number"> 6 </span>步以内使所有的灯都变亮。<br><br>输入格式<br>第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。<br><br>以下若干行数据分为 n 组，每组数据有<span class="hljs-number"> 5 </span>行，每行<span class="hljs-number"> 5 </span>个字符。<br><br>每组数据描述了一个游戏的初始状态。<br><br>各组数据间用一个空行分隔。<br><br>输出格式<br>一共输出 n 行数据，每行有一个小于等于<span class="hljs-number"> 6 </span>的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。<br><br>对于某一个游戏初始状态，若<span class="hljs-number"> 6 </span>步以内无法使所有灯变亮，则输出 −1。<br><br>数据范围<br>0&lt;n≤500<br>输入样例：<br>3<br>00111<br>01011<br>10001<br>11010<br>11100<br><br>11101<br>11101<br>11110<br>11111<br>11111<br><br>01111<br>11111<br>11111<br>11111<br>11111<br>输出样例：<br><br>3<br>2<br>-1<br></code></pre></td></tr></table></figure><p>题解</p><p>该题我们分析可以发现，我们可以通过枚举第一行的5个灯的32中开与不开的状态来实现，因为第一行开关确定以后，第一行的开关亮与不亮只与下一层开关有关，如果i-1行j列是关的，我们就开一下i行j列的灯就可以使上一个灯泡开，一次递推我们就可以实现是否所有灯都能开，要注意的是我们要保存一下开始的灯泡状态，因为要枚举32次，积累一下位运算&gt;&gt;</p><p>我们可以通过op&gt;&gt;i&amp;1表示第一行的灯是否开，这是通过二进制存储实现的，我们用0表示不开，用1表示开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">char</span> g[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>],backup[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">turn</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        <span class="hljs-type">int</span> a=x+dx[i],b=y+dy[i];<br>        <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span>||a&gt;=<span class="hljs-number">5</span>||b&lt;<span class="hljs-number">0</span>||b&gt;=<span class="hljs-number">5</span>)<span class="hljs-keyword">continue</span>;<br>        g[a][b]^=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)cin&gt;&gt;g[i];<br>        <br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> op=<span class="hljs-number">0</span>;op&lt;<span class="hljs-number">32</span>;op++)&#123;<br>            <span class="hljs-built_in">memcpy</span>(backup,g,<span class="hljs-keyword">sizeof</span> g);<br>            <span class="hljs-type">int</span> stmp=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(op&gt;&gt;i&amp;<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-built_in">turn</span>(<span class="hljs-number">0</span>,i);<br>                    stmp++;<br>                &#125;<br>            &#125;<br>            <br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(g[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                        <span class="hljs-built_in">turn</span>(i,j);<br>                        stmp++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-type">bool</span> suf=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">5</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(g[<span class="hljs-number">4</span>][j]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    suf=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(suf)&#123;<br>                ans=<span class="hljs-built_in">min</span>(ans,stmp);<br>            &#125;<br>            <br>            <span class="hljs-built_in">memcpy</span>(g,backup,<span class="hljs-keyword">sizeof</span> backup);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans&gt;<span class="hljs-number">6</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;ans&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分和前缀和"><a href="#二分和前缀和" class="headerlink" title="二分和前缀和"></a>二分和前缀和</h2><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="二分简介"><a href="#二分简介" class="headerlink" title="二分简介"></a>二分简介</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">二分分为整数二分和实数二分两种，<br><span class="hljs-section">#### 整数二分步骤：</span><br><br><span class="hljs-bullet">1.</span> 找一个区间[L, R]，使得答案一定在该区间中<br><span class="hljs-bullet">2.</span> 找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点。<br><span class="hljs-bullet">3.</span> 分析中点M在该判断条件下是否成立，如果<br>   （成立，考虑答案在那个区间。如果不成立，考虑答案在那个区间）<br><span class="hljs-bullet">4.</span> 如果更新方式写的是R = Mid，则此时l=mid+1，这是mid更新方式是<br>   如果更新方式是l=mid;则mid=l+r+1&gt;&gt;1;c此时r=mid-1；<br></code></pre></td></tr></table></figure><h4 id="入门例题-2"><a href="#入门例题-2" class="headerlink" title="入门例题"></a>入门例题</h4><h5 id="二分查找一"><a href="#二分查找一" class="headerlink" title="二分查找一"></a>二分查找一</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问整数 xx 是否在数组 AA 中。<br><br>输入格式<br>第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。<br><br>接下来一行有 nn 个整数 a_ia <br>i<br>​<br> 。<br><br>接下来 mm 行，每行有 11 个整数 xx，表示蒜头君询问的整数。<br><br>输出格式<br>对于每次查询，如果可以找到，输出&quot;YES&quot;，否则输出&quot;NO&quot;。<br><br>数据范围<br>1≤n,m≤1e5 0≤x≤1e6<br><br>输出时每行末尾的多余空格，不影响答案正确性<br><br>样例输入复制<br>10 5<br>1 1 1 2 3 5 5 7 8 9<br>0<br>1<br>4<br>9<br>10<br>样例输出复制<br>NO<br>YES<br>NO<br>YES<br>NO<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cin&gt;&gt;num[i];<br>    <span class="hljs-built_in">sort</span>(num,num+n);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> t;<br>        cin&gt;&gt;t;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;    <br>            <span class="hljs-keyword">if</span>(num[mid]&gt;=t)&#123;<br>                r=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num[l]!=t)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二分查找二"><a href="#二分查找二" class="headerlink" title="二分查找二"></a>二分查找二</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tap">蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问在数组 AA 中，大于等于 xx 的最小值是多大？<br><br>输入格式<br>第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。<br><br>接下来一行有 nn 个整数 a_ia <br>i<br>​<br> 。<br><br>接下来 mm 行，每行有<span class="hljs-number"> 11 </span>个整数 xx，表示蒜头君询问的整数。<br><br>输出格式<br>对于每次查询，如果可以找到，输出这个整数。<br><br>否则输出 -1。<br><br>数据范围<br>1≤n,m≤1e5 0≤x≤1e6<br><br>输出时每行末尾的多余空格，不影响答案正确性<br><br>样例输入复制<br>10 5<br>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 5 </span>5<span class="hljs-number"> 7 </span>8 9<br>0<br>1<br>4<br>9<br>10<br>样例输出复制<br>1<br>1<br>5<br>9<br>-1<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cin&gt;&gt;num[i];<br>    <span class="hljs-built_in">sort</span>(num,num+n);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> t;<br>        cin&gt;&gt;t;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(num[mid]&gt;=t)&#123;<br>                r=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num[l]&gt;=t)&#123;<br>            cout&lt;&lt;num[l]&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二分查找三"><a href="#二分查找三" class="headerlink" title="二分查找三"></a>二分查找三</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tap">蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问在数组 AA 中，比 xx 大的最小值是多大？但是这次蒜头君要求这个数字必须大于 xx，不能等于 xx。<br><br>输入格式<br>第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。<br><br>接下来一行有 nn 个整数 a_ia <br>i<br>​<br> 。<br><br>接下来 mm 行，每行有<span class="hljs-number"> 11 </span>个整数 xx，表示蒜头君询问的整数。<br><br>输出格式<br>对于每次查询，如果可以找到，输出这个整数。<br><br>否则输出 -1−1。<br><br>数据范围<br>1≤n,m≤1e5 0≤x≤1e6<br><br>输出时每行末尾的多余空格，不影响答案正确性<br><br>样例输入复制<br>10 5<br>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 5 </span>5<span class="hljs-number"> 7 </span>8 9<br>0<br>1<br>4<br>9<br>10<br>样例输出复制<br>1<br>2<br>5<br>-1<br>-1<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cin&gt;&gt;num[i];<br>    <br>    <span class="hljs-built_in">sort</span>(num,num+n);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> t;<br>        cin&gt;&gt;t;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(num[mid]&gt;t)&#123;<br>                r=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num[l]&gt;t)&#123;<br>            cout&lt;&lt;num[l]&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><h4 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><h4 id="宽度优先搜索（BFS）"><a href="#宽度优先搜索（BFS）" class="headerlink" title="宽度优先搜索（BFS）"></a>宽度优先搜索（BFS）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>;<br><span class="hljs-type">char</span> g[N][N];<br><span class="hljs-type">int</span> dis[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> T;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(PII start)</span></span>&#123;<br>    queue&lt;PII&gt; q;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> dis);<br>    dis[start.x][start.y]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        PII t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> a=t.x+dx[i],b=t.y+dy[i];<br>            <span class="hljs-keyword">if</span>(a&gt;=n||a&lt;<span class="hljs-number">0</span>||b&gt;=m||b&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(dis[a][b]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">if</span>(g[a][b]==<span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-keyword">return</span> dis[t.x][t.y]+<span class="hljs-number">1</span>;<br>            <br>            q.<span class="hljs-built_in">push</span>(&#123;a,b&#125;);<br>            dis[a][b]=dis[t.x][t.y]+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        cin&gt;&gt;n&gt;&gt;m;<br>        PII start;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                cin&gt;&gt;g[i][j];<br>                <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)&#123;<br>                    start=&#123;i,j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;start.x&lt;&lt;start.y&lt;&lt;endl;</span><br>        <span class="hljs-type">int</span> distence=<span class="hljs-built_in">bfs</span>(start);<br>        <span class="hljs-keyword">if</span>(distence==<span class="hljs-number">-1</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;oop!&quot;</span>&lt;&lt;endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;distence&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求最短路径"><a href="#求最短路径" class="headerlink" title="求最短路径"></a>求最短路径</h3><h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><h5 id="所有边权都是正数"><a href="#所有边权都是正数" class="headerlink" title="所有边权都是正数"></a>所有边权都是正数</h5><h6 id="朴素Dijkstra算法（稠密图）"><a href="#朴素Dijkstra算法（稠密图）" class="headerlink" title="朴素Dijkstra算法（稠密图）"></a>朴素Dijkstra算法（稠密图）</h6><p>​<img src="https://img-blog.csdnimg.cn/20210216163038477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY4MTU0OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))&#123;<br>                t=j;<br>            &#125;<br>        &#125;<br>        st[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <span class="hljs-type">int</span> t=<span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="堆优化Dijkstra算法（稀疏图）"><a href="#堆优化Dijkstra算法（稀疏图）" class="headerlink" title="堆优化Dijkstra算法（稀疏图）"></a>堆优化Dijkstra算法（稀疏图）</h6><h5 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h5><h6 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman-ford算法"></a>bellman-ford算法</h6><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tap">给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br><br>请你求出从<span class="hljs-number"> 1 </span>号点到 n 号点的最多经过 k 条边的最短距离，如果无法从<span class="hljs-number"> 1 </span>号点走到 n 号点，输出 impossible。<br><br>注意：图中可能 存在负权回路 。<br><br>输入格式<br>第一行包含三个整数 n,m,k。<br><br>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示从<span class="hljs-number"> 1 </span>号点到 n 号点的最多经过 k 条边的最短距离。<br><br>如果不存在满足条件的路径，则输出 impossible。<br><br>数据范围<br>1≤n,k≤500,<br>1≤m≤10000,<br>任意边长的绝对值不超过 10000。<br><br>输入样例：<br>3<span class="hljs-number"> 3 </span>1<br>1<span class="hljs-number"> 2 </span>1<br>2<span class="hljs-number"> 3 </span>1<br>1<span class="hljs-number"> 3 </span>3<br>输出样例：<br>3<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,M=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> dist[N],backup[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>&#125;edges[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-built_in">memcpy</span>(backup,dist,<span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            <span class="hljs-keyword">auto</span> e=edges[j];<br>            dist[e.b]=<span class="hljs-built_in">min</span>(dist[e.b],backup[e.a]+e.c);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        edges[i]=&#123;a,b,c&#125;;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h4><h6 id><a href="#" class="headerlink" title></a></h6><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><h4 id="试除法求质数"><a href="#试除法求质数" class="headerlink" title="试除法求质数"></a>试除法求质数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">1</span>、题目：<br>给定<span class="hljs-built_in">n</span>个正整数ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。<br><br>输入格式<br>第一行包含整数<span class="hljs-built_in">n</span>。<br><br>接下来<span class="hljs-built_in">n</span>行，每行包含一个正整数ai。<br><br>输出格式<br>对于每个正整数ai,按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。<br><br>每个正整数的质因数全部输出完毕后，输出一个空行。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100</span>,<br><span class="hljs-number">1</span>≤ai≤<span class="hljs-number">2</span>∗<span class="hljs-number">109</span><br>输入样例：<br><span class="hljs-number">2</span><br><span class="hljs-number">6</span><br><span class="hljs-number">8</span><br>输出样例：<br><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)&#123;<br>                x/=i;<br>                cnt++;<br>            &#125;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>)cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-built_in">divide</span>(x);<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个正整数 <span class="hljs-built_in">n</span>，请你求出 <span class="hljs-number">1</span>∼<span class="hljs-symbol">n1</span>∼<span class="hljs-built_in">n</span> 中质数的个数。<br><br>输入格式<br><br>共一行，包含整数 <span class="hljs-built_in">n</span>。<br><br>输出格式<br><br>共一行，包含一个整数，表示 <span class="hljs-number">1</span>∼<span class="hljs-symbol">n1</span>∼<span class="hljs-built_in">n</span> 中质数的个数。<br><br>数据范围<br><br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">1061</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">106</span><br><br>输入样例：<br></code></pre></td></tr></table></figure><h5 id="欧式筛法"><a href="#欧式筛法" class="headerlink" title="欧式筛法"></a>欧式筛法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> prime[N],cnt;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            prime[cnt++]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i;j&lt;=n;j+=i)&#123;<br>                st[j]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">get_prime</span>(n);<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">get_primes</span>(n);<br><br>    cout &lt;&lt; cnt &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;divs;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>            divs.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i*i!=n)divs.<span class="hljs-built_in">push_back</span>(n/i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(divs.<span class="hljs-built_in">begin</span>(),divs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s:divs)&#123;<br>        cout&lt;&lt;s&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">get_divisors</span>(n);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h4><p>利用算法基本定理，先分解质因数，然后约数个数就是每个质因数的指数+1的乘积。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">当然还有更简单的方法，考虑下我们小时候学过的分解质因数的知识。<br><span class="hljs-attribute">360</span>=2*2*2*3*3*5=2^3+3^2+5<br>那么360的约数只能为2^a<span class="hljs-number">*3</span>^b<span class="hljs-number">*5</span>^c2（a的范围(0-3),b的范围(0-2),c的范围(0-1)），因此360的约数有4<span class="hljs-number">*3</span><span class="hljs-number">*2</span>=24个。<br>具体实现方法：<br></code></pre></td></tr></table></figure><p>该题求解了100的阶乘的约数的个数。其中使用的哈希map也可以换成简单的map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unoredered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=<span class="hljs-number">100</span>;j++)&#123;<br>        <span class="hljs-type">int</span> n=j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                n/=i;<br>                mp[i]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)mp[n]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:mp)&#123;<br>        cout&lt;&lt;x.first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;x.second+<span class="hljs-number">1</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:mp)&#123;<br>        res*=(x.second+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求约数的和"><a href="#求约数的和" class="headerlink" title="求约数的和"></a>求约数的和</h4><p><img src="https://img-blog.csdnimg.cn/1ba4a2a166b5479eba2443902140c529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2OTA3NTQ3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>            &#123;<br>                x /= i;<br>                primes[i] ++ ;<br>            &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;<br>    &#125;<br><br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes)<br>    &#123;<br>        LL a = p.first, b = p.second;<br>        LL t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (b -- ) t = (t * a + <span class="hljs-number">1</span>) % mod;<br>        res = res * t % mod;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h4><p>辗转相除法又叫欧几里得法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣Hot100"><a href="#力扣Hot100" class="headerlink" title="力扣Hot100"></a>力扣Hot100</h1><h2 id="21-全排列-Medium"><a href="#21-全排列-Medium" class="headerlink" title="21.全排列 Medium"></a>21.全排列 Medium</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p>Related Topics</p><ul><li>数组</li><li>回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] isUsed;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        isUsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<span class="hljs-comment">//用于记录当前数字是否被用过</span><br>        backTracking(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!isUsed[i])&#123;<br>                isUsed[i] = <span class="hljs-literal">true</span>;<br>                path.add(nums[i]);<br>                backTracking(nums);<br>                path.removeLast();<br>                isUsed[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-旋转图像-Medium"><a href="#22-旋转图像-Medium" class="headerlink" title="22.旋转图像 Medium"></a>22.旋转图像 Medium</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>数学</li><li>矩阵</li></ul><p>解析：<a href="https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/">https://leetcode.cn/problems/rotate-image/solutions/1228078/48-xuan-zhuan-tu-xiang-fu-zhu-ju-zhen-yu-jobi/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n - <span class="hljs-number">1</span> - j][i];<br>                matrix[n - <span class="hljs-number">1</span> -j][i] = matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j];<br>                matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j] = matrix[j][n -<span class="hljs-number">1</span>-i];<br>                matrix[j][n-<span class="hljs-number">1</span>-i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-字母异位词分组-Medium"><a href="#23-字母异位词分组-Medium" class="headerlink" title="23.字母异位词分组 Medium"></a>23.字母异位词分组 Medium</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><p>Related Topics</p><ul><li>数组</li><li>哈希表</li><li>字符串</li><li>排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>            <span class="hljs-comment">//排序</span><br>            Arrays.sort(chars);<br>            <span class="hljs-comment">//将排序后得到的字符串作为map的key</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>            <span class="hljs-comment">//通过key查找出list，如果没有当前key对应的list，那就创建一个新的空list</span><br>            List&lt;String&gt; list = map.getOrDefault(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            <span class="hljs-comment">//list保存字符串</span><br>            list.add(str);<br>            <span class="hljs-comment">//map更新key对应的list</span><br>            map.put(key,list);<br>        &#125;<br>        <span class="hljs-comment">//根据key进行分组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-type">int</span>[] records = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-comment">//记录每个字母的数量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                records[str.charAt(i) -<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-comment">//只要得到的sb是相同的，那就说明是字母异位词</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; records.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (records[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    sb.append((<span class="hljs-type">char</span>) <span class="hljs-string">&#x27;a&#x27;</span>+i).append(records[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//得到的字符串作为map的key</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> sb.toString();<br>            <span class="hljs-comment">//通过key查找出list，如果没有当前key对应的list，那就创建一个新的空list</span><br>            List&lt;String&gt; list = map.getOrDefault(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            <span class="hljs-comment">//list保存字符串</span><br>            list.add(str);<br>            <span class="hljs-comment">//map更新key对应的list</span><br>            map.put(key,list);<br>        &#125;<br>        <span class="hljs-comment">//根据key进行分组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="24-最大子数组和-Medium"><a href="#24-最大子数组和-Medium" class="headerlink" title="24.最大子数组和 Medium"></a>24.最大子数组和 Medium</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><p>Related Topics</p><ul><li>数组</li><li>分治</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = Math.max(nums[i],dp[i-<span class="hljs-number">1</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>            max = Math.max(max,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            curSum = Math.max(nums[i],curSum+nums[i]);<br>            maxSum = Math.max(maxSum,curSum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-跳跃游戏-Medium"><a href="#25-跳跃游戏-Medium" class="headerlink" title="25.跳跃游戏 Medium"></a>25.跳跃游戏 Medium</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为<span class="hljs-number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="hljs-number"> 0 </span>， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p>Related Topics</p><ul><li>贪心</li><li>数组</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贪心算法：最大距离等于当前位置加上对应的nums[i]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDistance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; maxDistance) &#123;<span class="hljs-comment">//如果当前位置都比最大距离大了，那肯定无法到达</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            maxDistance = Math.max(maxDistance,i+nums[i]);<span class="hljs-comment">//更新最大距离</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-合并区间-Medium"><a href="#26-合并区间-Medium" class="headerlink" title="26.合并区间 Medium"></a>26.合并区间 Medium</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">//讨论特殊情况</span><br>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-comment">//对二维数组进行排序，根据二维数组中一维数组的第一个数字从小到大进行排序</span><br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//因为不知道有多少一维数组需要合并，所以最终得到的二维数组的长度也不知道，所以就创建一个list来存储一维数组</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//将排序后的第一个一维数组放进list，遍历剩下的一维数组</span><br>        list.add(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-comment">//当前数组的左值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">curArrLeft</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">//当前数组的右值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">curArrRight</span> <span class="hljs-operator">=</span> intervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//列表中的最后一个数组的左值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">listFinalArrLeft</span> <span class="hljs-operator">=</span> list.get(list.size() -<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">//列表中的最后一个数组的右值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">listFinalArrRight</span> <span class="hljs-operator">=</span> list.get(list.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (curArrLeft &lt;= listFinalArrRight) &#123;<span class="hljs-comment">//如果当前数组左值小于了列表中最后一个数组的右值，说明有重叠</span><br>                <span class="hljs-comment">//修改列表中的最后一个数组的右值</span><br>                list.get(list.size()-<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(curArrRight,listFinalArrRight);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//没有重合就将当前的一维数组放入列表中</span><br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;intervals[i][<span class="hljs-number">0</span>],intervals[i][<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="27-不同路径-Medium"><a href="#27-不同路径-Medium" class="headerlink" title="27.不同路径 Medium"></a>27.不同路径 Medium</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><p>Related Topics</p><ul><li>数学</li><li>动态规划</li><li>组合数学</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-comment">//第一行，每个格子都只有一种到达方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//列也是</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-comment">//递推公式</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="28-最小路径和"><a href="#28-最小路径和" class="headerlink" title="28.最小路径和"></a>28.最小路径和</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 200</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>动态规划</li><li>矩阵</li></ul><p>这题跟27题很类似，思路是差不多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; grid.length; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>]+dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">//行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j]+dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; grid.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>                dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[grid.length-<span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-爬楼梯-Easy"><a href="#29-爬楼梯-Easy" class="headerlink" title="29.爬楼梯 Easy"></a>29.爬楼梯 Easy</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><p>Related Topics</p><ul><li>记忆化搜索</li><li>数学</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//dp[i]表示爬到第i阶楼梯时有多少种方法</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">//递推公式</span><br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="30-编辑距离-Hard"><a href="#30-编辑距离-Hard" class="headerlink" title="30.编辑距离 Hard"></a>30.编辑距离 Hard</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 word1 转换成 word2 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><p>Related Topics</p><ul><li>字符串</li><li>动态规划</li></ul><p>解析：<a href="https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://www.programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br><span class="hljs-comment">//dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[word1.length() +<span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//这里可以理解为word2为空字符串，遍历到word的第i个自负，word2就需要增加i次才能变成跟word1一样</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++) &#123;、<br>                <span class="hljs-comment">//如果当前两个字符相等，那么最短编辑距离跟dp[i-1][j-1]相等</span><br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//删(增)：dp[i-1][j]+1，dp[i][j-1]+1.删或增最终的结果是一样的</span><br>                    <span class="hljs-comment">//改：dp[i-1][j-1]+1</span><br>                    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j]) + <span class="hljs-number">1</span>;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-颜色分类-Medium"><a href="#31-颜色分类-Medium" class="headerlink" title="31.颜色分类 Medium"></a>31.颜色分类 Medium</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,0,1]</span><br>输出：<span class="hljs-comment">[0,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><p>Related Topics</p><ul><li>数组</li><li>双指针</li><li>排序</li></ul><p>方法一：逐一覆盖，用idea模拟一遍就清楚思路了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">zeroIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oneIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentNum</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (currentNum &lt; <span class="hljs-number">2</span>) &#123;<br>                nums[oneIndex++] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentNum &lt; <span class="hljs-number">1</span>) &#123;<br>                nums[zeroIndex++] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：替换，思路是遇到0就跟左边界的元素替换，遇到2就跟右边界的元素替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//当前指向元素的索引</span><br>        <span class="hljs-keyword">while</span> (current &lt;= right)&#123;<span class="hljs-comment">//终止条件是当前索引&gt;右边界</span><br>            <span class="hljs-keyword">if</span> (nums[current] == <span class="hljs-number">0</span>) &#123;<br>                swap(nums,current,left);<br>                left++;<br>                current++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[current] == <span class="hljs-number">2</span>) &#123;<br>                swap(nums,current,right);<br>                right--;<br>                <span class="hljs-comment">//在这里不需要current++，因为替换之后的元素还得再继续比较</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                current++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-最小覆盖子串-Hard"><a href="#32-最小覆盖子串-Hard" class="headerlink" title="32.最小覆盖子串 Hard"></a>32.最小覆盖子串 Hard</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br>解释：最小覆盖子串 <span class="hljs-string">&quot;BANC&quot;</span> 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br>解释：整个字符串 s 是最小覆盖子串。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> s = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;aa&quot;</span><br>输出<span class="hljs-symbol">:</span> <span class="hljs-string">&quot;&quot;</span><br>解释<span class="hljs-symbol">:</span> <span class="hljs-built_in">t</span> 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p>进阶：</p><p>你能设计一个在 o(m+n)时间内解决此问题的算法吗？</p><p>Related Topics</p><ul><li>哈希表</li><li>字符串</li><li>滑动窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">//arr用于记录字符串中的字符需要的个数，用ASCII玛作为索引</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            arr[t.charAt(i)]++;<br>        &#125;<br>        <span class="hljs-comment">//滑动窗口左右边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br> <span class="hljs-comment">//size表示窗口的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-comment">//start用于记录窗口的起始位置，这里不用left记录，因为left可能随时更新</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//count表示在遍历s的时候，还需要多少个t中要求的字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>            <span class="hljs-comment">//如果当前字符的ASCII玛能够在arr中能找到，那就让count-1</span><br>            <span class="hljs-keyword">if</span> (arr[c] &gt; <span class="hljs-number">0</span>) &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-comment">//无论当前字符是否在t中，我们都让这个字符的ASCII玛在arr中对应的元素-1，哪怕是负数，负数可以认为是这个字符是多余的，后面就可以通过更新left来去除</span><br>            arr[c]--;<br>            <span class="hljs-comment">//count等于0说明t的所有字符都包含在了滑动窗口中</span><br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//缩小滑动窗口</span><br>                <span class="hljs-comment">//如果左边界的ASCII玛在arr中对应的值是小于0的，说明这个字符多余，让左边界右移</span><br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[s.charAt(left)] &lt; <span class="hljs-number">0</span>) &#123;<br>                    arr[s.charAt(left)]++;<br>                    left++;<br>                &#125;<br>                <span class="hljs-comment">//如果这次所求的滑动窗口的大小比上一次满足条件的滑动窗口的大小更小，就更新窗口大小，并更新start的值</span><br>                <span class="hljs-keyword">if</span> ((right - left + <span class="hljs-number">1</span>) &lt; size) &#123;<br>                    size = right - left + <span class="hljs-number">1</span>;<br>                    start = left;<br>                &#125;<br>                <span class="hljs-comment">//因为count等于0了，那我们就尝试让左边界右移，缩小窗口</span><br>                arr[s.charAt(left)]++;<br>                left++;<br>                <span class="hljs-comment">//count也需要加1，因为当前left对应的字符正式t中需要的</span><br>                count++;<br>            &#125;<br>            <span class="hljs-comment">//右边界右移</span><br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start,start+size);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-子集-Medium"><a href="#33-子集-Medium" class="headerlink" title="33.子集 Medium"></a>33.子集 Medium</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><p>Related Topics</p><ul><li>位运算</li><li>数组</li><li>回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dfs(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> index)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; nums.length; i++) &#123;<br>            path.add(nums[i]);<br>            dfs(nums,i+<span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="34-单词搜索-Medium"><a href="#34-单词搜索-Medium" class="headerlink" title="34.单词搜索 Medium"></a>34.单词搜索 Medium</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;SEE&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCB&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p><p>Related Topics</p><ul><li>数组</li><li>回溯</li><li>矩阵</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//将board的长宽作为全局变量</span><br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = board.length;<br>        <span class="hljs-built_in">this</span>.n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (backTracking(board,i,j,chars,<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">char</span>[] chars,<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">//如果index跟chars长度相等，说明找到了单词</span><br>        <span class="hljs-keyword">if</span> (index == chars.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断越界</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;=m || j &gt;= n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><span class="hljs-comment">//如果当前遍历的字符跟word中要求的不一样，false</span><br>        <span class="hljs-keyword">if</span> (board[i][j] != chars[index]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><span class="hljs-comment">//用临时变量记录board[i][j]，然后修改为别的字符，这样就算再返回来遍历这个字符，也不会被重复使用</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> board[i][j];<br>        board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;<br><span class="hljs-comment">//递归相邻的字符</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span>backTracking(board,i-<span class="hljs-number">1</span>,j,chars,index+<span class="hljs-number">1</span>)<br>                || backTracking(board,i,j-<span class="hljs-number">1</span>,chars,index+<span class="hljs-number">1</span>)<br>                || backTracking(board,i+<span class="hljs-number">1</span>,j,chars,index+<span class="hljs-number">1</span>)<br>                || backTracking(board,i,j+<span class="hljs-number">1</span>,chars,index+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//记得恢复原来的字符</span><br>        board[i][j] = temp;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35-柱状图中最大的矩形-Hard"><a href="#35-柱状图中最大的矩形-Hard" class="headerlink" title="35.柱状图中最大的矩形 Hard"></a>35.柱状图中最大的矩形 Hard</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入： heights </span>=<span class="hljs-string"> [2,4]</span><br><span class="hljs-string">输出： 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><p>Related Topics</p><ul><li>栈</li><li>数组</li><li>单调栈</li></ul><p>文字解析：<a href="https://www.programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p><p>视频解析：<a href="https://www.bilibili.com/video/BV1Ns4y1o7uB/?vd_source=92cb5cb9faa01574e9b1f82bf91d080d">https://www.bilibili.com/video/BV1Ns4y1o7uB/?vd_source=92cb5cb9faa01574e9b1f82bf91d080d</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里就不写注解了，不太好描述思路，思路详见文字解析或视频解析</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] newHeights= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length + <span class="hljs-number">2</span>];<br>        newHeights[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        newHeights[newHeights.length-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>            newHeights[i+<span class="hljs-number">1</span>] = heights[i];<br>        &#125;<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ;i &lt; newHeights.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (newHeights[i] &gt; newHeights[stack.peek()]) &#123;<br>                stack.push(i);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newHeights[i] == newHeights[stack.peek()]) &#123;<br>                stack.pop();<br>                stack.push(i);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (newHeights[i] &lt; newHeights[stack.peek()]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peek();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right - left -<span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> newHeights[mid];<br>                    maxArea = Math.max(maxArea,width * height);<br>                &#125;<br>                stack.push(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>精简版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] newHeights= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[heights.length + <span class="hljs-number">2</span>];<br>        newHeights[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        newHeights[newHeights.length-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>            newHeights[i+<span class="hljs-number">1</span>] = heights[i];<br>        &#125;<br><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; newHeights.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; newHeights[i] &lt; newHeights[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peek();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right - left -<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> newHeights[mid];<br>                maxArea = Math.max(maxArea,width * height);<br>            &#125;<br>            stack.push(i);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="36-最大矩形-Hard"><a href="#36-最大矩形-Hard" class="headerlink" title="36.最大矩形 Hard"></a>36.最大矩形 Hard</h2><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：matrix <span class="hljs-operator">=</span> []<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;1&quot;]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;,&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>1 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><p>Related Topics</p><ul><li>栈</li><li>数组</li><li>动态规划</li><li>矩阵</li><li>单调栈</li></ul><p>文字解析：<a href="https://leetcode.cn/problems/maximal-rectangle/solutions/1774721/by-burling-lucky-gqg0/">https://leetcode.cn/problems/maximal-rectangle/solutions/1774721/by-burling-lucky-gqg0/</a></p><p>这道题跟上面那一题挺像的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        List&lt;<span class="hljs-type">int</span>[]&gt; allRowsHeights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-type">int</span>[] height = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-keyword">while</span> (k &gt;= <span class="hljs-number">0</span> &amp;&amp; matrix[k][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    height[j+<span class="hljs-number">1</span>]++;<br>                    k--;<br>                &#125;<br>            &#125;<br>            allRowsHeights.add(height);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] heights:allRowsHeights) &#123;<br>            Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt; heights[i]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> heights[cur] * (i - stack.peek() - <span class="hljs-number">1</span>);<br>                    maxArea = Math.max(maxArea, val);<br>                &#125;<br>                stack.push(i);<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="37-二叉树的中序遍历-Easy"><a href="#37-二叉树的中序遍历-Easy" class="headerlink" title="37.二叉树的中序遍历 Easy"></a>37.二叉树的中序遍历 Easy</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 *<em>中序</em></em> 遍历* 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>Related Topics</p><ul><li>栈</li><li>树</li><li>深度优先搜索</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        inorderTraversal(root.left);<br>        res.add(root.val);<br>        inorderTraversal(root.right);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="38-不同的二叉搜索树-Medium"><a href="#38-不同的二叉搜索树-Medium" class="headerlink" title="38.不同的二叉搜索树 Medium"></a>38.不同的二叉搜索树 Medium</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><p>Related Topics</p><ul><li>树</li><li>二叉搜索树</li><li>数学</li><li>动态规划</li><li>二叉树</li></ul><p>解析：<a href="https://www.programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html">https://www.programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i] += dp[j-<span class="hljs-number">1</span>]*dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="39-验证二叉搜索树-Medium"><a href="#39-验证二叉搜索树-Medium" class="headerlink" title="39.验证二叉搜索树 Medium"></a>39.验证二叉搜索树 Medium</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>二叉搜索树</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//思路：二叉搜索树的中序遍历是有序的，所以只要按中序遍历记录每个节点的值，然后判断是不是有序即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root,list);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) &lt;= list.get(i-<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        dfs(root.left,list);<br>        list.add(root.val);<br>        dfs(root.right,list);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>思路2：在遍历的时候就进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//记录上一个节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//空节点也是二叉搜索树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left); <span class="hljs-comment">//左边是不是二叉搜索树</span><br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<span class="hljs-comment">//右边是不是二叉搜索树</span><br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="40-对称二叉树-Easy"><a href="#40-对称二叉树-Easy" class="headerlink" title="40.对称二叉树 Easy"></a>40.对称二叉树 Easy</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>广度优先搜索</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> compare(root.left,root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (left.val != right.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> compare(left.left,right.right) &amp;&amp; compare(left.right,right.left);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.offerFirst(root.left);<br>        deque.offerLast(root.right);<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> deque.pollLast();<br>            <span class="hljs-keyword">if</span> (leftNode == <span class="hljs-literal">null</span> &amp;&amp; rightNode == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (leftNode != <span class="hljs-literal">null</span> &amp;&amp; rightNode == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (leftNode == <span class="hljs-literal">null</span> &amp;&amp; rightNode != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (leftNode.val != rightNode.val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            deque.offerFirst(leftNode.left);<br>            deque.offerLast(rightNode.right);<br>            deque.offerFirst(leftNode.right);<br>            deque.offerLast(rightNode.left);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣Hot100"><a href="#力扣Hot100" class="headerlink" title="力扣Hot100"></a>力扣Hot100</h1><h2 id="1-两数之和-Easy"><a href="#1-两数之和-Easy" class="headerlink" title="1.两数之和 Easy"></a>1.两数之和 Easy</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">//讨论特殊情况</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">//使用一个Map来记录数组的值和索引值</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//定义一个临时变量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> target  - nums[i];<br>            <span class="hljs-comment">//更新res数组</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(temp))&#123;<br>                res[<span class="hljs-number">0</span>] = i;<br>                res[<span class="hljs-number">1</span>] = map.get(temp);<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//结束循环</span><br>            &#125;<br>            map.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加-Medium"><a href="#2-两数相加-Medium" class="headerlink" title="2.两数相加 Medium"></a>2.两数相加 Medium</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><p>Related Topics</p><ul><li>递归</li><li>链表</li><li>数学</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">//辅助的哑节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//辅助遍历的节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-comment">//carry表示十位，要么是1要么是0，这里的十位是指两个指针指向的两个数相加后的十位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//获取节点值，如果节点为空，就是0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y +carry;<br>            <span class="hljs-comment">//计算十位</span><br>            carry = sum / <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//计算个位</span><br>            sum = sum % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//添加节点</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            <span class="hljs-comment">//节点往后移</span><br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>)&#123;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>)&#123;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果到最后十位还是1的话，得补一个节点</span><br>        <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>)&#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串-Medium"><a href="#3-无重复字符的最长子串-Medium" class="headerlink" title="3.无重复字符的最长子串 Medium"></a>3.无重复字符的最长子串 Medium</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p>Related Topics</p><ul><li><p>哈希表</p></li><li><p>字符串</p></li><li><p>滑动窗口</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//特殊情况，字符串长度为0</span><br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//使用map记录当前滑动窗口是否存在当前遍历到的字符</span><br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//转为数组</span><br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//滑动窗口左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//右边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; chars.length)&#123;<br>            <span class="hljs-comment">//不包含当前字符，我们就记录一下，右边界右移</span><br>            <span class="hljs-keyword">if</span> (!map.containsKey(chars[right]) )&#123;<br>                map.put(chars[right],<span class="hljs-number">1</span>);<br>                right++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//说明包含了，map先删除这个字符</span><br>                <span class="hljs-comment">//左边界右移</span><br>                map.remove(chars[left]);<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//记录滑动窗口的最大值</span><br>            <span class="hljs-comment">//因为前面right已经++了，所以这里right-left不用+1</span><br>            res = Math.max(res,right-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对上一个方法进行优化，上一个方法里是left的更新比较慢，因为一旦遇到重复之后就需要更新left到重复字符的下一个位置，所以在这里对这个细节进行优化</span><br><span class="hljs-comment">//举个例子，假设字符串是 &quot;abcba&quot;：当遍历到第二个 &quot;b&quot; 时，发现它在位置 3 和位置 1 都出现过，此时需要更新 start 的值。通过 map.get(c) 可以得到最近一次 &quot;b&quot; 出现的位置为 1，那么通过 Math.max(map.get(c), start) 就可以得到新的 start 值为 1+1 = 2，即重复字符的下一个位置。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//end右边界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt; s.length();end++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span> (map.containsKey(c))&#123;<br>                <span class="hljs-comment">//左边界直接跳到右边界</span><br>                start = Math.max(map.get(c),start);<br>            &#125;<br>            res = Math.max(res,end-start+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//end+1是表示记录当前字符索引的下一位，这样就能直接跳到重复字符的下一位了</span><br>            map.put(s.charAt(end),end+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数-Hard"><a href="#4-寻找两个正序数组的中位数-Hard" class="headerlink" title="4.寻找两个正序数组的中位数 Hard"></a>4.寻找两个正序数组的中位数 Hard</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>二分查找</li><li>分治</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//合并数组，但只要合并到中间位置就可以了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> m + n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[l];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n &amp;&amp; i + j &lt;= l / <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span> (nums1[i] &lt;= nums2[j])&#123;<br>                res[index++] = nums1[i++];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                res[index++] = nums2[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//有可能只是一个数组元素很少，遍历完了，但是还没遍历到合并数组的中间位置</span><br>        <span class="hljs-keyword">while</span> (i == m &amp;&amp; i + j &lt;= l /<span class="hljs-number">2</span>)&#123;<br>            res[index++] = nums2[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j == n &amp;&amp; i + j &lt;= l /<span class="hljs-number">2</span>)&#123;<br>            res[index++] = nums1[i++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> (res[l/<span class="hljs-number">2</span>] + res[l/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> res[l/<span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串-Medium"><a href="#5-最长回文子串-Medium" class="headerlink" title="5.最长回文子串 Medium"></a>5.最长回文子串 Medium</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><p>Related Topics</p><ul><li>字符串</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">//特殊情况:如果字符串长度只有1，那一定是回文子串</span><br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-comment">//dp表示在s[i...j]范围内是否是回文子串</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <span class="hljs-comment">//初始化：根据dp的含义，而且我们知道单个字符肯定是回文子串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//记录回文子串的起始位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//记录回文子串的最大长度</span><br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-comment">//用动态规划dp[i][j]是否为true，是取决于dp[i+1][j-1]的</span><br>        <span class="hljs-comment">//所以这里我们先遍历列，再遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-comment">//两个字符不同，那肯定不是回文</span><br>                <span class="hljs-keyword">if</span> (chars[i] != chars[j])&#123;<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//dp[i][j]是否为true，是取决于dp[i+1][j-1]的</span><br>                    <span class="hljs-comment">//判断一下边界条件，(j-1)-(i+1)+1 &gt;= 2 才能用状态转移方程</span><br>                    <span class="hljs-comment">//不然的话，如果长度小于2,要么为1要么为0，再加上当前i和j的字符是相同的</span><br>                    <span class="hljs-comment">//那么dp[j][j]肯定是true了</span><br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>)&#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//如果当前是回文子串，并且长度也是大于maxLen</span><br>                <span class="hljs-comment">//那么就更新begin 和 maxLen</span><br>                <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen)&#123;<br>                    maxLen = j - i + <span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s.substring(begin,begin+maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-正则表达式匹配-Hard"><a href="#6-正则表达式匹配-Hard" class="headerlink" title="6.正则表达式匹配 Hard"></a>6.正则表达式匹配 Hard</h2><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><ul><li><code>&#39;.&#39;</code> 匹配任意单个字符</li><li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 20</code></li><li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><p>Related Topics</p><ul><li>递归</li><li>字符串</li><li>动态规划</li></ul><p>动态规划：<a href="https://www.bilibili.com/video/BV1jd4y1U7kE/?spm_id_from=333.337.search-card.all.click&vd_source=92cb5cb9faa01574e9b1f82bf91d080d">https://www.bilibili.com/video/BV1jd4y1U7kE/?spm_id_from=333.337.search-card.all.click&amp;vd_source=92cb5cb9faa01574e9b1f82bf91d080d</a></p><p><a href="https://www.iamshuaidi.com/2032.html">https://www.iamshuaidi.com/2032.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || p == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m ; j++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;.&#x27;</span>||p.charAt(j-<span class="hljs-number">1</span>)==s.charAt(i-<span class="hljs-number">1</span>))<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">1</span>&amp;&amp;p.charAt(j-<span class="hljs-number">2</span>)!=<span class="hljs-string">&#x27;.&#x27;</span>&amp;&amp;p.charAt(j-<span class="hljs-number">2</span>)!=s.charAt(i-<span class="hljs-number">1</span>))&#123;<br>                        dp[i][j] = dp[i][j-<span class="hljs-number">2</span>];<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] || dp[i][j-<span class="hljs-number">1</span>]||dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-盛最多水的容器-Medium"><a href="#7-盛最多水的容器-Medium" class="headerlink" title="7.盛最多水的容器 Medium"></a>7.盛最多水的容器 Medium</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><p>Related Topics</p><ul><li>贪心</li><li>数组</li><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">//考虑特殊情况</span><br>        <span class="hljs-keyword">if</span> (height.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//返回的结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>            <span class="hljs-comment">//h是高</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> Math.min(height[left],height[right]);<br>            <span class="hljs-comment">//计算面积</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> h * (right - left);<br>            <span class="hljs-comment">//更新res</span><br>            res = Math.max(res,area);<br>            <span class="hljs-comment">//如果左指针对应的高度比h低的话，指针右移</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; height[left] &lt;= h)&#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//如果右指针对应的高度比h低的话，指针左移</span><br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; height[right] &lt;= h)&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-三数之和-Medium"><a href="#8-三数之和-Medium" class="headerlink" title="8.三数之和 Medium"></a>8.三数之和 Medium</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>双指针</li><li>排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//排序，从小到大</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//数组长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//遍历第一个数，只需要到n-2，n-1是第三个数在遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">//跳过重复数字</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//优化细节1：如果前三个数加起来都大于0了，那么就不可能存在三个数加起来能等于0</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-comment">//优化细节1，如果最小的和最大的两个加起来小于0的话，那就没必要去遍历第二个数和第三个数了，因为这两个数比最大的两个数小</span><br>            <span class="hljs-comment">//直接进入下一循环</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[n-<span class="hljs-number">2</span>] + nums[n-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="hljs-number">0</span>)&#123;<br>                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));<br>                    <span class="hljs-comment">//去重第二个数字</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>])&#123;<br>                        right--;<br>                    &#125;<br>                    <span class="hljs-comment">//去重第三个数</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>])&#123;<br>                        left++;<br>                    &#125;<br>                    <span class="hljs-comment">//移动指针</span><br>                    left++;<br>                    right--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>)&#123;<br>                    left++;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-电话号码的字母组合-Medium"><a href="#9-电话号码的字母组合-Medium" class="headerlink" title="9.电话号码的字母组合 Medium"></a>9.电话号码的字母组合 Medium</h2><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：digits <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：<span class="hljs-keyword">digits</span> = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><p>Related Topics</p><ul><li>哈希表</li><li>字符串</li><li>回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    String[] numsStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;abc&quot;</span>,<br>            <span class="hljs-string">&quot;def&quot;</span>,<br>            <span class="hljs-string">&quot;ghi&quot;</span>,<br>            <span class="hljs-string">&quot;jkl&quot;</span>,<br>            <span class="hljs-string">&quot;mno&quot;</span>,<br>            <span class="hljs-string">&quot;pqrs&quot;</span>,<br>            <span class="hljs-string">&quot;tuv&quot;</span>,<br>            <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        dfs(digits,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-comment">//已经递归到这个数字对应的最后一个字母了，那就记录</span><br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            res.add(sb.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//获取这个数字对应的字母字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">numChar</span> <span class="hljs-operator">=</span> numsStr[digits.charAt(index)-<span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-comment">//遍历字母字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numChar.length(); i++) &#123;<br>            <span class="hljs-comment">//记录该字母</span><br>            sb.append(numChar.charAt(i));<br>            <span class="hljs-comment">//递归</span><br>            dfs(digits,index+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//回溯</span><br>            sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//回溯的另一种写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] MAPPING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;abc&quot;</span>,<br>            <span class="hljs-string">&quot;def&quot;</span>,<br>            <span class="hljs-string">&quot;ghi&quot;</span>,<br>            <span class="hljs-string">&quot;jkl&quot;</span>,<br>            <span class="hljs-string">&quot;mno&quot;</span>,<br>            <span class="hljs-string">&quot;qprs&quot;</span>,<br>            <span class="hljs-string">&quot;tuv&quot;</span>,<br>            <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br><br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[] path, digits;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> digits.length();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">this</span>.digits = digits.toCharArray();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span> (i == digits.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//比如这里的是digits是[2,3]</span><br>        <span class="hljs-comment">//那么MAPPING[2]对应的就是&quot;abc&quot;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : MAPPING[digits[i] -<span class="hljs-string">&#x27;0&#x27;</span>].toCharArray())&#123;<br>            <span class="hljs-comment">//这里path中的元素虽然没有被删掉，但在下一层循环中会被覆盖</span><br>            path[i] = c;<br>            dfs(i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-删除链表倒数第N个节点-Medium"><a href="#10-删除链表倒数第N个节点-Medium" class="headerlink" title="10.删除链表倒数第N个节点 Medium"></a>10.删除链表倒数第N个节点 Medium</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p>Related Topics</p><ul><li>链表</li><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//哑结点的好处在于可以不用讨论头结点被删除的情况</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>,head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-comment">//获取链表长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> getLength(head);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> len - n ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == k)&#123;<br>                temp.next = temp.next.next;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>)&#123;<br>            len++;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span>dummy;<br>        <span class="hljs-comment">//让right指针先走n步</span><br>        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>)&#123;<br>            right = right.next;<br>        &#125;<br>        <span class="hljs-comment">//然后left和right一起走，直到right到最后一个节点，这个时候left所指向的就是待删除节点的前一个节点</span><br>        <span class="hljs-keyword">while</span> (right.next != <span class="hljs-literal">null</span>)&#123;<br>            left = left.next;<br>            right = right.next;<br>        &#125;<br>        left.next = left.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-有效的括号-Easy"><a href="#11-有效的括号-Easy" class="headerlink" title="11.有效的括号 Easy"></a>11.有效的括号 Easy</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><p>Related Topics</p><ul><li>栈</li><li>字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> chars[i];<br>            <span class="hljs-comment">//遇到左括号，就把右括号放入队列中</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                deque.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deque.isEmpty() || deque.peek() != c)&#123;<br>                <span class="hljs-comment">//因为当前已经遍历到字符并且这个字符不是左括号，但是队列已经为空了，说明右括号多了</span><br>                <span class="hljs-comment">//如果头元素和当前字符不一样，要么是左括号多了，要么就是左右括号不能匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果遇到队列头元素和当前字符相同，就把头元素删掉</span><br>                deque.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-合并两个有序列表-Easy"><a href="#12-合并两个有序列表-Easy" class="headerlink" title="12.合并两个有序列表 Easy"></a>12.合并两个有序列表 Easy</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>Related Topics</p><ul><li>递归</li><li>链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最简单的办法是新造一个链表，遍历这两个链表，比较两个节点的大小，用小节点的值创建新的节点，连接在新链表之后</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list1.val);<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(list2.val);<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = list1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list2 != <span class="hljs-literal">null</span>)&#123;<br>            cur.next = list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法二，使用原来链表的节点去造新链表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span>) &#123;<br>            cur.next = list1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list2 != <span class="hljs-literal">null</span>)&#123;<br>            cur.next = list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next,list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list1,list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-括号生成-Medium"><a href="#13-括号生成-Medium" class="headerlink" title="13.括号生成 Medium"></a>13.括号生成 Medium</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p>Related Topics</p><ul><li>字符串</li><li>动态规划</li><li>回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-type">List</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 保存结果的集合</span><br><span class="hljs-type">char</span>[] path; <span class="hljs-comment">// 保存括号组合的数组</span><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 括号对数</span><br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span> * n]; <span class="hljs-comment">// 初始化括号组合数组的长度</span><br>    <span class="hljs-built_in">this</span>.n = n; <span class="hljs-comment">// 保存括号对数</span><br>    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">// 开始深度优先搜索，以0作为起始位置，初始括号数为0</span><br>    <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 返回结果集合</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> open)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span> *n)&#123; <span class="hljs-comment">// 当组合的括号对数达到2n时，即所有位置都填满了括号</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path)); <span class="hljs-comment">// 将当前的括号组合转化为字符串，并添加进结果集合</span><br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 结束当前的深度优先搜索</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (open &lt; n) &#123; <span class="hljs-comment">// 如果当前开放的左括号数小于n</span><br>        path[i] = <span class="hljs-string">&#x27;(&#x27;</span>; <span class="hljs-comment">// 在当前位置添加一个左括号</span><br>        dfs(i+<span class="hljs-number">1</span>,open+<span class="hljs-number">1</span>); <span class="hljs-comment">// 继续下一个位置的搜索，并更新左括号数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (i - open &lt; open) &#123; <span class="hljs-comment">// 如果当前位置之前的右括号数小于左括号数</span><br>        path[i] = <span class="hljs-string">&#x27;)&#x27;</span>; <span class="hljs-comment">// 在当前位置添加一个右括号</span><br>        dfs(i+<span class="hljs-number">1</span>,open); <span class="hljs-comment">// 继续下一个位置的搜索，并保持左括号数不变</span><br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-合并K个升序链表-Hard"><a href="#14-合并K个升序链表-Hard" class="headerlink" title="14.合并K个升序链表 Hard"></a>14.合并K个升序链表 Hard</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p>Related Topics</p><ul><li>链表</li><li>分治</li><li>堆（优先队列）</li><li>归并排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">//优先队列，默认情况下，最小的数排在队列头部</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (ListNode listNode : lists) &#123;<span class="hljs-comment">//将所有节点值塞进优先队列中，这样就得到了从小到大的排序</span><br>            <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(listNode.val);<br>                listNode = listNode.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<span class="hljs-comment">//通过遍历队列，创建节点</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(queue.poll());<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> mergeKListNodes(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 合并 lists 数组中区间 [i, j] 的链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKListNodes</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == j) &#123;<br>            <span class="hljs-keyword">return</span> lists[i]; <span class="hljs-comment">// 当 i 和 j 相等时，直接返回该链表</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> i + (j - i) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> mergeKListNodes(lists, i, mid); <span class="hljs-comment">// 递归合并左侧区间 [i, mid]</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> mergeKListNodes(lists, mid + <span class="hljs-number">1</span>, j); <span class="hljs-comment">// 递归合并右侧区间 [mid + 1, j]</span><br>        <span class="hljs-keyword">return</span> mergeTwoListNode(left, right); <span class="hljs-comment">// 合并左右两个链表</span><br>    &#125;<br><br>    <span class="hljs-comment">// 合并两个有序链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoListNode</span><span class="hljs-params">(ListNode listNode1, ListNode listNode2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (listNode1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> listNode2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (listNode2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> listNode1;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (listNode1 != <span class="hljs-literal">null</span> &amp;&amp; listNode2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (listNode1.val &lt;= listNode2.val) &#123;<br>                cur.next = listNode1; <span class="hljs-comment">// 将当前节点连接到合并后的链表中</span><br>                listNode1 = listNode1.next; <span class="hljs-comment">// 移动 listNode1 的指针</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = listNode2; <span class="hljs-comment">// 将当前节点连接到合并后的链表中</span><br>                listNode2 = listNode2.next; <span class="hljs-comment">// 移动 listNode2 的指针</span><br>            &#125;<br>            cur = cur.next; <span class="hljs-comment">// 移动合并后的链表指针</span><br>        &#125;<br>        cur.next = listNode1 == <span class="hljs-literal">null</span> ? listNode2 : listNode1; <span class="hljs-comment">// 将剩余的节点连接到合并后的链表中</span><br>        <span class="hljs-keyword">return</span> dummy.next; <span class="hljs-comment">// 返回合并后的链表</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-下一个排列-Medium"><a href="#15-下一个排列-Medium" class="headerlink" title="15.下一个排列 Medium"></a>15.下一个排列 Medium</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须 <strong>原地</strong> 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,5]</span><br>输出：<span class="hljs-comment">[1,5,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">2</span>; <span class="hljs-comment">// 从倒数第二个元素开始向左遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; <span class="hljs-comment">// 从倒数第一个元素开始向左比较</span><br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遍历数组中的每一个元素</span><br>        <span class="hljs-keyword">if</span> (nums[left] &lt; nums[right]) &#123; <span class="hljs-comment">// 找到两个相邻元素，并且左边的比右边的小</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; i &gt;= right; i--) &#123; <span class="hljs-comment">// 从右向左找到第一个大于较小元素的元素</span><br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[left]) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>                    nums[i] = nums[left];<br>                    nums[left] = temp;<br>                    Arrays.sort(nums, right, len); <span class="hljs-comment">// 对较小元素右侧的元素进行排序</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 执行了上面的代码就可以结束遍历了</span><br>        &#125;<br>        left--;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果遍历到left&lt;0,说明就找不到下一个排列，那就直接从小到大排序</span><br>        Arrays.sort(nums);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//寻找相邻的两个数，并且左边的数小于右边的数</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//只要有一个条件不满足，就停止循环</span><br>            i--;<br>        &#125;<br>        <span class="hljs-comment">//只有i大于等于0，才说明找到了那两个相邻的数</span><br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//j从后往前遍历，找第一个比nums[i]大的数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//交换这两个数</span><br>            swap(nums,i,j);<br>        &#125;<br>        <span class="hljs-comment">//将i往后的数进行从小到大排序</span><br>        reverse(nums,i+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums,left,right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-最长有效括号-Hard"><a href="#16-最长有效括号-Hard" class="headerlink" title="16.最长有效括号 Hard"></a>16.最长有效括号 Hard</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul><p>Related Topics</p><ul><li>栈</li><li>字符串</li><li>动态规划</li></ul><p>官方题解：<a href="https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/">https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">借助一个栈（Deque）来解决有效括号子串的问题。当遇到左括号时，将其下标入栈；当遇到右括号时，弹出栈顶元素表示匹配成功。对于有效的括号子串，栈中存储的是括号的下标，而不是括号本身</span><br><span class="hljs-comment">如果我们不事先将 -1 放入栈中，那么当字符串 s 的第一个字符是右括号时，栈将为空，导致后续计算有效括号子串长度时出现问题。通过事先放入 -1，我们可以确保栈中始终有一个元素，从而使得后续计算有效括号子串长度的操作能够正确进行。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 使用栈来存储括号的下标</span><br>        deque.push(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 在栈中事先放入-1，以处理特殊情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 遇到左括号，将其下标入栈</span><br>                deque.push(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 遇到右括号</span><br>                deque.pop(); <span class="hljs-comment">// 弹出栈顶元素，表示匹配成功</span><br>                <span class="hljs-keyword">if</span> (deque.isEmpty()) &#123; <span class="hljs-comment">// 栈为空，当前右括号没有匹配的左括号与之对应</span><br>                    deque.push(i); <span class="hljs-comment">// 将当前右括号的下标入栈，以便计算后续的有效括号子串长度</span><br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 栈非空，计算当前有效括号子串的长度</span><br>                    maxLen = Math.max(maxLen, i - deque.peek());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-搜索旋转排序数组-Medium"><a href="#17-搜索旋转排序数组-Medium" class="headerlink" title="17.搜索旋转排序数组 Medium"></a>17.搜索旋转排序数组 Medium</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>二分查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<span class="hljs-comment">//右半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<span class="hljs-comment">//目标值是否在右半部分</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//左半部分有序</span><br>                <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<span class="hljs-comment">//目标值是否在左半部分</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-在排序数组中查找元素的第一个和最后一个位置-Medium"><a href="#18-在排序数组中查找元素的第一个和最后一个位置-Medium" class="headerlink" title="18.在排序数组中查找元素的第一个和最后一个位置 Medium"></a>18.在排序数组中查找元素的第一个和最后一个位置 Medium</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>二分查找</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//得到的边界是开区间的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftBorder</span> <span class="hljs-operator">=</span> findLeftBorder(nums,target);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightBorder</span> <span class="hljs-operator">=</span> findRightBorder(nums,target);<br>        <span class="hljs-comment">//情况一：target小于数组的最小值或大于最大值，那么leftBorder和rightBorder就不会被更新</span><br>        <span class="hljs-keyword">if</span> (leftBorder == -<span class="hljs-number">2</span> || rightBorder == -<span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-comment">//情况二：target在数组中</span><br>        <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;leftBorder+<span class="hljs-number">1</span>,rightBorder-<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-comment">//情况三：target介于数组最小值和最大值之间，但不存在于数组中</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 寻找左边界</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLeftBorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftBorder</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) /<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                right = mid -<span class="hljs-number">1</span>;<br>                leftBorder = right;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> leftBorder;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 寻找右边界</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRightBorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightBorder</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) /<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>                left = mid +<span class="hljs-number">1</span>;<br>                rightBorder = left;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> rightBorder;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-组合总和-Medium"><a href="#19-组合总和-Medium" class="headerlink" title="19.组合总和 Medium"></a>19.组合总和 Medium</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[2,2,2,2]</span>,<span class="hljs-comment">[2,3,3]</span>,<span class="hljs-comment">[3,5]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2]</span>, target = 1<br>输出: <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>回溯</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (candidates== <span class="hljs-literal">null</span> || candidates.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        backTracking(candidates,target,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target,<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (target - candidates[i] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            path.add(candidates[i]);<br>            backTracking(candidates,target-candidates[i],i);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (candidates == <span class="hljs-literal">null</span> || candidates.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// 优化1：对候选数组进行排序</span><br>        <span class="hljs-comment">//通过对候选数组进行排序，可以将较小的元素尽早放入组合中，从而在搜索过程中更早地进行剪枝操作。当目标值小于当前选择的数字时，可以提前结束搜索，因为后续的数字更大，无法满足目标值要求。</span><br>        Arrays.sort(candidates);<br><br>        backTracking(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>            <span class="hljs-comment">// 优化2：目标值的剪枝</span><br>            <span class="hljs-keyword">if</span> (target &lt; candidates[i]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            path.add(candidates[i]);<br>            backTracking(candidates, target - candidates[i], i);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-接雨水-Hard"><a href="#20-接雨水-Hard" class="headerlink" title="20.接雨水 Hard"></a>20.接雨水 Hard</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p>Related Topics</p><ul><li>栈</li><li>数组</li><li>双指针</li><li>动态规划</li><li>单调栈</li></ul><p>思路：<a href="https://www.bilibili.com/video/BV1Qg411q7ia/?vd_source=92cb5cb9faa01574e9b1f82bf91d080d">https://www.bilibili.com/video/BV1Qg411q7ia/?vd_source=92cb5cb9faa01574e9b1f82bf91d080d</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre_max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">suf_max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            pre_max = Math.max(pre_max, height[left]);<br>            suf_max = Math.max(suf_max, height[right]);<br>            res += pre_max &lt; suf_max ? pre_max - height[left++] : suf_max-height[right--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100(%E4%BA%94)/"/>
    <url>/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣Hot100"><a href="#力扣Hot100" class="headerlink" title="力扣Hot100"></a>力扣Hot100</h1><h2 id="81-比特位计数-Easy"><a href="#81-比特位计数-Easy" class="headerlink" title="81.比特位计数 Easy"></a>81.比特位计数 Easy</h2><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong>1 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p><strong>示例 1：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">5</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br><span class="hljs-number">3</span> <span class="hljs-comment">--&gt; 11</span><br><span class="hljs-number">4</span> <span class="hljs-comment">--&gt; 100</span><br><span class="hljs-number">5</span> <span class="hljs-comment">--&gt; 101</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li><li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 <code>__builtin_popcount</code> ）</li></ul><p>Related Topics</p><ul><li>位运算</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            res[i] = countOne(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countOne</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            count++;<br>            num = num &amp; (num - <span class="hljs-number">1</span>);<span class="hljs-comment">//让最右边的1变为0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-前K个高频元素-Medium"><a href="#82-前K个高频元素-Medium" class="headerlink" title="82.前K个高频元素 Medium"></a>82.前K个高频元素 Medium</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1,1,1,2,2,3]</span>, k = 2<br>输出: <span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出: <span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><p>Related Topics</p><ul><li>数组</li><li>哈希表</li><li>分治</li><li>桶排序</li><li>计数</li><li>快速选择</li><li>排序</li><li>堆（优先队列）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length;i++)&#123;<span class="hljs-comment">//用map记录数组中的值，并记录该值出现的次数</span><br>            map.put(nums[i],map.getOrDefault(nums[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//PriorityQueue的泛型为int[]，里面第一个记录数组中的值，另一个记录该值出现的次数</span><br>       PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> &#123;<br>                <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<span class="hljs-comment">//这里是重写的compare方法，比较放进队列中的数组中对应的次数哪个多，记录次数多的那个数组</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;<span class="hljs-comment">//遍历map，取出其中的key和value，准备放入队列中</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> entry.getKey();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> entry.getValue();<br>            <span class="hljs-keyword">if</span>(queue.size() == k)&#123;<span class="hljs-comment">//说明队列满了，剩下的需要比较次数，次数多的才能放进队列</span><br>                <span class="hljs-keyword">if</span>(queue.peek()[<span class="hljs-number">1</span>] &lt; count )&#123;<br>                    queue.poll();<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num,count&#125;);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//比k小的，直接放入队列</span><br>                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num,count&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<span class="hljs-comment">//将队列中的数组的第二个值取出来，放入res数组中</span><br>            res[i] = queue.poll()[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="83-字符串解码-Medium"><a href="#83-字符串解码-Medium" class="headerlink" title="83.字符串解码 Medium"></a>83.字符串解码 Medium</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3[a]2[bc]&quot;</span><br>输出：<span class="hljs-string">&quot;aaabcbc&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3[a2[c]]&quot;</span><br>输出：<span class="hljs-string">&quot;accaccacc&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2[abc]3[cd]ef&quot;</span><br>输出：<span class="hljs-string">&quot;abcabccdcdcdef&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc3[cd]xyz&quot;</span><br>输出：<span class="hljs-string">&quot;abccdcdcdxyz&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li><li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li><li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li></ul><p>Related Topics</p><ul><li>栈</li><li>递归</li><li>字符串</li></ul><p>解析：<a href="https://www.bilibili.com/video/BV1u7411W7e2/?spm_id_from=333.337.search-card.all.click&vd_source=92cb5cb9faa01574e9b1f82bf91d080d">https://www.bilibili.com/video/BV1u7411W7e2/?spm_id_from=333.337.search-card.all.click&amp;vd_source=92cb5cb9faa01574e9b1f82bf91d080d</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        Deque&lt;Integer&gt; times = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Deque&lt;String&gt; preStrings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : chars) &#123;<br>            <span class="hljs-keyword">if</span> (isNum(c)) &#123;<br>                time = time * <span class="hljs-number">10</span> + Integer.parseInt(c + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                times.push(time);<br>                preStrings.push(res);<br>                time = <span class="hljs-number">0</span>;<br>                res = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> times.pop();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">preString</span> <span class="hljs-operator">=</span> preStrings.pop();<br>                <span class="hljs-keyword">while</span> (curTime &gt; <span class="hljs-number">0</span>) &#123;<br>                    curTime--;<br>                    preString += res;<br>                &#125;<br>                res = preString;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                res += c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNum</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="84-除法求值-Medium"><a href="#84-除法求值-Medium" class="headerlink" title="84.除法求值  Medium"></a>84.除法求值  Medium</h2><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p><p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p><strong>注意：</strong>未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]], values = [<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>]]<br>输出：[<span class="hljs-number">6.00000</span>,<span class="hljs-number">0.50000</span>,<span class="hljs-number">-1.00000</span>,<span class="hljs-number">1.00000</span>,<span class="hljs-number">-1.00000</span>]<br>解释：<br>条件：a / b = <span class="hljs-number">2.0</span>, b / c = <span class="hljs-number">3.0</span><br>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>结果：[<span class="hljs-number">6.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span> ]<br>注意：x 是未定义的 =&gt; <span class="hljs-number">-1.0</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]], values = [<span class="hljs-number">1.5</span>,<span class="hljs-number">2.5</span>,<span class="hljs-number">5.0</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>],[<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>]]<br>输出：[<span class="hljs-number">3.75000</span>,<span class="hljs-number">0.40000</span>,<span class="hljs-number">5.00000</span>,<span class="hljs-number">0.20000</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]], values = [<span class="hljs-number">0.5</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>]]<br>输出：[<span class="hljs-number">0.50000</span>,<span class="hljs-number">2.00000</span>,<span class="hljs-number">-1.00000</span>,<span class="hljs-number">-1.00000</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= equations.length &lt;= 20</code></li><li><code>equations[i].length == 2</code></li><li><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></li><li><code>values.length == equations.length</code></li><li><code>0.0 &lt; values[i] &lt;= 20.0</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></li><li><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</li></ul><p>Related Topics</p><ul><li>深度优先搜索</li><li>广度优先搜索</li><li>并查集</li><li>图</li><li>数组</li><li>最短路</li></ul><p>解析：<a href="https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">https://leetcode.cn/problems/evaluate-division/solutions/548634/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">equationsSize</span> <span class="hljs-operator">=</span> equations.size();<br><br>        <span class="hljs-type">UnionFind</span> <span class="hljs-variable">unionFind</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br>        Map&lt;String, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; equationsSize; i++) &#123;<br>            List&lt;String&gt; equation = equations.get(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> equation.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> equation.get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(var1)) &#123;<br>                hashMap.put(var1, id);<br>                id++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(var2)) &#123;<br>                hashMap.put(var2, id);<br>                id++;<br>            &#125;<br>            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">queriesSize</span> <span class="hljs-operator">=</span> queries.size();<br>        <span class="hljs-type">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[queriesSize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queriesSize; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> queries.get(i).get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> hashMap.get(var1);<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">id2</span> <span class="hljs-operator">=</span> hashMap.get(var2);<br><br>            <span class="hljs-keyword">if</span> (id1 == <span class="hljs-literal">null</span> || id2 == <span class="hljs-literal">null</span>) &#123;<br>                res[i] = -<span class="hljs-number">1.0d</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = unionFind.isConnected(id1, id2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 指向的父结点的权值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] weight;<br><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>            <span class="hljs-built_in">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>            <span class="hljs-built_in">this</span>.weight = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                parent[i] = i;<br>                weight[i] = <span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> value)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootY</span> <span class="hljs-operator">=</span> find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            parent[rootX] = rootY;<br>            <span class="hljs-comment">// 关系式的推导请见「参考代码」下方的示意图</span><br>            weight[rootX] = weight[y] * value / weight[x];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 路径压缩</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 根结点的 id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> parent[x];<br>                parent[x] = find(parent[x]);<br>                weight[x] *= weight[origin];<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootX</span> <span class="hljs-operator">=</span> find(x);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rootY</span> <span class="hljs-operator">=</span> find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span> weight[x] / weight[y];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="85-根据身高重建队列-Medium"><a href="#85-根据身高重建队列-Medium" class="headerlink" title="85.根据身高重建队列 Medium"></a>85.根据身高重建队列 Medium</h2><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[5,2]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span><br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span> 是重新构造后的队列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[6,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[6,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 2000</code></li><li><code>0 &lt;= hi &lt;= 106</code></li><li><code>0 &lt;= ki &lt; people.length</code></li><li>题目数据确保队列可以被重建</li></ul><p>Related Topics</p><ul><li>贪心</li><li>树状数组</li><li>线段树</li><li>数组</li><li>排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        <span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br>        Arrays.sort(people, (a, b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];   <span class="hljs-comment">// a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列</span><br>            <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] - a[<span class="hljs-number">0</span>];   <span class="hljs-comment">//b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列</span><br>        &#125;);<br><br>        LinkedList&lt;<span class="hljs-type">int</span>[]&gt; que = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : people) &#123;<br>            que.add(p[<span class="hljs-number">1</span>],p);   <span class="hljs-comment">//Linkedlist.add(index, value)，會將value插入到指定index裡。</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> que.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[people.length][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="86-分割等和子串-Medium"><a href="#86-分割等和子串-Medium" class="headerlink" title="86.分割等和子串 Medium"></a>86.分割等和子串 Medium</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,11,5]</span><br>输出：true<br>解释：数组可以分割成 <span class="hljs-comment">[1, 5, 5]</span> 和 <span class="hljs-comment">[11]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            sum += nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">//如果sum为奇数，那直接返回false</span><br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//target在这里就表示背包的重量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">//dp[j]表示容量为j的背包能装物品的最大价值，其中，物品的价值和重量相等</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target +<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= nums[i]; j--)&#123;<span class="hljs-comment">//j要大于等于nums[i]，因为背包容量肯定要大于物品重量</span><br>                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[target] ==target;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="87-路径总和III-Medium"><a href="#87-路径总和III-Medium" class="headerlink" title="87.路径总和III  Medium"></a>87.路径总和III  Medium</h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">3</span><br>解释：和等于 <span class="hljs-number">8</span> 的路径有 <span class="hljs-number">3</span> 条，如图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,1000]</code></li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>二叉树</li></ul><p>解析：<a href="https://leetcode.cn/problems/path-sum-iii/solutions/1021490/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/">https://leetcode.cn/problems/path-sum-iii/solutions/1021490/gong-shui-san-xie-yi-ti-shuang-jie-dfs-q-usa7/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        sum = targetSum;<br>        dfs1(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs1</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       dfs2(root,root.val);<br>       dfs1(root.left);<br>       dfs1(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs2</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (val == sum) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            dfs2(root.left,val + root.left.val);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            dfs2(root.right,val + root.right.val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者</p><p><a href="https://leetcode.cn/problems/path-sum-iii/solutions/1021296/lu-jing-zong-he-iii-by-leetcode-solution-z9td/">https://leetcode.cn/problems/path-sum-iii/solutions/1021296/lu-jing-zong-he-iii-by-leetcode-solution-z9td/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        res += dfs(root,targetSum);<br>        res += pathSum(root.left,targetSum);<br>        res += pathSum(root.right,targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (root.val == targetSum) &#123;<br>           res++;<br>       &#125;<br><br>       res += dfs(root.left,targetSum - root.val);<br>       res += dfs(root.right,targetSum - root.val);<br><br>       <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="88-找到字符串中所有的字母异位词-Medium"><a href="#88-找到字符串中所有的字母异位词-Medium" class="headerlink" title="88.找到字符串中所有的字母异位词  Medium"></a>88.找到字符串中所有的字母异位词  Medium</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><p>Related Topics</p><ul><li>哈希表</li><li>字符串</li><li>滑动窗口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-comment">//滑动窗口解法</span><br><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//定义两个字符串长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">slen</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">plen</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-keyword">if</span>(slen &lt; plen)&#123;<span class="hljs-comment">//如果s的长度比p的要小，说明不存在，直接返回list</span><br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br><br>        <span class="hljs-comment">//先统计两个字符串前plen个字母出现的频率，并判断在前plen是否有相同的异位词</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; plen;i++)&#123;<br>            arr1[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            arr2[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(arr1,arr2))&#123;<br>            list.add(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//开始滑动</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; slen-plen;i++)&#123;<br>            arr1[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<span class="hljs-comment">//将滑动前首位的词频删去</span><br>            arr1[s.charAt(i+plen) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<span class="hljs-comment">//增加滑动后最后一位的词频（以此达到滑动的效果）</span><br><br>            <span class="hljs-comment">//判断此窗口内是否有异位词</span><br>            <span class="hljs-keyword">if</span>(Arrays.equals(arr1,arr2))&#123;<br>                list.add(i+<span class="hljs-number">1</span>);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="89-找到所有数组中消失的数字-Easy"><a href="#89-找到所有数组中消失的数字-Easy" class="headerlink" title="89.找到所有数组中消失的数字 Easy"></a>89.找到所有数组中消失的数字 Easy</h2><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,3,2,7</span>,<span class="hljs-number">8,2,3,1</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li></ul><p><strong>进阶：</strong>你能在不使用额外空间且时间复杂度为 <code>O(n)</code> 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p><p>Related Topics</p><ul><li>数组</li><li>哈希表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            set.add(num);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!set.contains(i)) &#123;<br>                res.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] boo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            boo[nums[i] - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!boo[i]) &#123;<br>                res.add(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="90-汉明距离-Easy"><a href="#90-汉明距离-Easy" class="headerlink" title="90.汉明距离 Easy"></a>90.汉明距离 Easy</h2><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">1</span>   (<span class="hljs-number">0 0 0 1</span>)<br><span class="hljs-number">4</span>   (<span class="hljs-number">0 1 0 0</span>)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：x </span>=<span class="hljs-string"> 3, y = 1</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= x, y &lt;= 231 - 1</code></li></ul><p>Related Topics</p><ul><li>位运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> x ^ y; <span class="hljs-comment">// ^ 使得1 和 0 为 1，这样n里面有多少个1就是汉明距离</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            res++;<br>            <span class="hljs-comment">//二进制的n减1之后，从右往左数的第一个1就变为0，同时这个1右边所有的0都变为1</span><br>        <span class="hljs-comment">//n&amp;(n-1)会使得上一步改变的那几个1都为变0</span><br>       <span class="hljs-comment">//通过这样的规律，重复一次，就可以记录二进制中1的个数</span><br>            n = n &amp; (n-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="91-目标和-Medium"><a href="#91-目标和-Medium" class="headerlink" title="91.目标和 Medium"></a>91.目标和 Medium</h2><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。<br>-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3<br>+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>动态规划</li><li>回溯</li></ul><p>解析：<a href="https://www.bilibili.com/video/BV1o8411j73x/?vd_source=92cb5cb9faa01574e9b1f82bf91d080d">https://www.bilibili.com/video/BV1o8411j73x/?vd_source=92cb5cb9faa01574e9b1f82bf91d080d</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-comment">//两种特殊情况</span><br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> &amp;&amp; sum &lt; -target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> ((target + sum ) %<span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (sum + target) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> size; j &gt;= nums[i] ; j--) &#123;<br>                dp[j] += dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="92-把二叉搜索树转换为累加树-Medium"><a href="#92-把二叉搜索树转换为累加树-Medium" class="headerlink" title="92.把二叉搜索树转换为累加树 Medium"></a>92.把二叉搜索树转换为累加树 Medium</h2><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br>输出：[<span class="hljs-number">30</span>,<span class="hljs-number">36</span>,<span class="hljs-number">21</span>,<span class="hljs-number">36</span>,<span class="hljs-number">35</span>,<span class="hljs-number">26</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">33</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,0,2]</span><br>输出：<span class="hljs-comment">[3,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：root = [<span class="hljs-number">3,2,4,1</span>]<br>输出：[<span class="hljs-number">7,9,4,10</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>二叉搜索树</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将转换前和转换后的树按中序遍历后，得到的都是有序数组，然后就发现转换后的树其实就是中序遍历的一个变形，先遍历右子树，再左子树，就能得到答案</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        dfs(root.right);<br>        root.val += pre;<br>        pre = root.val;<br>        dfs(root.left);<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="93-二叉树的直径-Easy"><a href="#93-二叉树的直径-Easy" class="headerlink" title="93.二叉树的直径 Easy"></a>93.二叉树的直径 Easy</h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：root = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> ，取路径 [<span class="hljs-number">4,2,1,3</span>] 或 [<span class="hljs-number">5,2,1,3</span>] 的长度。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：root </span>=<span class="hljs-string"> [1,2]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 104]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不能简单的认为就是左右子树的最大深度之和，根据题意，二叉树的最大直径不一定经过根节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        getMaxDepth(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> getMaxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightDepth</span> <span class="hljs-operator">=</span> getMaxDepth(root.right);<br>        <span class="hljs-comment">//实时更新最大直径</span><br>        res = Math.max(res,leftDepth + rightDepth);<br>        <span class="hljs-comment">//左右子树的最大深度</span><br>        <span class="hljs-keyword">return</span> Math.max(leftDepth,rightDepth) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-和为K的子数组-Medium"><a href="#94-和为K的子数组-Medium" class="headerlink" title="94.和为K的子数组 Medium"></a>94.和为K的子数组 Medium</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 k 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3], k = 3</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>哈希表</li><li>前缀和</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//暴力法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> subarraySum(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">sum</span> += nums[j];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> == k) &#123;<br>                    <span class="hljs-keyword">count</span>++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前缀和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            preSum[i+<span class="hljs-number">1</span>] = preSum[i] + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-comment">//注意偏移，因为我们的nums[2]到nums[4]等于presum[5]-presum[2]</span><br>                <span class="hljs-comment">//所以这样就可以得到nums[i,j]区间内的和</span><br>                <span class="hljs-keyword">if</span> (preSum[j+<span class="hljs-number">1</span>] - preSum[i] == k) &#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/562174/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/">https://leetcode.cn/problems/subarray-sum-equals-k/solutions/562174/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            preSum += nums[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(preSum- k)) &#123;<br>                count += map.get(preSum - k);<br>            &#125;<br>            map.put(preSum,map.getOrDefault(preSum,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="95-最短无序连续子数组-Medium"><a href="#95-最短无序连续子数组-Medium" class="headerlink" title="95.最短无序连续子数组 Medium"></a>95.最短无序连续子数组 Medium</h2><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,6,4,8,10,9,15]</span><br>输出：<span class="hljs-number">5</span><br>解释：你只需要对 <span class="hljs-string">[6, 4, 8, 10, 9]</span> 进行升序排序，那么整个表都会变为升序排序。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p><p>Related Topics</p><ul><li>栈</li><li>贪心</li><li>数组</li><li>双指针</li><li>排序</li><li>单调栈</li></ul><p>解析：<a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solutions/911677/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leet-yhlf/">https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solutions/911677/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leet-yhlf/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isSorted(nums)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] copyNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        System.arraycopy(nums,<span class="hljs-number">0</span>,copyNums,<span class="hljs-number">0</span>,nums.length);<br>        Arrays.sort(copyNums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != copyNums[i]) &#123;<br>                left = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != copyNums[i]) &#123;<br>                right = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：<a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solutions/45076/shi-jian-chao-guo-100de-javajie-fa-by-zackqf/">https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/solutions/45076/shi-jian-chao-guo-100de-javajie-fa-by-zackqf/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[len-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//如果array是已经sorted的话，left和right还是初始值，确保返回的数值是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (max &gt; nums[i]) &#123;<br>                right = i;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                max= nums[i];<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (min &lt; nums[len - i - <span class="hljs-number">1</span>]) &#123;<br>                left = len - i - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                min = nums[len - i -<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left + <span class="hljs-number">1</span>;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="96-合并二叉树-Easy"><a href="#96-合并二叉树-Easy" class="headerlink" title="96.合并二叉树 Easy"></a>96.合并二叉树 Easy</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>广度优先搜索</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root1;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> root1.val + root2.val;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br>        root.left = mergeTrees(root1.left,root2.left);<br>        root.right = mergeTrees(root1.right,root2.right);<br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="97-任务调度器-Medium"><a href="#97-任务调度器-Medium" class="headerlink" title="97.任务调度器 Medium"></a>97.任务调度器 Medium</h2><p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>], n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">8</span><br>解释：A -&gt; B -&gt; <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A -&gt; B -&gt; <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A -&gt; B<br>     在本示例中，两个相同类型任务之间必须间隔长度为 n = <span class="hljs-number">2</span> 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>], n = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">6</span><br>解释：在这种情况下，任何大小为 <span class="hljs-number">6</span> 的排列都可以满足要求，因为 n = <span class="hljs-number">0</span><br>[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>]<br>[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>]<br>[<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>]<br>...<br>诸如此类<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：tasks = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>], n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">16</span><br>解释：一种可能的解决方案是：<br>     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A -&gt; <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(待命)</span> -&gt;</span> A<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= task.length &lt;= 104</code></li><li><code>tasks[i]</code> 是大写英文字母</li><li><code>n</code> 的取值范围为 <code>[0, 100]</code></li></ul><p>Related Topics</p><ul><li>贪心</li><li>数组</li><li>哈希表</li><li>计数</li><li>排序</li><li>堆（优先队列）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leastInterval</span><span class="hljs-params">(<span class="hljs-type">char</span>[] tasks, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//统计每个任务出现的次数，找到出现次数最多的任务</span><br>        <span class="hljs-type">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tasks.length; ++i) &#123;<br>            hash[tasks[i] - <span class="hljs-string">&#x27;A&#x27;</span>] += <span class="hljs-number">1</span>;<br>        &#125;<br>        Arrays.sort(hash);<br>        <span class="hljs-comment">//因为相同元素必须有n个冷却时间，假设A出现3次，n = 2，任务要执行完，至少形成AXX AXX A序列（X看作预占位置）</span><br>        <span class="hljs-comment">//该序列长度为</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> (n+<span class="hljs-number">1</span>) *  (hash[<span class="hljs-number">25</span>] - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//此时为了尽量利用X所预占的空间（贪心）使得整个执行序列长度尽量小，将剩余任务往X预占的空间插入</span><br>        <span class="hljs-comment">//剩余的任务次数有两种情况：</span><br>        <span class="hljs-comment">//1.与A出现次数相同，比如B任务最优插入结果是ABX ABX AB，中间还剩两个空位，当前序列长度+1</span><br>        <span class="hljs-comment">//2.比A出现次数少，若还有X，则按序插入X位置，比如C出现两次，形成ABC ABC AB的序列</span><br>        <span class="hljs-comment">//直到X预占位置还没插满，剩余元素逐个放入X位置就满足冷却时间至少为n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i] == hash[<span class="hljs-number">25</span>]) ++ minLen;<br>        &#125;<br>        <span class="hljs-comment">//当所有X预占的位置插满了怎么办？</span><br>        <span class="hljs-comment">//在任意插满区间（这里是ABC）后面按序插入剩余元素，比如ABCD ABCD发现D之间距离至少为n+1，肯定满足冷却条件</span><br>        <span class="hljs-comment">//因此，当X预占位置能插满时，最短序列长度就是task.length，不能插满则取最少预占序列长度</span><br>        <span class="hljs-keyword">return</span> Math.max(minLen, tasks.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-回文子串-Medium"><a href="#98-回文子串-Medium" class="headerlink" title="98.回文子串 Medium"></a>98.回文子串 Medium</h2><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span>个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><p>Related Topics</p><ul><li>字符串</li><li>动态规划</li></ul><p>解析：<a href="https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html#%E6%80%9D%E8%B7%AF</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-comment">//dp[i][j]表示下标从i到j的字符串是否是回文子串</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++) &#123;<span class="hljs-comment">//根据dp的定义，j要大于等于i</span><br>                <span class="hljs-keyword">if</span> (chars[i] == chars[j]) &#123;<br>                    <span class="hljs-comment">//j-i&gt;=1</span><br>                    <span class="hljs-comment">//j == i 就一个字母，一定是回文子串</span><br>                    <span class="hljs-comment">//j -1 ==1,两个相邻字母，因为前提已经是s.charAt(i) == s.charAt(j)，所以这两个字母是一样的，所以也是回文</span><br>                    <span class="hljs-keyword">if</span> (j-i &lt;= <span class="hljs-number">1</span>) &#123;<br>                        res++;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])&#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        res++;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="99-每日温度-Medium"><a href="#99-每日温度-Medium" class="headerlink" title="99.每日温度 Medium"></a>99.每日温度 Medium</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]<br>输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">30,40,50,60</span>]<br>输出: [<span class="hljs-number">1,1,1,0</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: temperatures = <span class="hljs-comment">[30,60,90]</span><br>输出: <span class="hljs-comment">[1,1,0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><p>Related Topics</p><ul><li>栈</li><li>数组</li><li>单调栈</li></ul><p>解析：<a href="https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentTemperatureIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                res[currentTemperatureIndex] = i - currentTemperatureIndex;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100(%E4%B8%89)/"/>
    <url>/chaserblog/2024/01/08/%E5%8A%9B%E6%89%A3Hot100(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣Hot100"><a href="#力扣Hot100" class="headerlink" title="力扣Hot100"></a>力扣Hot100</h1><h2 id="41-二叉树的层序遍历-Medium"><a href="#41-二叉树的层序遍历-Medium" class="headerlink" title="41.二叉树的层序遍历 Medium"></a>41.二叉树的层序遍历 Medium</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>Related Topics</p><ul><li>树</li><li>广度优先搜索</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接套模板</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//层序遍历</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//利用队列来实现</span><br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//要先判断根节点不为空，才能把根节点放进队列中</span><br>            deque.add(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<span class="hljs-comment">//循环条件是队列不为空</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size();<span class="hljs-comment">//记录二叉树每层节点的个数</span><br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<span class="hljs-comment">//通过size来控制要pollFirst多少次</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> deque.poll();<br>                list.add(node.val);<span class="hljs-comment">//将当前节点从队列中取出来，并记录数值</span><br>                <br>                <span class="hljs-comment">//判断当前节点的左右节点是否为空，不为空就放进队列</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>)&#123;<br>                    deque.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>)&#123;<br>                    deque.add(node.right);<br>                &#125;               <br>            &#125;<br>            res.add(list);           <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;            <br>        <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-二叉树的最大深度-Easy"><a href="#42-二叉树的最大深度-Easy" class="headerlink" title="42.二叉树的最大深度 Easy"></a>42.二叉树的最大深度 Easy</h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>广度优先搜索</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//深度优先搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br>        <span class="hljs-keyword">return</span> Math.max(left , right) +<span class="hljs-number">1</span>;<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//广度优先搜索</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       deque.offer(root);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (!deque.isEmpty()) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size();<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> deque.poll();<br>               <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                  deque.offer(cur.left);<br>               &#125;<br>               <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                   deque.offer(cur.right);<br>               &#125;<br>           &#125;<br>           res++;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="43-从前序与中序遍历序列构造二叉树-Medium"><a href="#43-从前序与中序遍历序列构造二叉树-Medium" class="headerlink" title="43.从前序与中序遍历序列构造二叉树 Medium"></a>43.从前序与中序遍历序列构造二叉树 Medium</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: preorder = <span class="hljs-string">[3,9,20,15,7]</span>, inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>输出: <span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span><br>输出: <span class="hljs-comment">[-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><p>Related Topics</p><ul><li>树</li><li>数组</li><li>哈希表</li><li>分治</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> build(preorder,<span class="hljs-number">0</span>, preorder.length-<span class="hljs-number">1</span>, inorder,<span class="hljs-number">0</span>, inorder.length-<span class="hljs-number">1</span>);<br><br>    &#125;<br><br>    TreeNode <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder,<span class="hljs-type">int</span> preStart,<span class="hljs-type">int</span> preEnd,<span class="hljs-type">int</span>[] inorder,<span class="hljs-type">int</span> inStart,<span class="hljs-type">int</span> inEnd)</span>&#123;<br>        <span class="hljs-keyword">if</span>(preStart &gt; preEnd)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//根节点的值就是中序数组中的第一个元素</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preStart];<br>        <span class="hljs-comment">//找到根节点的数值在map中的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(rootVal);<br><br>        <span class="hljs-comment">//左子树的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftLength</span> <span class="hljs-operator">=</span> index-inStart;<br><br>        <span class="hljs-comment">//构造出当前的根节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);<br><br>        <span class="hljs-comment">//构造左子树和右子树</span><br>        root.left = build(preorder,preStart+<span class="hljs-number">1</span>,preStart+leftLength,inorder,inStart,index-<span class="hljs-number">1</span>);<br>        root.right = build(preorder,preStart+leftLength+<span class="hljs-number">1</span>,preEnd,inorder,index+<span class="hljs-number">1</span>,inEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="44-二叉树展开为链表-Medium"><a href="#44-二叉树展开为链表-Medium" class="headerlink" title="44.二叉树展开为链表 Medium"></a>44.二叉树展开为链表 Medium</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><p>Related Topics</p><ul><li>栈</li><li>树</li><li>深度优先搜索</li><li>链表</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用拼接</span><br><span class="hljs-comment">//思路：以右子树为主线，每次遍历到下一个节点的时候，将该节点的右子树放到左子树中最底层的右节点，作为该节点的右子树，然后将整个左子树拼接到右子树，这样就实现了</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>               root = root.right;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root.left;<br>               <span class="hljs-keyword">while</span> (temp.right != <span class="hljs-literal">null</span>) &#123;<br>                   temp = temp.right;<br>               &#125;<br>               temp.right = root.right;<br>               root.right = root.left;<br>               root.left = <span class="hljs-literal">null</span>;<br>               root = root.right;<br>           &#125;<br>       &#125;     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用递归实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//通过递归方式将左子树和右子树拉平</span><br>        flatten((root.left));<br>        flatten((root.right));<br><br>        <span class="hljs-comment">//声明新的节点，记录拉平后的左右子树</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br><br>        <span class="hljs-comment">//将根节点的左子树为空</span><br>        root.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//将已经拉平的左子树放到根节点的右子树上</span><br>        root.right = left;<br><br>        <span class="hljs-comment">//最后将原来根节点的右子树接在当前右子树的的末端</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(temp.right != <span class="hljs-literal">null</span>)&#123;<br>            temp = temp.right;<br>        &#125;<br>        temp.right = right;<br><br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="45-买卖股票的最佳时机-Easy"><a href="#45-买卖股票的最佳时机-Easy" class="headerlink" title="45.买卖股票的最佳时机 Easy"></a>45.买卖股票的最佳时机 Easy</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">//dp[0]表示持有这只股票时花的钱，用负数表示，方便dp[1]表示净利润</span><br>        <span class="hljs-comment">//dp[1]表示卖出这只股票之后的净利润</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-comment">//第一天买入股票，花了prices[0]</span><br>        dp[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//第一天的净利润为0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//依次遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">//遍历的时候，比较更为便宜的股票，因为是负数，所以用max</span><br>            dp[<span class="hljs-number">0</span>] = Math.max(dp[<span class="hljs-number">0</span>],-prices[i]);<br>            <span class="hljs-comment">//更新利润，取最大值</span><br>            dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>]+prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法二：遍历的时候记录最小的购入价格和最大的利润</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxProfit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) &#123;<br>                minPrice = prices[i];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                maxProfit = Math.max(maxProfit,prices[i] - minPrice);<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-二叉树中的最大路径和-Hard"><a href="#46-二叉树中的最大路径和-Hard" class="headerlink" title="46.二叉树中的最大路径和 Hard"></a>46.二叉树中的最大路径和 Hard</h2><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p>Related Topics</p><ul><li>树</li><li>深度优先搜索</li><li>动态规划</li><li>二叉树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        getMaxPathSum(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxPathSum</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//递归计算左右子节点的最大贡献值</span><br>        <span class="hljs-comment">//只有在最大贡献值大于0时，才会选取对应的子节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftPathSum</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>,getMaxPathSum(node.left));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightPathSum</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>,getMaxPathSum(node.right));<br><br>        <span class="hljs-comment">//节点的最大路径和取决于该节点的值以及该节点的左右子节点的最大贡献值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> node.val + leftPathSum + rightPathSum;<br>        <span class="hljs-comment">//更新res</span><br>        res = Math.max(res,sum);<br><br>        <span class="hljs-comment">//返回节点的最大贡献值</span><br>        <span class="hljs-keyword">return</span> node.val + Math.max(leftPathSum,rightPathSum);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="47-最长连续序列-Medium"><a href="#47-最长连续序列-Medium" class="headerlink" title="47.最长连续序列 Medium"></a>47.最长连续序列 Medium</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p>Related Topics</p><ul><li>并查集</li><li>数组</li><li>哈希表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<span class="hljs-comment">//去重</span><br>            set.add(num);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>            <span class="hljs-keyword">if</span>(!set.contains(num - <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//如果数组中不包含currentNum - 1，说明currentNum是连续序列的起点</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentNum</span> <span class="hljs-operator">=</span> num;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentSeqLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//连续序列的起点</span><br>                <span class="hljs-keyword">while</span> (set.contains(currentNum + <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//接下来就看是否有连续的数字，不断更新连续序列的长度</span><br>                    currentSeqLen++;<br>                    currentNum++;<br>                &#125;<br>                <span class="hljs-comment">//取最大值</span><br>                res = Math.max(res,currentSeqLen);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//时间复杂度是O(nlogn)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化为1，因为至少会有一个元素是连续的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curSeqLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i+<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) &#123;<br>                curSeqLen++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] != nums[i+<span class="hljs-number">1</span>]) &#123;<br>                res = Math.max(res, curSeqLen);<br>                curSeqLen = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 在循环结束后再次比较更新，处理最后一个连续序列</span><br>        res = Math.max(res, curSeqLen);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-只出现一次的数字-Easy"><a href="#48-只出现一次的数字-Easy" class="headerlink" title="48.只出现一次的数字 Easy"></a>48.只出现一次的数字 Easy</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [2,2,1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,1,2,1,2]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li><li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li></ul><p>Related Topics</p><ul><li>位运算</li><li>数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <br>       <span class="hljs-comment">//异或</span><br>       <span class="hljs-comment">// ①a ^ a = 0; ②a ^ 0 = a; ③a ^ b ^ b = a ^ 0 = a;</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; nums.length; i++)&#123;<br>           res = res ^ nums[i];<br>           <span class="hljs-comment">//比如[4,1,2,1,2]: res = 0 ^ 4 ^ 1 ^ 2 ^ 1 ^ 2 = 0 ^ 4 = 4;</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="49-单词拆分-Medium"><a href="#49-单词拆分-Medium" class="headerlink" title="49.单词拆分 Medium"></a>49.单词拆分 Medium</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以由 <span class="hljs-string">&quot;leet&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 拼接成。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;applepenapple&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以由 <span class="hljs-string">&quot;apple&quot;</span> <span class="hljs-string">&quot;pen&quot;</span> <span class="hljs-string">&quot;apple&quot;</span> 拼接成。<br>     注意，你可以重复使用字典中的单词。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><p>Related Topics</p><ul><li>字典树</li><li>记忆化搜索</li><li>数组</li><li>哈希表</li><li>字符串</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>        <span class="hljs-comment">//dp[i]表示字符串长度为i时，该字符串是否能被单词列表组成</span><br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//dp[0]这里没有实际意义，声明它为true是因为后面需要根据前面来推断</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//求排列，先遍历背包后遍历物品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<span class="hljs-comment">//i就相当于背包的大小</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i &amp;&amp; !dp[i]; j++) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(s.substring(j,i)) &amp;&amp; dp[j]) &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//另一种思路</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (String word : wordDict) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> word.length();<br>                <span class="hljs-keyword">if</span>(i &gt;= len &amp;&amp; dp[i -len] &amp;&amp; word.equals(s.substring(i-len,i)))&#123;<br>                    dp[i] =<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="50-环形链表-Easy"><a href="#50-环形链表-Easy" class="headerlink" title="50.环形链表 Easy"></a>50.环形链表 Easy</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：pos 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><p>Related Topics</p><ul><li>哈希表</li><li>链表</li><li>双指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果快慢指针不相遇，最终一定会遍历到链表末尾，终止循环</span><br>           slow = slow.next;<span class="hljs-comment">//慢指针移动一步</span><br>           fast = fast.next.next;<span class="hljs-comment">//快指针移动两步</span><br>           <span class="hljs-keyword">if</span> (slow == fast) &#123;<span class="hljs-comment">//如果有环，快慢指针一定相遇</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-环形链表II-Medium"><a href="#51-环形链表II-Medium" class="headerlink" title="51.环形链表II Medium"></a>51.环形链表II Medium</h2><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 null。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><p>Related Topics</p><ul><li>哈希表</li><li>链表</li><li>双指针</li></ul><p>解析：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> head;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> slow;<br>                <span class="hljs-keyword">while</span> (index2 != index1) &#123;<br>                    index2 = index2.next;<br>                    index1 = index1.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="52-LRU缓存-Medium"><a href="#52-LRU缓存-Medium" class="headerlink" title="52.LRU缓存 Medium"></a>52.LRU缓存 Medium</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><p>Related Topics</p><ul><li>设计</li><li>哈希表</li><li>链表</li><li>双向链表</li></ul><p>解析：<a href="https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/">https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">//定义一个双向链表</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        MyListNode pre;<br>        MyListNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyListNode</span><span class="hljs-params">()</span>&#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyListNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br><br>    &#125;<br><br>    Map&lt;Integer,MyListNode&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> size;<span class="hljs-comment">//当前链表的长度</span><br>    <span class="hljs-type">int</span> capacity;<span class="hljs-comment">//题目给定的链表长度，作为全局变量</span><br>    MyListNode head, tail;<span class="hljs-comment">//伪头节点、伪尾结点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">//进行一系列初始化</span><br>        size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListNode</span>();<br>        <span class="hljs-comment">//头结点和尾结点相互指向</span><br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br>    <br>    <span class="hljs-comment">//获取key对应value</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//通过map找到对应的节点</span><br>        <span class="hljs-type">MyListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//每获取一次值就放到链表头部去，用于表示这个节点刚被访问过</span><br>        <span class="hljs-comment">//这样很久没被访问的节点最终就会跑到链表尾部</span><br>        moveToHead(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-comment">//新增或修改</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">MyListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//不存在该kv</span><br>            <span class="hljs-comment">//创建一个该kv的节点，塞到map中</span><br>            <span class="hljs-type">MyListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListNode</span>(key,value);<br>            cache.put(key,newNode);<br>            <span class="hljs-comment">//移动到头部</span><br>            addToHead(newNode);<br>            size++;<span class="hljs-comment">//记得链表长度+1</span><br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<span class="hljs-comment">//如果装不下了，就将很久没访问的节点删掉</span><br>                <span class="hljs-type">MyListNode</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> removeTail();<br>                cache.remove(tail.key);<br>                --size;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            node.value = value;<br>            moveToHead(node);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//将该节点添加到头部</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToHead</span><span class="hljs-params">(MyListNode node)</span> &#123;<br>        <span class="hljs-type">MyListNode</span> <span class="hljs-variable">headNext</span> <span class="hljs-operator">=</span> head.next;<br>        node.pre = head;<br>        head.next = node;<br>        node.next = headNext;<br>        headNext.pre = node;<br>    &#125;<br><br>    <span class="hljs-comment">//删除节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span> <span class="hljs-params">(MyListNode node)</span> &#123;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br><br><span class="hljs-comment">//移动到头部</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span> <span class="hljs-params">(MyListNode node)</span> &#123;<br>        removeNode(node);<br>        addToHead(node);<br>    &#125;<br><br><span class="hljs-comment">//删除尾节点</span><br>    <span class="hljs-keyword">public</span> MyListNode <span class="hljs-title function_">removeTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MyListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> tail.pre;<br>        removeNode(res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-排序链表-Medium"><a href="#53-排序链表-Medium" class="headerlink" title="53.排序链表 Medium"></a>53.排序链表 Medium</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>]<br>输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [-<span class="hljs-number">1,5,3,4</span>,<span class="hljs-number">0</span>]<br>输出：[-<span class="hljs-number">1,0,3,4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>Related Topics</p><ul><li>链表</li><li>双指针</li><li>分治</li><li>排序</li><li>归并排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最直观的方法是用数据记录链表的所有节点值，排序后，再更改链表所有节点的值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<br>            list.add(temp.val);<br>            temp = temp.next;<br>        &#125;<br>        Collections.sort(list);<br>        temp = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            temp.val = list.get(i);<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用优先队列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;ListNode&gt;((node1,node2) -&gt; node1.val-node2.val);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">null</span>) &#123;<br>            queue.offer(temp);<br>            temp = temp.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            current.next = queue.poll();<br>            current = current.next;<br>        &#125;<br>        current.next = <span class="hljs-literal">null</span>;<span class="hljs-comment">//最后一个节点的next要置为空</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用归并排序</p><p>解析：<a href="https://leetcode.cn/problems/sort-list/solutions/13728/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/">https://leetcode.cn/problems/sort-list/solutions/13728/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//递归终止条件</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-comment">//找到链表的中间节点，并断开</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">middleNode</span> <span class="hljs-operator">=</span> getMiddleNode(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightListNode</span> <span class="hljs-operator">=</span> middleNode.next;<br>        middleNode.next = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(rightListNode);<br><br>        <span class="hljs-comment">//合并有序链表</span><br>        <span class="hljs-keyword">return</span> mergeTwoListNode(left,right);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//返回中间节点</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getMiddleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//合并链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoListNode</span><span class="hljs-params">(ListNode l1,ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>                cur.next = l1;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cur.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br><br>        cur.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummy.next;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-乘积最大子数组"><a href="#54-乘积最大子数组" class="headerlink" title="54.乘积最大子数组"></a>54.乘积最大子数组</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><p><strong>子数组</strong> 是数组的连续子序列。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,0,<span class="hljs-string">-1</span>]<br>输出: 0<br>解释: 结果不能为 2, 因为 [<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>] 不是子数组。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li></ul><p>Related Topics</p><ul><li>数组</li><li>动态规划</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//由于存在负负得正的情况，所以无法简单判断加入或者不加入就确定动态转移方程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//maxF[i]表示以nums[i]结尾的子数组，最大的乘积为maxF[i]</span><br>        <span class="hljs-type">int</span>[] maxF = Arrays.copyOf(nums,len);<br>        <span class="hljs-comment">//minF[i]表示以nums[i]结尾的子数组，最小的乘积为minF[i]</span><br>        <span class="hljs-type">int</span>[] minF = Arrays.copyOf(nums,len);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            maxF[i] = Math.max(Math.max(maxF[i-<span class="hljs-number">1</span>]*nums[i],minF[i-<span class="hljs-number">1</span>]*nums[i]),nums[i]);<br>            minF[i] = Math.min(Math.min(maxF[i-<span class="hljs-number">1</span>]*nums[i],minF[i-<span class="hljs-number">1</span>]*nums[i]),nums[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxF.length; i++) &#123;<br>            res = Math.max(res,maxF[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempMax</span> <span class="hljs-operator">=</span> max;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempMin</span> <span class="hljs-operator">=</span> min;<br>            max = Math.max(nums[i], Math.max(max * nums[i],min*nums[i]));<br>            min = Math.min(nums[i], Math.min(max*nums[i],min*nums[i]));<br>            res = Math.max(res,max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="55-最小栈"><a href="#55-最小栈" class="headerlink" title="55.最小栈"></a>55.最小栈</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul><p>Related Topics</p><ul><li>栈</li><li>设计</li></ul><p>这道题与剑指offer第30题一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Stack&lt;Integer&gt; dataStack;<br>    Stack&lt;Integer&gt; minStack;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        dataStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        dataStack.push(val);<br>        <span class="hljs-keyword">if</span> (minStack.isEmpty() || minStack.peek() &gt;= val) &#123;<br>            minStack.push(val);<br>        &#125;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!dataStack.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> dataStack.pop();<br>            <span class="hljs-keyword">if</span> (!minStack.isEmpty() &amp;&amp; value == minStack.peek()) &#123;<br>                minStack.pop();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dataStack.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> minStack.peek();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-相交链表"><a href="#56-相交链表" class="headerlink" title="56.相交链表"></a>56.相交链表</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><p>Related Topics</p><ul><li>哈希表</li><li>链表</li><li>双指针</li></ul><p>这题跟剑指offer第52题一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> getLength(headA);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenB</span> <span class="hljs-operator">=</span> getLength(headB);<br><br>        <span class="hljs-comment">// 将较长链表的指针先向后移动差值个节点</span><br>        <span class="hljs-keyword">while</span> (lenA &gt; lenB) &#123;<br>            headA = headA.next;<br>            lenA--;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (lenB &gt; lenA) &#123;<br>            headB = headB.next;<br>            lenB--;<br>        &#125;<br><br>        <span class="hljs-comment">// 同时遍历两个链表，找到第一个相交节点</span><br>        <span class="hljs-keyword">while</span> (headA != <span class="hljs-literal">null</span> &amp;&amp; headB != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (headA == headB) &#123;<br>                <span class="hljs-keyword">return</span> headA;<br>            &#125;<br>            headA = headA.next;<br>            headB = headB.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数，用于计算链表的长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            len++;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="57-多数元素"><a href="#57-多数元素" class="headerlink" title="57.多数元素"></a>57.多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p><p>Related Topics</p><ul><li>数组</li><li>哈希表</li><li>分治</li><li>计数</li><li>排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//题目明确说了这个元素的个数超过数组长度的一半，所以排序后返回中间那个数即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums[nums.length/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文字解析：<a href="https://leetcode.cn/problems/majority-element/solutions/1/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh/">https://leetcode.cn/problems/majority-element/solutions/1/169-duo-shu-yuan-su-mo-er-tou-piao-qing-ledrh/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//摩尔投票法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                x = num;<br>            &#125;<br>            count += x == num? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="58-打家劫舍"><a href="#58-打家劫舍" class="headerlink" title="58.打家劫舍"></a>58.打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p>Related Topics</p><ul><li>数组</li><li>动态规划</li></ul><p>解析：<a href="https://www.programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html#%E6%80%9D%E8%B7%AF</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//先考虑特殊情况</span><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//dp[i]表示到第i家最多能盗窃的金额</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="59-岛屿数量"><a href="#59-岛屿数量" class="headerlink" title="59.岛屿数量"></a>59.岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><p>Related Topics</p><ul><li>深度优先搜索</li><li>广度优先搜索</li><li>并查集</li><li>数组</li><li>矩阵</li></ul><p>文字解析：<a href="https://www.programmercarl.com/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.%E6%B7%B1%E6%90%9C%E7%89%88.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.%E6%B7%B1%E6%90%9C%E7%89%88.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    res++;<br>                    dfs(grid,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        dfs(grid,i-<span class="hljs-number">1</span>,j);<br>        dfs(grid,i+<span class="hljs-number">1</span>,j);<br>        dfs(grid,i,j-<span class="hljs-number">1</span>);<br>        dfs(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="60-反转链表"><a href="#60-反转链表" class="headerlink" title="60.反转链表"></a>60.反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p>Related Topics</p><ul><li>递归</li><li>链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//头插法</span><br>        <span class="hljs-comment">//通过设置一个虚拟节点，将摘下的节点连接到虚拟节点上</span><br>        <span class="hljs-comment">//按顺序遍历原链表，依次将节点连接到虚拟节点后，即在虚拟节点和后面的节点中间插入</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverseHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            pre = cur;<br>            cur = cur.next;<br>            pre.next = reverseHead.next;<br>            reverseHead.next = pre;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> reverseHead.next;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            temp = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2021/10/01/2022-03-24%20%E6%88%91%E7%9A%84%E7%BB%8F%E5%8E%86%20&amp;%20%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2021/10/01/2022-03-24%20%E6%88%91%E7%9A%84%E7%BB%8F%E5%8E%86%20&amp;%20%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="大学经历"><a href="#大学经历" class="headerlink" title="大学经历"></a>大学经历</h1><p>工作室</p><p>鹅厂工作</p><h2 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h2><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>不能完全跟着学校学</p><p>Java、MySQL</p><p>网站工作室 - html\css\js\响应式\Bootstrap</p><p>python\C#\java spring</p><p>国家级创新项目 —— 机会是自己争取的</p><p>3.73</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>前端 vue、jquery、组件库，做项目</p><p>后端 java spring、springmvc、mybatis</p><p>做项目去学习 —— 校园打卡系统（前端 + 后端）学生是否在教学楼（上网搜），很杂乱</p><p>5 家实习（大厂）<strong>实习僧</strong> </p><p>html\css\js，算法数据结构，全挂了</p><p>java 拿到了机会，珍惜机会（一般的公司）<strong>目标：java 后端</strong> （思考逻辑）</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>加入实验室，区块链项目、教材</p><p><strong>跳板</strong>     进入一家大点的互联网公司（字节跳动）</p><p>springcloud、socket、netty、dubbo、rpc、jvm、并发编程</p><p><strong>实习</strong> </p><p>不算裸辞（有备选方案）</p><h3 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h3><p>快速晋升，趁早准备，趁早做规划</p><h3 id="工作上半年"><a href="#工作上半年" class="headerlink" title="工作上半年"></a>工作上半年</h3><p>全身心</p><p>做任何事情，一定要朝着自己的目标来。看网上的经验 &#x2F; 知识，自学。</p><h2 id="大一，学编程做项目"><a href="#大一，学编程做项目" class="headerlink" title="大一，学编程做项目"></a>大一，学编程做项目</h2><p>要刷 OJ 的 &#x3D;&gt; 自学额外的编程语言（<strong>前端 \ python</strong> \ Android） 目标：<strong>写代码</strong> 、做出东西。（挤时间）</p><p><strong>做自己的项目：</strong></p><ol><li>一个算法（抢红包）</li><li>网站</li><li>APP</li><li>一个技术框架</li></ol><p>先百度 &#x3D;&gt; 问别人</p><p>把自己所有遇到的 bug 全部记录，收藏好， <strong>错题集</strong></p><p>学编程不要背，记忆的东西越少越好（第二大脑）。（考试前要背）</p><h2 id="大二、竞赛"><a href="#大二、竞赛" class="headerlink" title="大二、竞赛"></a>大二、竞赛</h2><p>做自己的项目 《&#x3D;》 参加比赛</p><p>计算机应用能力大赛（三等奖）2 次 （合作）吃亏了，完成</p><p>蓝桥杯（省二 * 2）友好 <strong>（一定要参加）</strong></p><p>三创赛（上海市二等奖）：拼团购物 APP + 网站，功能多，营销模式上（了解比赛的规则以及详细的打分机制）</p><p>挑战杯（大三上）国家级二等奖 上海市特等奖：合作，计算机真正的价值（多去尝试、多去找机会）</p><h2 id="大三、考研还是就业"><a href="#大三、考研还是就业" class="headerlink" title="大三、考研还是就业"></a>大三、考研还是就业</h2><p>外界的压力、长辈的压力、同龄人的压力、研究生认可度高一点、有一些岗位的硬性要求：算法（AI\NLP\CV）</p><p>就业 挣钱</p><p>趁早抓机会！！！！<strong>大二、大一多学技术</strong></p><h4 id="大二暑假找一个实习（时间不够、能力不够、没机会去）"><a href="#大二暑假找一个实习（时间不够、能力不够、没机会去）" class="headerlink" title="大二暑假找一个实习（时间不够、能力不够、没机会去）"></a>大二暑假找一个实习（时间不够、能力不够、没机会去）</h4><p><strong>想想你会什么、写简历、投递简历、去面试</strong></p><p><strong>兴趣</strong></p><p>转正（抓住眼前的机会）</p><p>《校招薪水》</p><h2 id="大四、求职-面试官最看重的"><a href="#大四、求职-面试官最看重的" class="headerlink" title="大四、求职 - 面试官最看重的"></a>大四、求职 - 面试官最看重的</h2><ol><li>写简历（项目经验 &#x2F; 实习经历）</li><li>逻辑思维（简历的项目介绍，用什么技术解决了什么问题）&#x3D;》自己做项目、多思考别人怎么做的、刷算法（做oj）</li><li>语言表达、做事认真（简历不能有错别字）</li><li>自主性、创新性</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>“《博客搭建相关》”</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
