<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/"/>
    <url>/chaserblog/2024/04/29/%E7%AE%80%E5%8E%86%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%90%B8%E5%BC%95%E9%9D%A2%E8%AF%95%E5%AE%98%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>总结：你用什么技术，解决了什么问题，达到了什么效果，优化提高了效率。</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427192526166.png" alt="image-20240427192526166"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427193048993.png" alt="image-20240427193048993"></p><p>简历应该怎么写才能吸引面试官呢？</p><p>在我的简历中，包含几部分：个人基本信息、个人描述、荣誉奖项、科研学术经历、实习经历、项目经历、技术栈，这些都是一份优质程序员简历上都该有的关键信息。</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427191643229.png" alt="image-20240427191643229"></p><p>凭着这份简历，我也是百投百中，秋招时很多公司的笔试都没参与就收到了面试邀约。这份简历也曾经被同事、B 站知名 UP 主拿去分享，帮助大家学习写简历的技巧。</p><p>但事实上，人外有人，天外有天。至今为止，我已经向腾讯内推了 300 多名 同学，每一位投递人的简历我都有阅读，看了这么多，也发现了很多让我拍案叫绝的简历。我不禁感慨，自己的简历的确还有待提高啊，要不是堆了一些奖项，估计也就被其他大佬压在地上摩擦了。</p><p>其中有一份简历让我印象深刻，不仅是因为他的主人，正是我的 同校直系 学弟，我大四在学校举办腾讯云开发校园作坊时，他还主动和我交流了一段时间。当然，更重要的是，他的这份简历，在我看来是非常非常优秀的，即使简历上没有任何一个竞赛奖项或科研成果，但通过一些小技巧，依旧能够吸引面试官！</p><p>后来学弟果然被发起了面试邀约，最后也成功通过了面试，拿到了腾讯的 offer，现在是我的同事哈哈~</p><p>所以我把他的简历称为 “标杆简历”，我认为所有同学都能够且应该学习和参考他的简历，从而增加你进入面试的概率。</p><p>在征得学弟的同意后，脱敏分享给大家~</p><p>简历内容<br>这份简历只有一页，非常精简，内容分为 教育经历、技术栈、实习经历、项目经历 四部分。</p><p>学弟的简历<br>教育经历<br>学校：上海 XXX 工程院校 本科在读</p><p>专业：软件工程</p><p>外语：大一时通过 CET4􏰉、CET􏰅6 考试</p><p>技术栈<br>后端</p><p>熟悉: Java</p><p>了解：SpringCloud、Express.js、Node.js、Python</p><p>数据库</p><p>熟悉：MySQL</p><p>了解：MongoDB</p><p>中间件</p><p>了解：Redis、RabbitMQ、Elasticsearch</p><p>DevOps</p><p>了解：微服务、Jenkins、Gitlab CI &#x2F; CD、Nginx、Traefik、Linux</p><p>云计算</p><p>了解:  Docker、Kubernetes</p><p>前端</p><p>了解:  React、React Native、Javascript、HTML、CSS、Grafana</p><p>实习经历<br>腾讯科技有限公司 后端开发工程师（实习）</p><p>在腾讯 XX 部门从事 管理系统 开发，主要参与故障处理平台建设</p><p>完成故障处理流程灰度、流程版本升级功能的需求分析、数据库设计、界面原型设计以及前后端实现，加快了运营团队的迭代速度</p><p>为方便团队掌握大规模故障的情况，参与了大规模告警机制的开发流程，并为其开发前端交互界面</p><p>使用 Grafana 开发运营监控视图，使团队成员可以快速掌握运营状况，及时做出调整</p><p>项目经历<br>Roga Developer</p><p>展示地址：<a href="https://xxx.live(暂不公开哈)/">https://xxx.live（暂不公开哈）</a></p><p>独立开发的基于 MERN 技术栈的 新媒体信息流整合 平台，采用 前后端分离架构</p><p>使用 React 构建前端，对手机端 交互模式 进行了 专门优化 ，使用 Cloudflare 作为 CDN</p><p>使用 React Native 开发了 跨平台 的移动端应用，提高了开发效率，减少了 50% 的开发时间</p><p>为适应产品特性，加快迭代速度，后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB ，实现了前后一体的 集中式配置中心 ，提高了接近 1 倍 的开发效率</p><p>使用 JWT 用户鉴权实现了 平台内容分级机制 ，用户可自定义界面，用户设置 云端同步</p><p>采用 Redis 实现了 高频信息缓存 ，加快了 请求响应速度 ，降低了 90% 以上的数据库压力</p><p>使用 Elasticsearch 实现 全站内容搜索 ，相比 MongoDB 搜索效率提升 80% 以上</p><p>利用 RabbitMQ 的队列机制进行 削峰 ，缓解了 高并发 情况下的 系统资源短缺 问题</p><p>为加强爬虫系统灵活性，将其由 Scrapy 重写为 Node.js ，实现了分批分时、错峰爬取</p><p>为提升开发效率，使用 Gitlab CI&#x2F;CD 进行 持续集成 和 持续部署 ，实现了 构建部署自动化</p><p>采用 Nginx 和 Traefik 进行 前端部署 和 反向代理 ，增强了软件系统的 安全性</p><p>为配合 集群化部署 ，前后端均以 Docker 作为容器，可在任一陌生机器 迅速启动应用</p><p>曾使用 VPS 测试搭建了拥有 10 个节点的 K8s 集群，可进行应用的 快速扩容 和 集中式管理</p><p>RubbishQ Developer</p><p>垃圾分类查询工具，负责 技术选型 、架构设计 和 前后端开发 工作</p><p>为适应产品特性，使用 MongoDB 作为数据库，实现了垃圾分类、讨论区等功能</p><p>为减轻数据库压力，使用 Redis 对搜索结果进行 缓存 ，同时 极大缩短了应用响应时间</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240427191801377.png" alt="image-20240427191801377"></p><p>简历技巧<br>我不知道大家看完学弟的简历后有什么感受，反正给我最明显的感觉就是两点：</p><p>他会的技术很多</p><p>自主性很强，并且善于用技术解决问题</p><p>而且呢，看完他的简历后，他的 Roga 新媒体信息流整合 项目给我留下了深刻的印象，为啥呢？</p><p>首先显而易见，这个项目经历占据了他简历的大部分内容（50 % 左右）。虽然很长，但是有关这个项目的介绍却字字珠玑，句句精华！</p><p>比如这句：为适应产品特性，加快迭代速度，后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB ，实现了前后一体的 集中式配置中心 ，提高了接近 1 倍 的开发效率。</p><p>和大多数同学介绍项目时直接简单写一句 “用什么技术实现了什么功能” 不同，这句话点明了四个关键：</p><p>为什么要做？（为适应产品特性，加快迭代速度）</p><p>怎么做？用什么技术？（后端由 Springboot 重构至 Node.js ，数据库由 MySQL 迁移至 MongoDB）</p><p>实现了什么？（前后一体的 集中式配置中心）</p><p>达到了怎样的效果？（提高了接近 1 倍 的开发效率）</p><p>有前因、有技术、有后果，给人的感觉就是这位同学做事有目的、有自主性、又善于分析和总结，这些正是很多面试官都看中的特质。再加上介绍中使用大量的 加粗 强调了重点，使用具体数据（如 50%）量化了效果，再次给人加深了印象。我觉得这种写法非常值得大家学习！</p><p>很多同学担心自己简历上没东西写，那不妨认认真真做一个项目，然后按照他的项目经历写法，展示到简历上。</p><p>结合这位学弟和我的简历，鱼皮给大家总结了 撰写简历的一些技巧 ：</p><p>内容完整全面，简历通常包括几个部分：个人简介（基本信息、照片、学校、专业、成绩、证书等）、个人描述（专业特长）、个人技能（技术栈）、项目经历、科研学术经历、实习经历等。</p><p>简历必须一页，排版整洁，且色调不宜过暗或过亮，推荐蓝色或淡灰色。</p><p>依据个人优势对板块排序，把最有亮点的部门放上面。</p><p>文字内容精炼，拒绝口语化，用词尽量专业，体现专业性。</p><p>项目 &#x2F; 实习经历介绍中，可用 STAR 分析（场景、任务、行动、成果）来梳理自己的核心工作。比如，在 xx 公司 xx 项目中，在 xx 情况下，运用 xx 技术，解决了 xx，优化了 xx，带来 xx 收益。每段介绍不宜过长，给面试官提问的空间。</p><p>最好给项目附上可直接访问的链接，有个人博客的话也最好列举上去，并且在博客中记录和总结一些自己学到的知识技能，让面试官感受到你的努力积累、脚踏实地。</p><p>利用简历去引导面试官。很多面试官都会针对简历中提到的技术去展开提问，因此必须熟悉简历中的项目和技术，提前想好对策（比如项目中用了哪些技术，为什么用，有什么亮点，怎么去优化等）。</p><p>写完简历后，自己通读几遍，有机会可以多阅读借鉴他人的简历。</p><p>针对不同的岗位和 JD（岗位描述），准备不同的简历，在部分细节和工作内容上调整。比如投递产品和运营岗，你的项目和实习介绍就要分别侧重这两种不同的职位。</p><p>内容允许夸大，尤其是对于没有特别多的项目的同学，在简历的项目部分是需要适度包装的。但是杜绝欺骗，尤其是工作年限等有准确数字、可被调查的问题，请实事求是，否则后果自负。</p><p> 作者：程序员鱼皮 <a href="https://www.bilibili.com/read/cv11757591/">https://www.bilibili.com/read/cv11757591/</a> 出处：bilibili</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <url>/chaserblog/2024/04/29/markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>一、标题</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h1 id="1-一级标题"><a href="#1-一级标题" class="headerlink" title="1 一级标题"></a>1 一级标题</h1><h2 id="2-二级标题"><a href="#2-二级标题" class="headerlink" title="2 二级标题"></a>2 二级标题</h2><p>二、段落</p><p>斜体、<em>1</em></p><p>粗体、<strong>粗体</strong></p><p>粗斜体、<em><strong>1</strong></em></p><p>分隔线、</p><hr><hr><p>删除线、<del>baidu</del></p><p>下划线、<u>xia</u></p><p>脚注1[^2]</p><p>三、列表</p><p>无序列表</p><ul><li>第一项</li><li>第二项</li></ul><p>有序列表</p><ol><li>第一项</li><li>第二项</li></ol><p>列表嵌套</p><ol><li>第一<ul><li>嵌套1</li><li>嵌套2</li></ul></li><li>第二</li></ol><p>四、区块（&gt;)</p><blockquote><p>区块引用</p></blockquote><blockquote><p>菜鸟笔记</p><hr></blockquote><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><p>区块中使用列表</p><blockquote><p>区块</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><p>列表中使用区块</p><ol><li><p>第一项</p><blockquote><p>区块</p><ol><li>第一项</li></ol></blockquote></li><li><p>第二项</p></li></ol><ul><li><p>第一项</p><blockquote><p>区块</p></blockquote></li><li><p>第二项</p></li></ul><p>五、代码</p><p>段落上的一个函数或片段的代码可以用反引号把它包起来（**&#96;**）</p><p><code>printf()</code></p><p>代码区块</p><ol><li>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>(我没有用起)</li><li>用 <strong>&#96;&#96;&#96;</strong> 包裹一段代码，并指定一种语言（也可以不指定）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;runoob&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>六、链接</p><p><a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">链接名称</a></p><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a></p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><p>七、图片</p><p><img src="https://static.jyshare.com/images/runoob-logo.png" alt="alt 属性文本"></p><p>八、表格</p><table><thead><tr><th>左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td>单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td>单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><table><thead><tr><th align="center">dfasd</th><th align="center">dfadsfsd</th><th align="center">fdafdf</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>九、支持html元素</p><p>1</p><p>大幅</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/2024.4.27/"/>
    <url>/chaserblog/2024/04/29/2024.4.27/</url>
    
    <content type="html"><![CDATA[<p><strong>一、Textile</strong> <strong>格式</strong><br>Textile是一种简单的文本标记，简单的符号标记要强调的单词。文本块可轻易标记为头部、引用或列表。Textile文档能转换成HTML文档用于Web浏览。</p><p>今天总体的完成学习情况</p><ul><li><input disabled="" type="checkbox"> 学习了阿里云盘上鱼皮的分享视频  2小时</li><li><input disabled="" type="checkbox"> 学习了utools这个功能强大的插件库，有很多功能强大的插件</li><li><input disabled="" type="checkbox"> 在有道云笔记上记了一下学习笔记</li><li><input disabled="" type="checkbox"> 准备根据视频搭建自己的博客，不知能否成功。</li><li><input disabled="" type="checkbox"> 玩了一下语雀，团队项目的协作平台</li></ul><p><img src="/chaserblog/./assets/image-20240427170153026.png" alt="image-20240427170153026"></p><p>在学习文件夹下的程序员鱼皮中有我今天所收集的信息</p><p>还有就是知识星球和[编程导航](<a href="https://www.code-nav.cn/user/1698590357501091841">用户信息 - 编程导航 (code-nav.cn)</a>)、面试鸭这个项目的面试经验的学习一部分</p><h1 id="1-鱼皮学习体会和感受"><a href="#1-鱼皮学习体会和感受" class="headerlink" title="1 鱼皮学习体会和感受"></a>1 鱼皮学习体会和感受</h1><p>从实习至今，我已经在腾讯工作两年了。今天分享下我自从入职腾讯就一直在坚持的习惯，说出来可能会有点土哈哈，这个习惯就是 <strong>写日报</strong> 。</p><p>没错，每天下班前，我都会用 <code>Typora</code> 软件在自己电脑上记录一下当天完成的工作，并且计划好第二天要做的事，其实有点像写日记。</p><p><img src="/chaserblog/./assets/640.png" alt="图片"></p><ul><li><p><input disabled="" type="checkbox"> <strong>程序员鱼皮开发的软件变成导航：地址<a href="https://www.code-nav.cn/">主页 - 编程导航 (code-nav.cn)</a></strong></p><p>重要网站</p></li></ul><p><img src="/chaserblog/./assets/image-20240427103716775.png" alt="image-20240427103716775"></p><p>练习了使用html内嵌样式，更改文字颜色。</p><p><span style="color:文字颜色;background:red;font-size:文字大小;font-family:字体;">你要改色的文字</span></p><p>别人所做的计划安排：</p><p>日报中都写了什么呢？给大家看我实习期间写的一篇：</p><p><img src="/chaserblog/./assets/1.png" alt="图片"></p><p>先说说 <strong>今日计划</strong> 部分，除了列举要做的事，我还会给每项工作一个预期完成时间，有点类似之前提到的目标拆解，可以帮助自己更好地把握整体工作进度。</p><p>再说说 <strong>实际工作</strong> 部分，记录了自己完成计划所做的事项以及耗费的时间，可以帮助自己事后复盘。比如这一天我计划 1 个小时完成本地项目搭建，但实际消耗了 2.5 个小时，我就会在另一个文档记录工作中遇到的问题，并且思考：如果再让我做这件事，用什么方法能按预期时间完成呢？</p><p>通过坚持记录，我很轻松地做出了转正答辩 PPT，并且顺利通过。而如果没有写日报的这个习惯，可能我要再想破脑袋去梳理自己的工作内容了，要额外花费很多时间精力。</p><p>所以在转正后，我会在日报上记录更多的内容，比如在工作中的思考、收获感悟、导师的教诲等。</p><p>比如之前有段时间，我投入了大量精力去调研某个系统的各种技术实现方案，结果到最后也没给出一个确定的结论。后面冷静分析了下，确实从高层的视角来看，这段时间我啥代码都没写、零产出。所以有了如下思考：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYKs01zOKIicx0Llibe9BfhdV5MQHEAict8FlI4Oia8ySDwwX0JcGUricAduVohPquMtv7dqqK0QqDibKZrQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>把这点记录下来，在之后的工作中，我会更注重 <strong>结果导向</strong> ，调整自己在不重要事情上投入的时间，不要为了学技术而学技术。</p><p>不得不说，写日报真的给我带来了很大的价值。因此，即使后来换部门后老板要求写周报就行了，但我始终保持写日报的习惯，每周再对日报汇总，提炼出有价值的工作，周报自然就轻松完成。</p><p>很多同学抱怨自己工作效率低，日复一日，很是迷茫。那不妨试试写日报，当你持续总结和计划后，会发现每一天都有盼头，每一天都无比充实。</p><p>万事开头难，刚开始写日报时，我会花不少时间，有时候也会偷懒随便写写。但当养成习惯后，每天只需要花 2 - 3 分钟就能完成。</p><p>不要觉得写日报浪费时间！一般公司内每次评估绩效和晋级前，都需要汇报自己的工作内容。这种时候，我只需掏出日报，两年内的工作尽收眼底、历历在目，有了平日点滴的积累，何愁没有东西写呢？</p><p>最后，其实我真正的坚持的是 <strong>计划</strong> 和 <strong>总结</strong> ，写日报只是一种方式罢了。除了总结工作内容，我还会总结用过的技术和平台、读过的文章、写过的 Bug 等。比如我在公司两年总结的所有内部平台和技术，做了分类：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYKs01zOKIicx0Llibe9BfhdV5QtBLxro0iaXN1HWBSpwBpgT7SCJXnwc3lAJQPXt9dxJyAHEwxFFiblRQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h1 id="自我感想"><a href="#自我感想" class="headerlink" title="自我感想"></a>自我感想</h1><p>​        从今天起，自己一定要改掉以前的手写笔记的习惯，要紧跟时代的步伐，用高科技的手段技术来革新自己，武装自己，提高自己的学习效率。不断地学习新工具。</p><p>​       不断地吸收新思想，新观点，新方法。</p><p>interest</p><p>我觉得大学前三年的学习完全没有找到重心，有点遗憾，但从今天做起，加油！</p><p>可以日报周报结合，周报也分计划和实际。 有时候我们不太容易确定“明天做什么”，频繁修改计划又会让你的计划变得没有意义。这个时候周报的“计划”就会让你知道你这个星期的侧重点是什么，不至于只看重“明天”而忽视了“未来”，更好地去规划“明天”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/2022-05-15%20%E9%9D%A2%E8%AF%95%E9%B8%AD%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/29/2022-05-15%20%E9%9D%A2%E8%AF%95%E9%B8%AD%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="面试鸭分享"><a href="#面试鸭分享" class="headerlink" title="面试鸭分享"></a>面试鸭分享</h1><p>做着玩和真正上线有很大的区别</p><p><a href="https://github.com/liyupi/mianshiya-public">https://github.com/liyupi/mianshiya-public</a></p><h3 id="创作原因"><a href="#创作原因" class="headerlink" title="创作原因"></a>创作原因</h3><ol><li>挖掘需求：自己遇到的问题，看别人的项目并且找出别人项目的缺点</li></ol><p>验证需求是否有价值：能解决别人的问题，<strong>能否解决通用的问题</strong>（对内 - 对自己、对外 - 对其他用户）</p><h4 id="这个项目能给我们带来什么？"><a href="#这个项目能给我们带来什么？" class="headerlink" title="这个项目能给我们带来什么？"></a>这个项目能给我们带来什么？</h4><ol><li>对别人的价值</li><li>兴趣</li><li>引流</li><li>做项目出视频、分享</li><li><strong>巩固所学知识</strong>、学习知识</li></ol><p><strong>程序员面试刷题讨论平台</strong></p><p>竞品：</p><ul><li>A 知乎：问答 | <strong>不垂直</strong></li><li>B LeetCode：算法刷题 | 主打的不是面试题，大家很少在上面讨论某一道题目</li><li>C 牛客网：讨论面经 + 刷题 |  主打的不是面试题，大家很少在上面讨论某一道题目，不能集中搜索面试题</li><li>D 其他现成的面试题库 | 不能讨论、个人维护（更新慢）</li></ul><p>A + B + C 进行融合，取长补短、精简化</p><p><strong>为什么轮子多？</strong></p><ol><li>每个产品都有优点、优缺点，面向的需求不一样</li><li>卷：API Fox、API Post、Eolink，竞争</li><li>大佬的任性</li></ol><h3 id="需求篇"><a href="#需求篇" class="headerlink" title="需求篇"></a>需求篇</h3><p>千万不要一上来就大而全，要先把核心功能 <strong>快速上线和验证</strong>，得到用户反馈</p><p>再进行下一步操作。</p><p><strong>不要闷头开发。</strong></p><p><strong>敏捷开发，小步快跑，慢慢加功能。</strong></p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>搜索面试题</p><p>分类查看面试题</p><p>在线查看题解、讨论题目</p><p>自由上传题目</p><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p>试卷功能</p><p>语音读题</p><p>视频题解</p><p>讨论区</p><p>调研、按优先级排期</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p><strong>人力成本</strong></p><p><strong>稳定</strong></p><ul><li><p>项目的量级（用户数、频率、做到什么地步？）</p></li><li><p>成本</p><ul><li>价格</li><li><strong>人力成本</strong> ：围绕着人来，团队对技术的熟悉程度；团队内要有一个问题解决者、领导者</li></ul></li><li><p><strong>生态</strong></p><p>怎么判断：去网上搜 github 的 star 数<strong>（开源）</strong>、业内的认可、文章</p><ul><li>Spring</li><li>Vue、React</li></ul></li><li><p>看作者（看公司）</p><ul><li>稳定性</li></ul></li><li><p><strong>目的</strong>：学习</p></li></ul><p>为什么选某些技术？</p><p>后端为啥不用 Java？</p><ul><li>效率第一：选用云开发，对 node.js</li><li>redis： 限流</li><li>Elasticsearch 搜索引擎技术：提高搜索的灵活性<strong>（贵）</strong></li><li>对象存储：存文件（用户图片、静态文件）</li></ul><p>为什么后来对技术架构做了升级？！将云开发重构为 Express？</p><ul><li>开发框架：Express（Express Session）</li></ul><p>云开发 Serverless 架构：每个函数都是一个系统，独立开发、独立更新、独立维护。多个函数共同组成完整系统。</p><blockquote><p>粒度比为服务更新。清晰、互不影响，云开发对云函数的支持很好。</p></blockquote><p>随着系统量级增大：</p><ol><li>云函数数量太多</li><li>云函数之间要共享变量比较麻烦</li><li>不方便增加统一的逻辑（比如增加请求拦截）</li></ol><p><strong>为什么重构为 Node 而不是 Java？</strong></p><p>方便迁移，降低成本</p><p>CDN 加速：<strong>如果是自己的项目，尽量不要用付费的</strong></p><p><strong>没有必要过度去技术选型</strong></p><p>用 Java 的 SpringBoot 做了一些微信公众号登录服务。</p><p>主要原因：有现成的 WxJava 库。</p><blockquote><p>对技术不了解的话，看下星球的用户中心项目。</p></blockquote><h3 id="设计篇"><a href="#设计篇" class="headerlink" title="设计篇"></a>设计篇</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>我使用云开发可视化界面操作，没有写 SQL 语句。</p><p>类型在 TypeScript 中也有定义，所以不会丢失。</p><blockquote><p>liyupi&#x2F;mianshiya-public&#x2F;src&#x2F;models&#x2F;类型定义</p></blockquote><h4 id="ES-索引-设计"><a href="#ES-索引-设计" class="headerlink" title="ES 索引 设计"></a>ES 索引 设计</h4><blockquote><p>搜索性能更好、更灵活的数据库</p></blockquote><p>es 安装 ik 中文分词器（免费）</p><p>有自己的词库。</p><p>索引 &#x3D;&gt; 理解为 MySQL 的表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&quot;aliases&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;question&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-string">&quot;search_analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;keyword&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>            <span class="hljs-string">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_max_word&quot;</span>,<br>        <span class="hljs-string">&quot;search_analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<br>        <span class="hljs-string">&quot;fields&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;keyword&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>            <span class="hljs-string">&quot;ignore_above&quot;</span>: <span class="hljs-number">256</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-string">&quot;reviewStatus&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;link&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;tags&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;links&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;userId&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;params&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;type&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;difficulty&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;meetNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;favourNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;shareNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;commentNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;thumbNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;viewNum&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;reviewMessage&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;priority&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;long&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;reviewerId&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;reviewTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;publishTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;_createTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;_updateTime&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;isDelete&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ES-和-MySQL-怎么同步（保证一致性）？"><a href="#ES-和-MySQL-怎么同步（保证一致性）？" class="headerlink" title="ES 和 MySQL 怎么同步（保证一致性）？"></a>ES 和 MySQL 怎么同步（保证一致性）？</h4><p>强一致性：</p><ol><li>事务双写：插入数据时两个库里都必须插入成功，才算成功，有任何一个失败就回滚（写入性能低）</li></ol><p>稍强一致性：</p><ol><li>监听 binlog：mySQL 在插入数据成功后，会写入 binlog 日志，我们只开一个程序（线程）需要监听 binlog 的变化，如果发现有插入，就也插入到 es（canal 技术）</li></ol><p>弱一致性：</p><ol><li>定时同步：每分钟读取 MySQL 中近 5 分钟内新增的数据，然后写入 ES（根据 id 判断已写入）</li></ol><p>定时检测和补偿程序：每天 &#x2F; 每小时去对比两个库，如果发现不一致，自动以数据库为主，或者发送告警，人工处理。</p><h3 id="团队开发篇"><a href="#团队开发篇" class="headerlink" title="团队开发篇"></a>团队开发篇</h3><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol><li>群众的力量（钞能力）</li></ol><p>公开招人帮忙上传题目、审核题目。</p><p><strong>定制规范很重要！</strong> 统一标准</p><ol start="2"><li>CV 的力量</li></ol><h3 id="团队怎么开发和管理"><a href="#团队怎么开发和管理" class="headerlink" title="团队怎么开发和管理"></a>团队怎么开发和管理</h3><ol><li><p>要有一个协作文档 &#x2F; 平台</p><p>分场景：小团队建议直接用腾讯文档。平台有使用成本、没有使用习惯、没那么方便。</p></li><li><p>日常沟通：了解成员工作情况、代码编写信息</p></li><li><p>团队代码怎么管理：</p><ol><li><p>GitHub 组织功能，私有仓库</p></li><li><p>不能所有同学都把直接提交到一起，要划分分支来区分每个人的代码</p><p>分支：</p><ol><li>每个人一个分支</li><li>每个需求一个分支（大项目）</li></ol></li><li><p>提交前 MR <strong>代码审查</strong></p></li></ol></li></ol><h3 id="技术源码篇"><a href="#技术源码篇" class="headerlink" title="技术源码篇"></a>技术源码篇</h3><p>前端</p><p>后端</p><p>其他服务</p><h3 id="上线篇"><a href="#上线篇" class="headerlink" title="上线篇"></a>上线篇</h3><ol><li><p>选择 Docker 方式部署，原因：</p><ol><li>腾讯云云开发支持快速 Docker 部署，很方便。</li><li>分布式部署，Docker 弹性伸缩很方便，不用自己输命令。</li></ol></li><li><p>测试</p><ol><li>拉了个 500 人内测群</li><li>产品反馈平台 —— 腾讯图小巢：</li></ol></li><li><p>开源前：写好 README.md 项目介绍文档，参考知名项目的文档仿写，可以复制别人的 README 改写</p><blockquote><p>小图标网站：<a href="https://shields.io/">https://shields.io/</a></p></blockquote></li></ol><h3 id="运营篇"><a href="#运营篇" class="headerlink" title="运营篇"></a>运营篇</h3><ol><li><p>关于网站维护，最麻烦的是内容，建议：</p><ol><li>大家找帮手 &#x2F; 合作来维护</li><li>完善系统，开发一些功能来降低维护成本</li></ol></li><li><p>持续看用户反馈</p></li><li><p>给网站添加统计分析功能（比如百度统计），每天查看一下用户访问数、<strong>用户来源</strong></p></li><li><p>关于网络安全</p><ol><li>少用收费的东西（比如 CDN），或者用免费的 CDN，降低不稳定因素</li><li>如果有条件，不要暴露你项目的真实 ip</li><li>DDOS 防不住！！！<strong>轻量级应用防护 31 一块钱一年防 10 G</strong></li></ol></li></ol><h3 id="推广篇"><a href="#推广篇" class="headerlink" title="推广篇"></a>推广篇</h3><p>不细讲。</p><ol><li>自己有流量，自己写文章视频</li><li>如果你完全没有流量，怎么推广？<ol><li>花钱</li><li>找类似的项目，去适当的、找机会去分享自己的项目（介绍你的项目）</li><li>友链</li><li>SEO：搜索引擎优化，别人能搜到你的网站</li></ol></li></ol><p>加入星球的同学，如果你有 <strong>足够好的</strong> 项目和点子，可以来找我</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/29/2022-04-02%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8&amp;%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%92%8C%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/"/>
    <url>/chaserblog/2024/04/29/2022-04-02%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8&amp;%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%92%8C%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建代码托管-前端监控平台"><a href="#搭建代码托管-前端监控平台" class="headerlink" title="搭建代码托管 &amp; 前端监控平台"></a>搭建代码托管 &amp; 前端监控平台</h1><h2 id="0-从-0-开服务器"><a href="#0-从-0-开服务器" class="headerlink" title="0. 从 0 开服务器"></a>0. 从 0 开服务器</h2><p>服务器类别：</p><ol><li>轻量应用服务器：<strong>快速</strong> 搭建应用、简单易用，提供了很多现成的镜像。省去了一些复杂的功能</li><li>云服务器：功能齐全、基础的服务器</li></ol><p>BAT 美团、华为、京东，1 年换一家去买，利用新用户优惠</p><p>宝塔 Linux（ Linux 运维面板 1 C 2 G 能带动）：</p><ol><li>企业：安全性，不建议用</li><li>个人：快速搭建应用（强烈推荐）</li></ol><p>怎么算带宽：</p><p>4 MB &#x3D;&gt; 1 MB</p><p>1MB * 1000，1.25MBps</p><h2 id="SSH-连接服务器"><a href="#SSH-连接服务器" class="headerlink" title="SSH 连接服务器"></a>SSH 连接服务器</h2><p>XShell</p><p>Putty（轻量，相对专业）</p><p>MobaXterm</p><p>FinalShell</p><h2 id="操作服务器"><a href="#操作服务器" class="headerlink" title="操作服务器"></a>操作服务器</h2><p>下载文件</p><h2 id="1-代码托管平台"><a href="#1-代码托管平台" class="headerlink" title="1. 代码托管平台"></a>1. 代码托管平台</h2><p>企业中，往往不会把项目放到公开的平台，一般自己搭建。</p><p>GitLab（占用资源比较多，功能丰富）、Gitea、Gogs</p><p>估计要装 10 分钟左右</p><p>平台对比：</p><ul><li><a href="https://about.gitlab.com/devops-tools/github-vs-gitlab/">https://about.gitlab.com/devops-tools/github-vs-gitlab/</a></li><li><a href="https://about.gitlab.com/devops-tools/gitea-vs-gitlab/">https://about.gitlab.com/devops-tools/gitea-vs-gitlab/</a></li><li><a href="https://about.gitlab.com/devops-tools/gogs-vs-gitlab/">https://about.gitlab.com/devops-tools/gogs-vs-gitlab/</a></li></ul><p>系统要求：CPU &gt;&#x3D; 2C，内存 &gt;&#x3D; 4 G</p><h2 id="2-前端监控系统（目前搭建未成功，大家学理论就好）"><a href="#2-前端监控系统（目前搭建未成功，大家学理论就好）" class="headerlink" title="2. 前端监控系统（目前搭建未成功，大家学理论就好）"></a>2. 前端监控系统（目前搭建未成功，大家学理论就好）</h2><p>监控的作用：</p><ol><li>监测系统的正常运行</li><li>还原案发现场，<strong>帮助定位和排查问题</strong></li><li>即时感知到系统的问题（告警），防止用户流失</li></ol><p>监控分类：</p><ol><li>系统性能监控（CPU、内存、带宽）偏底层，关注整体资源情况</li><li>网站运行情况（页面是否正常？当前访问人数？加载时长？当前消耗带宽等）应用层，关注网站运行情况</li><li>网站 <strong>数据</strong> 收集 &#x2F; 监控（网站 PV、UV、用户分布、年龄分布等），关注网站的用户情况，数据分析</li><li>行为监控（点了哪些按钮，操作路径），关注网站用户具体的行为，数据分析</li><li>错误监控（页面哪些内容报错了）帮助定位和排查问题，防止用户流失</li></ol><p>2、3、4 百度统计 &#x2F; Aegis</p><p>5 错误监控：Sentry（开源），badjs</p><p>Sentry 官网：<a href="https://sentry.io/welcome/">https://sentry.io/welcome/</a></p><p>Sandbox 可体验</p><p>自行搭建 Sentry：<a href="https://github.com/getsentry/self-hosted">https://github.com/getsentry/self-hosted</a></p><p>安装教程：<a href="https://blog.csdn.net/weixin_40230682/article/details/120737684">https://blog.csdn.net/weixin_40230682/article/details/120737684</a></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>容器技术，我们可以把应用（比如 jar 包）和应用依赖的环境（比如 java）都打包（封装）成镜像，想要使用 &#x2F; 部署应用时只需要下载镜像。而不需要自己重新准备环境。</p><p>镜像是死的，可分发（安装包）</p><p>容器应用是活的，根据安装包来启动容器</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>我们要启动多个 <strong>Docker</strong>，比如 MySQL + Java SpringBoot + Redis，自己一个个启动很麻烦</p><p>使用 Docker Compose 可以同时启动，节省时间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2024.4.29</title>
    <link href="/chaserblog/2024/04/29/2024-4-29/"/>
    <url>/chaserblog/2024/04/29/2024-4-29/</url>
    
    <content type="html"><![CDATA[<ol><li>从今天开始，每一天总结自己所学习的心得体会、及时的复盘与汇总，</li><li>每一周星期都要有一个周总结，因为自己看到了太多与别人的差距，特别是在青春榜样上看到了计算机学院宋杨同学的努力，报名了多个计算机算法赛事。</li></ol><p>定期（不定、可能会1个月等等）的维护自己的博客</p><p>今日学习任务：</p><ul><li><input disabled="" type="checkbox"> 信息检索工具vosviwer工具的使用</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2024/04/28/2024.4.28/"/>
    <url>/chaserblog/2024/04/28/2024.4.28/</url>
    
    <content type="html"><![CDATA[<p>(<a href="https://blog.fiveth.cc/p/bb32.html">如何用Hexo搭建个人博客? | Fiveth</a>)</p><p>优点<br>1、不需要服务器，github免费提供的托管服务<br>2、不需要域名，github同样提供了一个.io的域名<br>3、不用自己写xml、<a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a>提供了很多开源的博客模板。<br>4、便于维护更新，换风格直接换模板就行。</p><p>问题：</p><p>使用github作为服务器时，repo包中我用https:*******这个输入账号和密码一直显示连接错误</p><p>我改为用ssh连接时就好了。</p><p>配置SSH Key<br>注册完之后需要添加 SSH Key。 SSH Key是一个认证，让github识别绑定这台机器，允许这台机器无需密码提交，修改项目。执行如下命令：</p><p>生产新的SSH Key配置<br>在Git Bash(在任意文件夹中鼠标右击选择Git Bash Here打开)执行代码：</p><p><code>ssh-keygen -t rsa -C &quot;xxxxxxxxx@qq.com&quot;</code><br>上面的邮箱记得修改成你自己的，成功后会生成两个文件id_rsa（私钥） 以及id_rsa.pub（公钥）。 然后找到这两个文件，默认都在C盘 &gt; 用户 &gt; xxx &gt; .ssh 里面（xxx是计算机名字，我这里是Administrator）</p><p><img src="https://img-blog.csdnimg.cn/648d8c72050c46a9bf7f2dd252b57de6.png" alt="img"></p><p>然后用文本编辑器把id_rsa_pub（公钥）这个文件打开，全选复制出来； 然后打开在github上添加SSH Key，登录github账号，点击右上角用户头像，选择setting（设置）&gt; SSH and GPG keys &gt; NewSSH key</p><p><img src="https://img-blog.csdnimg.cn/1afa3b66e2114b5ba795545fa1bad8b0.png" alt="img"></p><p>然后把刚才复制的内容粘贴到key这里就可以了.</p><p>3.1. 测试是否成功<br><code>$ ssh -T git@github.com</code> # 注意邮箱地址不用改<br>复制</p><p>如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><p><code>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</code></p><p>看到这个信息说明SSH已配置成功！<br>————————————————</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428085806628.png" alt="image-20240428085806628"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428090043539.png" alt="image-20240428090043539"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428132801443.png" alt="image-20240428132801443"></p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428132842085.png" alt="image-20240428132842085"></p><p>搭建个人博客</p><h1 id="项目展示】"><a href="#项目展示】" class="headerlink" title="项目展示】"></a>项目展示】</h1><blockquote><p>【展示地址】：<a href="https://zhangruyi3906.github.io/chaserblog/">chaserblog | 我的博客 (zhangruyi3906.github.io)</a>【注册、下载与安装】</p></blockquote><h2 id="【1】gitee注册"><a href="#【1】gitee注册" class="headerlink" title="【1】gitee注册"></a>【1】gitee注册</h2><blockquote><p>【gitee官方注册地址】：<a href="https://gitee.com/signup">https://gitee.com/signup</a></p></blockquote><h2 id="【2】Typora下载"><a href="#【2】Typora下载" class="headerlink" title="【2】Typora下载"></a>【2】Typora下载</h2><blockquote><p>【下载地址】：<a href="https://www.typora.io/">https://www.typora.io/</a></p></blockquote><h2 id="【3】node安装"><a href="#【3】node安装" class="headerlink" title="【3】node安装"></a>【3】node安装</h2><blockquote><p>【下载地址】：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>【安装过程】：选择磁盘可以切换到其他盘，然后一直下一步就好了。（这里演示是切换D盘）</p></blockquote><h2 id="【4】git安装"><a href="#【4】git安装" class="headerlink" title="【4】git安装"></a>【4】git安装</h2><blockquote><p>【下载地址】：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>【安装过程】：选择磁盘可以切换到其他盘，然后一直下一步就好了。（这里演示是切换D盘）</p></blockquote><h1 id="【本地博客搭建】"><a href="#【本地博客搭建】" class="headerlink" title="【本地博客搭建】"></a>【本地博客搭建】</h1><h2 id="【1】hexo-cli安装"><a href="#【1】hexo-cli安装" class="headerlink" title="【1】hexo-cli安装"></a>【1】hexo-cli安装</h2><blockquote><p>npm install hexo-cli -g</p><p>或</p><p>先安装cnpm，然后利用cnpm安装hexo-cli</p><p>npm install cnpm</p><p>cnpm install hexo-cli -g</p></blockquote><h2 id="【2】初始化hexo项目"><a href="#【2】初始化hexo项目" class="headerlink" title="【2】初始化hexo项目"></a>【2】初始化hexo项目</h2><blockquote><p>hexo init blog</p></blockquote><h2 id="【3】项目启动"><a href="#【3】项目启动" class="headerlink" title="【3】项目启动"></a>【3】项目启动</h2><blockquote><p>永远的hexo三件套：</p><p>-清除生成的页面相关内容</p><p>hexo clean</p><p>-构建生成的页面相关内容</p><p>hexo g</p><p>-项目启动</p><p>hexo s</p></blockquote><p>会看到这样的页面，证明本地hexo默认模板配置成功，<br><img src="https://img-blog.csdnimg.cn/img_convert/b26252eb40bc11f27ab2808484f82dd0.png" alt="wapchief"><br>到这一步如果将hexo放到github page，那么使用github.io访问的将是一个默认的页面。下面我们要把他diy成自己的博客，包括导入模板主题等。</p><p>安装主题<br>关于主题大多都是以压缩包形式，可以去github上搜hexo theme，会出来很多，里面都有介绍。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d99c1f1811f3af2535ab2d92d869563b.png" alt="hexo-theme主题">比如我们比如我们要用第一个。<br>可以通过两种方法，这里我直接使用git命令完成，具体请参考next官方文档：<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a><br>继续在我们的本地hexo目录输入</p><p>git clone <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a> themes&#x2F;next</p><h1 id="【添加主题模板Fluid】"><a href="#【添加主题模板Fluid】" class="headerlink" title="【添加主题模板Fluid】"></a>【添加主题模板Fluid】</h1><h2 id="【1】在blog-themes目录下"><a href="#【1】在blog-themes目录下" class="headerlink" title="【1】在blog\themes目录下"></a>【1】在blog\themes目录下</h2><blockquote><p>去gitee上下载Fluid主题模板（github上真的太慢了有时候还下不下来。）</p><p>git clone <a href="https://gitee.com/mirrors/hexo-theme-fluid.git">https://gitee.com/mirrors/hexo-theme-fluid.git</a></p></blockquote><h2 id="【2】修改-conf-yml"><a href="#【2】修改-conf-yml" class="headerlink" title="【2】修改_conf.yml"></a>【2】修改_conf.yml</h2><blockquote><p>找到theme，替换为对应下载主题名字（在themes下载下来的文件夹名）</p><p>theme: hexo-theme-fluid</p><p>此时我出现了以下问题：</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428144618381.png" alt="image-20240428144618381"></p></blockquote><p>不能够通过老老实实的安装上述提及的相关缺失的包来解决问题，</p><p>而是可以通过在命令行中输入npm install 这个命令来解决问题</p><p>这个方法简便且快速和高效。</p><h2 id="【3】修改为主题语言为中文"><a href="#【3】修改为主题语言为中文" class="headerlink" title="【3】修改为主题语言为中文"></a>【3】修改为主题语言为中文</h2><blockquote><p>在blog目录下的_conf.yml，找到文件内容里的language替换为以下</p><p>language: zh-CN #指定语言，会影响主题显示的语言，按需修改</p></blockquote><h2 id="【4】生成about页面"><a href="#【4】生成about页面" class="headerlink" title="【4】生成about页面"></a>【4】生成about页面</h2><blockquote><p>在blog路径下，执行指令（管理员cmd操作）</p><p>hexo new page about</p><p>创建成功后，去到blog\source\about\index.md，添加layout属性，以为为index.md里所有内容</p><p>-–<br>title: about<br>date: 2021-10-01 14:53:12<br>layout: about<br>-–</p></blockquote><p>修改内容<br>内容较多建议参考官方文档<br><a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a><br>修改完之后，可以重新执行hexo s在浏览器查看效果。并确认无误，包括以后需要添加文章，或者更新主题等，都建议先在本地查看无误再远程部署。<br>根_config.yml文件中</p><h1 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h1><p><code>title: 网站标题</code><br><code>subtitle: 副标题</code><br><code>description: 个人签名</code><br><code>author: 姓名</code><br><code>language: zh-Hans</code><br><code>timezone:</code></p><h1 id="【图片、内容等修改】"><a href="#【图片、内容等修改】" class="headerlink" title="【图片、内容等修改】"></a>【图片、内容等修改】</h1><h2 id="【1】添加友链导航"><a href="#【1】添加友链导航" class="headerlink" title="【1】添加友链导航"></a>【1】添加友链导航</h2><blockquote><p>【参考地址】：<a href="https://hexo.fluid-dev.com/docs/guide/#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5">https://hexo.fluid-dev.com/docs/guide/#%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5</a></p><p>在blog\themes\hexo-theme-fluid目录下的_config.yml内容中去掉 navbar导航栏 menu下的link 前的注释</p><p>menu:<br>- { key: “home”, link: “&#x2F;“, icon: “iconfont icon-home-fill” }<br>- { key: “archive”, link: “&#x2F;archives&#x2F;“, icon: “iconfont icon-archive-fill” }<br>- { key: “category”, link: “&#x2F;categories&#x2F;“, icon: “iconfont icon-category-fill” }<br>- { key: “tag”, link: “&#x2F;tags&#x2F;“, icon: “iconfont icon-tags-fill” }<br>- { key: “about”, link: “&#x2F;about&#x2F;“, icon: “iconfont icon-user-fill” }<br>- { key: “links”, link: “&#x2F;links&#x2F;“, icon: “iconfont icon-link-fill” }</p></blockquote><h2 id="【2】改页面标题和页面前的小icons"><a href="#【2】改页面标题和页面前的小icons" class="headerlink" title="【2】改页面标题和页面前的小icons"></a>【2】改页面标题和页面前的小icons</h2><blockquote><p>blog目录下的_config.yml的内容中</p><p>原来是有title: Hexo</p><p>改为title: 阿怼博客</p></blockquote><blockquote><p>blog\themes\hexo-theme-fluid\主题目录下的_config.yml的内容中</p><p>navbar:</p><p> blog_title: “Fluid”</p><p>改为</p><p>navbar:</p><p> blog_title: “阿怼博客”</p><p>同样文件，找到首页（index）</p><p>index:<br># 首页 Banner 头图，可以是相对路径或绝对路径，以下相同<br># Path of Banner image, can be a relative path or an absolute path, the same on other pages<br>banner_img: &#x2F;img&#x2F;default.png</p><p># 头图高度，屏幕百分比<br># Height ratio of banner image<br># Available: 0 - 100<br>banner_img_height: 100</p><p># 头图黑色蒙版的不透明度，available: 0 - 1.0， 1 是完全不透明<br># Opacity of the banner mask, 1.0 is completely opaque<br># Available: 0 - 1.0<br>banner_mask_alpha: 0.3</p><p># 首页副标题的独立设置<br># Independent config of home page subtitle<br>slogan:<br>enable: true</p><p># 为空则按 hexo config.subtitle 显示<br># If empty, text based on <code>subtitle</code> in hexo config<br>text: “An elegant Material-Design theme for Hexo”</p><p>这里的text改成你想改的</p><p>text: “我叫阿怼，南方阿怼，一个热爱计算机更热爱祖国的南方人。”</p></blockquote><blockquote><p>修改icons或者其他图片，找到blog\themes\hexo-theme-fluid\source\img目录下（注意不是blog\public\img目录下的，public的目录文件不需要改，因为每次hexo clean都会删除了，然后hexo g再重新创建）</p><p>在这里面替换成你想要的图片、icon就好了。</p></blockquote><h1 id="【-md文件博客上传】"><a href="#【-md文件博客上传】" class="headerlink" title="【.md文件博客上传】"></a>【.md文件博客上传】</h1><blockquote><p>首先，写好一个.md，作为你的博客了。</p><p>也可以直接在blog目录下，执行以下指令生成.md，再进行对该.md进行完善内容。</p><p>hexo new “《我的第一个日记》”</p><p>这时候就生成在blog\source_posts目录下了</p><p>你已经写好了.md，也可以直接移动到这里，然后再重新启动hexo三件套就好了。（hexo clean、hexo g、hexo s）</p></blockquote><blockquote><p>标签添加</p><p>在你想添加标签的.md文件中，添加tags: “标签名”</p><p>-–<br>title: 《个人博客搭建》<br>date: 2021-10-01 15:35:44<br>tags: “《博客搭建相关》”<br>-–</p></blockquote><h1 id="【宠物插件】"><a href="#【宠物插件】" class="headerlink" title="【宠物插件】"></a>【宠物插件】</h1><blockquote><p>npm install –save hexo-helper-live2d<br>或<br>cnpm install –save hexo-helper-live2d</p><p>1、cnpm install –save hexo-helper-live2d<br>2、<a href="https://www.npmjs.com/package/hexo-helper-live2d">live2d插件</a><br>3、安装合适的宠物cnpm install live2d-widget-model-chitose<br>4、在博客_config.yml配置文件中（不是themes里的）添加即可</p></blockquote><p>使用命令下载插件：npm install –save hexo-helper-live2d</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-2.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-2.png" alt="img"></a></p><p>使用命令下载模型：npm install live2d-widget-model-hijiki</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-3.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-3.png" alt="img"></a></p><p>在blog目录下，配置_config.yml，找到deploy，添加以下代码</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-4.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-4.png" alt="img"></a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span> <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span> <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span> <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 标签模式, 是否仅替换 live2dtag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">log:</span> <span class="hljs-literal">false</span> <br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-hijiki</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否在移动设备上显示</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span><br></code></pre></td></tr></table></figure><h1 id="9-鼠标特效"><a href="#9-鼠标特效" class="headerlink" title="9. 鼠标特效"></a>9. 鼠标特效</h1><p>在主题目录下，找到source&#x2F;js文件，打开后创建，一个js文件，名字可以自定义</p><p><a href="https://gitee.com/nanyanxin/tuc/raw/master/image/12-5.png"><img src="https://gitee.com/nanyanxin/tuc/raw/master/image/12-5.png" alt="img"></a></p><p>然后添加一下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*网页鼠标点击特效（爱心）*/</span><br>!<span class="hljs-keyword">function</span> (<span class="hljs-params">e, t, a</span>) &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">r</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>; e &lt; s.<span class="hljs-property">length</span>; e++) s[e].<span class="hljs-property">alpha</span> &lt;= <span class="hljs-number">0</span> ? (t.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(s[e].<span class="hljs-property">el</span>), s.<span class="hljs-title function_">splice</span>(e, <span class="hljs-number">1</span>)) : (s[e].<span class="hljs-property">y</span>--, s[e].<span class="hljs-property">scale</span> += <span class="hljs-number">.004</span>, s[e].<span class="hljs-property">alpha</span> -= <span class="hljs-number">.013</span>, s[e].<span class="hljs-property">el</span>.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> = <span class="hljs-string">&quot;left:&quot;</span> + s[e].<span class="hljs-property">x</span> + <span class="hljs-string">&quot;px;top:&quot;</span> + s[e].<span class="hljs-property">y</span> + <span class="hljs-string">&quot;px;opacity:&quot;</span> + s[e].<span class="hljs-property">alpha</span> + <span class="hljs-string">&quot;;transform:scale(&quot;</span> + s[e].<span class="hljs-property">scale</span> + <span class="hljs-string">&quot;,&quot;</span> + s[e].<span class="hljs-property">scale</span> + <span class="hljs-string">&quot;) rotate(45deg);background:&quot;</span> + s[e].<span class="hljs-property">color</span> + <span class="hljs-string">&quot;;z-index:99999&quot;</span>);<span class="hljs-title function_">requestAnimationFrame</span>(r)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">n</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">var</span> t = <span class="hljs-string">&quot;function&quot;</span> == <span class="hljs-keyword">typeof</span> e.<span class="hljs-property">onclick</span> &amp;&amp; e.<span class="hljs-property">onclick</span>;e.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;t &amp;&amp; <span class="hljs-title function_">t</span>(), <span class="hljs-title function_">o</span>(e)&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">o</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-keyword">var</span> a = t.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);a.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;heart&quot;</span>, s.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">el</span>: a,<span class="hljs-attr">x</span>: e.<span class="hljs-property">clientX</span> - <span class="hljs-number">5</span>,<span class="hljs-attr">y</span>: e.<span class="hljs-property">clientY</span> - <span class="hljs-number">5</span>,<span class="hljs-attr">scale</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">alpha</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">color</span>: <span class="hljs-title function_">c</span>()&#125;), t.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(a)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">i</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-keyword">var</span> a = t.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;style&quot;</span>);a.<span class="hljs-property">type</span> = <span class="hljs-string">&quot;text/css&quot;</span>;<span class="hljs-keyword">try</span> &#123;a.<span class="hljs-title function_">appendChild</span>(t.<span class="hljs-title function_">createTextNode</span>(e))&#125; <span class="hljs-keyword">catch</span> (t) &#123;a.<span class="hljs-property">styleSheet</span>.<span class="hljs-property">cssText</span> = e&#125;t.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(a)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;rgb(&quot;</span> + ~~(<span class="hljs-number">255</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">&quot;,&quot;</span> + ~~(<span class="hljs-number">255</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">&quot;,&quot;</span> + ~~(<span class="hljs-number">255</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()) + <span class="hljs-string">&quot;)&quot;</span>&#125;<span class="hljs-keyword">var</span> s = [];e.<span class="hljs-property">requestAnimationFrame</span> = e.<span class="hljs-property">requestAnimationFrame</span> || e.<span class="hljs-property">webkitRequestAnimationFrame</span> || e.<span class="hljs-property">mozRequestAnimationFrame</span> || e.<span class="hljs-property">oRequestAnimationFrame</span> || e.<span class="hljs-property">msRequestAnimationFrame</span> || <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<span class="hljs-built_in">setTimeout</span>(e, <span class="hljs-number">1e3</span> / <span class="hljs-number">60</span>)&#125;, <span class="hljs-title function_">i</span>(<span class="hljs-string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>), <span class="hljs-title function_">n</span>(), <span class="hljs-title function_">r</span>()&#125;(<span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">document</span>);<br></code></pre></td></tr></table></figure><p>在footer标签内添加以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/click_lihua.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="【提交搭建的博客到Gitee上，正式完成博客搭建】"><a href="#【提交搭建的博客到Gitee上，正式完成博客搭建】" class="headerlink" title="【提交搭建的博客到Gitee上，正式完成博客搭建】"></a>【提交搭建的博客到Gitee上，正式完成博客搭建】</h1><blockquote><p>修改blog_config.yml配置文件的站点地址（找到deploy）：</p><p>deploy:<br>type: git<br>repo:<br>branch: master<br>live2d: <a href="https://gitee.com/southern-adui/southern-adui.git">https://gitee.com/southern-adui/southern-adui.git</a><br>enable: true</p><p>安装git上传助手（如果有git设置过有帐号密码，就去先对git进行操作）</p><p>npm install hexo-deployer-git –save<br>或<br>cnpm install hexo-deployer-git –save</p><p>完成后，输入</p><p>hexo d</p></blockquote><blockquote><p>git的操作<br>查看配置信息： $ git config –list<br>修改用户名<br>git config –global user.name “xxxx(新的用户名)”<br>修改密码<br>git config –global user.password “xxxx(新的密码)”<br>修改邮箱<br>git config –global user.email “<a href="mailto:xxxx@xxx.com">xxxx@xxx.com</a>(新的邮箱)”<br>清除掉缓存在git中的用户名和密码<br>git credential-manager uninstall</p></blockquote><p>最后注意一下，按照以上核心步骤弄出自己的博客后如果没有加载出来css等，可以稍等片刻再试一下。</p><p>可能会收到网络因素的影响。（至少要2分钟左右）</p><p>问题：</p><p>鼠标点击礼花形状的效果（这个问题我找了很久。。。。）</p><p>最后还是在看了同组中的样例后才发现的，网上没有现成的教程。</p><p>总结：遇到问题还是不能太死板、死磕，要想方设法的去解决问题。</p><p><img src="F:/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/typora/assets/image-20240428155704328.png" alt="image-20240428155704328"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-11%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-11%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>本次直播内容：</p><ol><li>上次直播问题总结✔</li><li>用户库表设计✔</li><li>完成登录注册的前后端开发</li><li>完成用户管理后台的前后端开发</li><li>其他（根据时间弹性安排）</li></ol><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min</p><ol><li>后端       20min <ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min</li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol><li>前端</li><li>后端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><hr><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p><strong>登录 &#x2F; 注册</strong> 20min</p><ol><li>前端</li><li>后端</li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol><li>前端</li><li>后端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>本次直播内容：</p><ol><li>上次直播问题总结✔</li><li>用户库表设计✔</li><li>完成登录注册的前后端开发</li><li>完成用户管理后台的前后端开发</li><li>其他（根据时间弹性安排）</li></ol><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-03-25%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E7%BB%88%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-03-25%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E7%BB%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>终 - 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%AB%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-04-04%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E6%9C%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>末 - 直播内容</p><ol><li>开发用户注销前端 7 分钟 &#x2F; 后端 3 分钟 √</li><li>补充用户注册校验逻辑前端 10 分钟 &#x2F; 后端 10 分钟 √</li><li>后端代码优化 20 - 30 min</li><li>前端代码优化 5 - 10 min</li><li>项目部署上线 1h<ol><li>买服务器   10 min</li><li>原生部署20 - 30 min</li><li>容器部署    20 - 30 min</li><li>绑定域名    5 min</li><li><strong>排查问题</strong></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-03%20%E5%B0%9D%E9%B2%9CAI%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6Copilot%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/2022-04-03%20%E5%B0%9D%E9%B2%9CAI%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%8F%92%E4%BB%B6Copilot%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="体验-AI-自动写代码插件-Copilot"><a href="#体验-AI-自动写代码插件-Copilot" class="headerlink" title="体验 AI 自动写代码插件 Copilot"></a>体验 AI 自动写代码插件 Copilot</h1><p>基于 GitHub 上开源的亿级别的代码，训练 AI 模型，自动生成代码。</p><p>数据量能够决定你 AI 模型精度的上限</p><p>而算法是帮助你不断逼近这个上限</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>自动补全</li><li>根据注释自动生成代码</li><li>自动推断、生成类似的代码</li><li>自动生成测试</li><li>自动生成代码建议，提供选择</li></ol><p>根据注释生成注释？</p><p>插件支持 VS Code、JetBrains 全家桶、Visual Studio</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>申请（<a href="https://copilot.github.com/%EF%BC%89">https://copilot.github.com/）</a></p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><ol><li>逻辑类代码（比如校验，80 分）</li><li>重复代码量越少，推荐越不准</li><li>固定格式的、通用的代码（java 40 分）大家写来写去都是一样的 &#x2F; 类似的代码</li><li>业务逻辑（用处不大)</li></ol><p>提示代码的准确度和模型本身、模型分析依赖的环境 &#x2F; 上下文有关。</p><p>以前：写代码，查百度，开发者</p><p>现在：写注释，翻生成的代码是否靠谱，监管者</p><p><strong>AI 辅助程序员</strong></p><p>自己能掌控代码再用</p><p>适合一些工具类（日期转换、对象转化，校验），提高效率 &#x3D;&gt; 不要拿来生成一些本来就看不懂的代码</p><p>不要在企业和敏感项目中使用，可能有安全隐患！</p><p>欢迎加入鱼皮的编程知识星球：dogyupi.com</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-17%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E9%83%A8%E7%BD%B2%EF%BC%89%20/"/>
    <url>/chaserblog/2024/04/28/2022-04-17%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E9%83%A8%E7%BD%B2%EF%BC%89%20/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>GitLab 地址：<a href="http://gitlab.code-nav.cn/">http://gitlab.code-nav.cn/</a></p><p>部署 - 直播内容</p><ol><li>多环境 5 - 10min</li><li>项目部署上线 1h √<ul><li>原始前端 &#x2F; 后端项目</li><li>宝塔 Linux </li><li>容器</li><li>容器平台</li></ul></li><li>前后端的联调 —— 跨域 15 min</li><li>用户中心项目扩展和规划（优化点）5 - 10 min</li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端部署方式"><a href="#前端部署方式" class="headerlink" title="前端部署方式"></a>前端部署方式</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 后端</span><br><span class="hljs-attribute">docker</span> build -t user-center-backend:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br><br><span class="hljs-comment"># 前端</span><br><span class="hljs-attribute">docker</span> build -t user-center-front:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>前端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; </p><p>服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如果解决跨域</p><ol><li>把域名、端口改成相同的</li></ol><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><ol start="2"><li><p>网关支持（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改后端服务</p><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/2022-04-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%E7%BA%BF%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/2022-04-18%20%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E4%B8%8A%E7%BA%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h1><p>完整了解做项目的思路，接触一些企业级的开发技术</p><p>（尽量少写代码）目标：大家之后都能轻松做出管理系统</p><p>GitLab 地址：<a href="http://gitlab.code-nav.cn/">http://gitlab.code-nav.cn/</a></p><p>部署 - 直播内容</p><ol><li>多环境 5 - 10min</li><li>项目部署上线 1h √<ul><li>原始前端 &#x2F; 后端项目</li><li>宝塔 Linux </li><li>容器</li><li>容器平台</li></ul></li><li>前后端的联调 —— 跨域 15 min</li><li>用户中心项目扩展和规划（优化点）5 - 10 min</li></ol><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端部署方式"><a href="#前端部署方式" class="headerlink" title="前端部署方式"></a>前端部署方式</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h2 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h2><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 后端</span><br><span class="hljs-attribute">docker</span> build -t user-center-backend:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br><br><span class="hljs-comment"># 前端</span><br><span class="hljs-attribute">docker</span> build -t user-center-front:v0.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>前端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; </p><p>服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如果解决跨域</p><ol><li>把域名、端口改成相同的</li></ol><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><ol start="2"><li><p>网关支持（Nginx）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改后端服务</p><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol></li></ol><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><ol><li><p>通用返回对象 √</p><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义错误码</p></li><li><p>返回类支持返回正常和错误</p></li></ul></li><li><p>封装全局异常处理</p><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器</p><p>作用：</p><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><p>实现：</p><ol><li>Spring AOP：在调用方法前后进行额外的处理</li></ol></li></ol></li><li><p>todo 全局请求日志和登录校验</p></li></ol><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><blockquote><p>直播 0：00 - 0：35 踩坑过程，可跳过</p></blockquote><ol><li><p>对接后端的返回值，取 data</p></li><li><p>全局响应处理：</p><ol><li><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p></li><li><p>优势：不用在每个接口请求中都去写相同的逻辑</p></li><li><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020</a></p><p>）如果你用 <strong>axios</strong>，参考 axios 的文档。创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p></li></ol></li></ol><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，自觉</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><p>终- 直播内容：</p><ol><li>完成注册功能的前端开发 15 - 20min √</li><li>获取用户的登录态，<strong>获取当前登录用户信息接口</strong>  √</li><li>完成用户管理后台的前端开发 20 - 30 min</li><li>前端代码瘦身 &amp; 优化 20min</li><li>后端代码优化 20min</li><li>新需求 - 讨论及开发星球用户校验（简易） —</li><li></li><li>项目扩展思路</li></ol><h3 id="Ant-Design-Pro（Umi-框架）"><a href="#Ant-Design-Pro（Umi-框架）" class="headerlink" title="Ant Design Pro（Umi 框架）"></a>Ant Design Pro（Umi 框架）</h3><p>app.tsx 项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</p><p>access.ts 控制用户的访问权限</p><p>首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="待优化点-todo"><a href="#待优化点-todo" class="headerlink" title="待优化点 todo"></a>待优化点 todo</h3><ul><li>前端密码重复提示（可能有别的优化方式）</li><li>注册没有友好的提示</li><li>用户注销</li><li>优化查询接口（支持更多查询）</li></ul><p>MFSU：前端编译优化</p><p>Ant Design 组件库 &#x3D;&gt; React </p><p>Ant Design Procomponents &#x3D;&gt; Ant Design</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; Ant Design、React、Ant Design Procomponents、其他的库</p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt;</p><p>初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署&#x3D;&gt; 发布</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li><strong>登录 &#x2F; 注册</strong></li><li><strong>用户管理（仅管理员可见）对用户的查询或者修改</strong></li><li>用户校验（ <strong>仅星球用户</strong> ）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol><li><p>初始化项目</p><ol><li><p>前端初始化     20 min</p><ol><li>初始化项目 ✔</li><li>引入一些组件之类的 ✔</li><li>框架介绍 &#x2F; 瘦身 ✔</li></ol></li><li><p>后端初始化  20 min</p><ol><li>准备环境（MySQL 之类的）验证 MySQL 是否安装成功 - 连接一下 ✔</li><li>初始化后端项目，引入框架（整合框架）✔</li></ol></li></ol></li><li><p>数据库设计</p></li><li><p><strong>登录 &#x2F; 注册</strong> 20min ✔</p><ol><li>后端       20min ✔<ol><li>规整项目目录 2 min</li><li>实现基本数据库操作（操作 user 表）<ol><li>模型 user 对象 &#x3D;&gt; 和数据库的字段关联，自动生成</li></ol></li><li>写登录逻辑</li></ol></li><li>前端       20min<ol><li>删除多余代码</li></ol></li></ol></li><li><p>用户管理（仅管理员可见） 20 min</p><ol start="2"><li>后端 ✔</li><li>前端</li></ol></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>三种初始化 Java 项目的方式</p><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计-30-min"><a href="#数据库设计-30-min" class="headerlink" title="数据库设计 30 min"></a>数据库设计 30 min</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库，代替人工</p><p>什么是设计数据库表？</p><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？</p><p>表与表之间的关联~</p><p><strong>性别是否需要加索引？</strong></p><p>用户表：</p><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p> MyBatisX 插件，自动根据数据库生成 domain 实体对象、mapper（操作数据库的对象）、mapper.xml（定义了 mapper对象和数据库的关联，可以在里面自己写 SQL）、service（包含常用的增删改查）、serviceImpl（具体实现 service）</p><h3 id="今日计划"><a href="#今日计划" class="headerlink" title="今日计划"></a>今日计划</h3><ol><li>开发完成后端登录功能 20 min（单机登录 &#x3D;&gt; 后续改造为分布式 &#x2F; 第三方登录）✔</li><li>开发后端用户的管理接口 5 min（用户的查询 &#x2F; 状态更改）✔</li><li>后端接口测试 ✔</li><li>开发前端用户登录注册功能 40 min - 1h</li><li>讨论如何校验用户（星球的小伙伴可以使用）</li></ol><h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h2 id="控制层-Controller-封装请求"><a href="#控制层-Controller-封装请求" class="headerlink" title="控制层 Controller 封装请求"></a>控制层 Controller 封装请求</h2><p>application.yml 指定接口全局 api</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</p><p>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</p><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><p>（javaweb 这一块）</p><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理接口"><a href="#用户管理接口" class="headerlink" title="用户管理接口"></a>用户管理接口</h2><p>！！！ 必须鉴权</p><ol><li>查询用户<ol><li>允许根据用户名查询</li></ol></li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><p>先做设计</p><p>代码实现</p><p>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</p><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求</p><p>前端 ajax 来请求后端</p><p>axios 封装了 ajax</p><p>request 是 ant design 项目又封装了一次</p><p>追踪 request 源码：用到了 umi 的插件、requestConfig 是一个配置</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么搞代理？</p><p>Nginx 服务器</p><p>Node.js 服务器</p><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World练习</title>
    <link href="/chaserblog/2024/04/28/hello-world/"/>
    <url>/chaserblog/2024/04/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>练习测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/yuwork-%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/yuwork-%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95%E5%B7%A5%E5%85%B7%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="开发记录和分析工作的工具"><a href="#开发记录和分析工作的工具" class="headerlink" title="开发记录和分析工作的工具"></a>开发记录和分析工作的工具</h1><blockquote><p>by 程序员鱼皮 <a href="https://yupi.icu/">知识星球</a></p><p>直播回放会发布到编程学习圈子：<a href="https://yupi.icu/">https://yupi.icu</a></p><p>直播回放 + 项目源码 + 笔记：<a href="https://t.zsxq.com/03J6URbem">https://t.zsxq.com/03J6URbem</a> （加入星球可见）</p></blockquote><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>个人可以记录自己每日的工作、工作时长、工作打标签（工作进度、目标）</li><li>可以根据日历查看自己的工作（视图）</li><li>可以对一定周期内的工作进行分析（饼图、折线图、柱状图）</li></ol><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><h4 id="第一次开发"><a href="#第一次开发" class="headerlink" title="第一次开发"></a>第一次开发</h4><p>完整基本前后端搭建和联调，实现任务创建和查询功能</p><h4 id="第二次开发"><a href="#第二次开发" class="headerlink" title="第二次开发"></a>第二次开发</h4><ol><li>优化样式</li><li>分页检索</li></ol><h3 id="第三次开发"><a href="#第三次开发" class="headerlink" title="第三次开发"></a>第三次开发</h3><ol><li>增删改 <strong>查</strong>（搜索 &#x2F; 排序）</li></ol><h3 id="下次开发"><a href="#下次开发" class="headerlink" title="下次开发"></a>下次开发</h3><ol><li>登录</li><li>管理员分析，分析所有用户（指定范围用户）的工作情况</li><li>任务拖动</li><li>多种视图布局</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ol><li>前端：Vue 3 + Vite 2 + Ant Design Vue（桌面端为主）<ul><li>数据可视化：AntV G2</li><li>日期处理库：Day.js</li></ul></li><li>后端：SpringBoot + Redis 分布式登录</li></ol><h2 id="前端整合"><a href="#前端整合" class="headerlink" title="前端整合"></a>前端整合</h2><ol><li>Vite 初始化</li><li>Vue Router 整合，添加路由功能</li><li>Ant Design Vue 整合</li><li>整合 AntV G2，支持实例图表</li></ol><h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><ol><li>新增记录：表单页</li><li>展示记录：列表页</li><li>分析</li></ol><h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><ol><li>拉取通用模板，已经整合好了常用框架、用户登录用例等</li><li>设计库表</li></ol><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="工作表"><a href="#工作表" class="headerlink" title="工作表"></a>工作表</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">name:</span> <span class="hljs-type">string</span>;<br><span class="hljs-symbol">description:</span> <span class="hljs-type">string</span>;<br><span class="hljs-symbol">duration:</span> number;<br><span class="hljs-symbol">tags:</span> <span class="hljs-type">string</span>[];<br>planTime?: <span class="hljs-type">Date</span>;<br><span class="hljs-symbol">createTime:</span> <span class="hljs-type">Date</span>;<br><span class="hljs-symbol">updateTime:</span> <span class="hljs-type">Date</span>;<br></code></pre></td></tr></table></figure><p>id bigint</p><p>任务名称 varchar</p><p>描述 varchar</p><p>时长 duration int</p><p>tags  varchar</p><p>planTime 计划时间 datetime</p><p>创建时间  datetime</p><p>更新时间  datetime</p><p>逻辑删除 tinyint 0 &#x2F; 1</p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 任务<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> work<br>(<br>    id          <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>    name        <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;任务名称&#x27;</span>,<br>    description text               <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    duration    <span class="hljs-type">int</span>                <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;时长（秒）&#x27;</span>,<br>    tags        <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;标签列表json&#x27;</span>,<br>    planTime    datetime comment <span class="hljs-string">&#x27;计划时间&#x27;</span>,<br>    createTime  datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime  datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete    tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>) comment <span class="hljs-string">&#x27;任务&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><ol><li>校验参数</li><li>插入数据到数据库中</li></ol><p>查询任务列表</p><p>直接用接口文档在线测试</p><h3 id="查询列表（分页）"><a href="#查询列表（分页）" class="headerlink" title="查询列表（分页）"></a>查询列表（分页）</h3><p>MyBatis Plus 的 Page 方法</p><h2 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h2><h3 id="分页实现"><a href="#分页实现" class="headerlink" title="分页实现"></a>分页实现</h3><ol><li>前端分页（一次请求全量数据，前端去计算每一页展示什么）</li><li>后端分页（一次请求一页的数据，前端页面时重新发请求去加载）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E6%8A%93%E9%B1%BC-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%AF%84%E8%AE%BA%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E6%8A%93%E9%B1%BC-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E8%AF%84%E8%AE%BA%E5%8C%BA%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="写一个小项目-——-抓鱼"><a href="#写一个小项目-——-抓鱼" class="headerlink" title="写一个小项目 —— 抓鱼"></a>写一个小项目 —— 抓鱼</h1><p><strong>直播回放在知识星球：dogyupi.com，欢迎加入</strong></p><ol><li>获取某个视频的评论 ✔</li><li><strong>实时</strong> 感知到评论的变化（定时去抓屏）-<ol><li><strong>设计算法（顺序、去重、不丢失）</strong>：</li><li>去重：<strong>rpid</strong></li><li>顺序：从接口拿来的数据本来就是按最新shi</li><li>不丢失：提高抓取的频率（不太建议）</li><li><strong>不能太频繁</strong>：定时 10 秒更新</li></ol></li><li>能够把评论输出到其他平台（网页）✔</li></ol><p>技术选型：</p><p>后端：Node.js + Express  + axios 请求库 + socket.io 实时通讯，nodemon 热更新</p><p>前端：JavaScript + moment.js</p><p>socket + websocket</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE%20-%20%E8%87%AA%E5%AA%92%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <url>/chaserblog/2024/04/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%B1%BC%E7%9A%AE%20-%20%E8%87%AA%E5%AA%92%E4%BD%93%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员鱼皮-自媒体经验分享"><a href="#程序员鱼皮-自媒体经验分享" class="headerlink" title="程序员鱼皮 - 自媒体经验分享"></a>程序员鱼皮 - 自媒体经验分享</h1><h2 id="环节一"><a href="#环节一" class="headerlink" title="环节一"></a>环节一</h2><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><p>知识区 &#x2F; 科技区 &#x3D;&gt; 计算机 &#x2F; 编程知识 UP，分享在职程序员 &amp; 自媒体创作（两大脱发职业）的经历和干货</p><h3 id="2-拍摄介绍"><a href="#2-拍摄介绍" class="headerlink" title="2. 拍摄介绍"></a>2. 拍摄介绍</h3><p>设备</p><ul><li>摄像头：罗技 Stream Cam</li><li>拍摄：<ul><li>日常：手机足够</li><li>vlog：大疆 pocket 2</li><li>高清视频：相机索尼 a7c</li></ul></li><li>麦克风<ul><li>直播：罗技 Blue Yeti</li><li>录制：Rode Wireless Go II</li></ul></li><li>幕布</li><li>打光<ul><li>桌面打光灯</li><li>落地打光灯</li></ul></li><li>前期可以用提词器</li></ul><p>硬件</p><ul><li>Mac or Windows 电脑均可</li></ul><p>软件</p><ul><li>必剪（做封面）</li><li>剪映</li><li>PR（之前用的多，后来很少用了）</li><li>爱提词</li></ul><h3 id="3-做-UP-有意思的事-——-带节奏、一起快乐"><a href="#3-做-UP-有意思的事-——-带节奏、一起快乐" class="headerlink" title="3. 做 UP 有意思的事 —— 带节奏、一起快乐"></a>3. 做 UP 有意思的事 —— 带节奏、一起快乐</h3><ol><li>直播写代码翻车（让大家集中注意力、无痛学编程）</li><li>网站被攻击（激励大家学习编程、同时感受到网络攻击的危害）</li><li>评论区人才辈出</li></ol><h2 id="环节二"><a href="#环节二" class="headerlink" title="环节二"></a>环节二</h2><h3 id="1-个人创作经历-——-五个阶段"><a href="#1-个人创作经历-——-五个阶段" class="headerlink" title="1. 个人创作经历 —— 五个阶段"></a>1. 个人创作经历 —— 五个阶段</h3><h4 id="1-1-短视频-起因：激励自己准备面试"><a href="#1-1-短视频-起因：激励自己准备面试" class="headerlink" title="1.1 短视频 - 起因：激励自己准备面试"></a>1.1 短视频 - 起因：激励自己准备面试</h4><p>看一道面试题，录一道，一天 3 - 5 期，录了 100 多个视频只有 100 个粉丝。</p><h4 id="1-2-短视频-起因：想试试"><a href="#1-2-短视频-起因：想试试" class="headerlink" title="1.2 短视频 - 起因：想试试"></a>1.2 短视频 - 起因：想试试</h4><p>别人的经历能有那么多点赞？我的经历也挺励志，也值得给大家分享！</p><p>分享了自己大学四年的经历。</p><p>第一次直播的经历（20 多个人聊了半个多小时）</p><p>理念：通过短视频帮大家快速了解某个技术、让知识变得有趣</p><h4 id="1-3-文字创作-公众号-起因：想有个地方写文章、兴趣"><a href="#1-3-文字创作-公众号-起因：想有个地方写文章、兴趣" class="headerlink" title="1.3 文字创作 - 公众号 - 起因：想有个地方写文章、兴趣"></a>1.3 文字创作 - 公众号 - 起因：想有个地方写文章、兴趣</h4><ul><li>一天一更，坚持了 1 个多月</li><li>观念转变，希望更多人看到，激励自己输出</li><li>知乎，每天回答 3 - 5 个问题</li><li>变现</li></ul><h4 id="1-4-中长视频-起因：合成大西瓜小爆款-B-站粘性高"><a href="#1-4-中长视频-起因：合成大西瓜小爆款-B-站粘性高" class="headerlink" title="1.4 中长视频 - 起因：合成大西瓜小爆款 &#x2F; B 站粘性高"></a>1.4 中长视频 - 起因：合成大西瓜小爆款 &#x2F; B 站粘性高</h4><ul><li>之前考虑没做是因为没做起来，时间也不够</li><li>持续做 B 站，氛围好、想做大、想得到大家的认可，排期 &#x3D;&gt; 不出稿难受</li><li>纠结：迎合流量还是专注技术？ &#x3D;&gt; 像稚晖君那样的结合？</li><li>成为习惯 &#x3D;&gt; 爱好</li></ul><h4 id="1-5-私域流量-知识星球"><a href="#1-5-私域流量-知识星球" class="headerlink" title="1.5 私域流量 - 知识星球"></a>1.5 私域流量 - 知识星球</h4><ul><li>粉丝多了后，很多想分享的知识并不适合去做视频分享，不如定制化地帮大家解决问题</li><li>想挑战不依赖第三方平台，打造自己的 IP</li><li>变现</li></ul><h4 id="做自媒体的契机"><a href="#做自媒体的契机" class="headerlink" title="做自媒体的契机"></a>做自媒体的契机</h4><p>自己的契机：兴趣 + 尝试 + 坚持</p><p>过程：随缘 &#x3D;&gt; 尝试 &#x3D;&gt; 兴趣 &#x3D;&gt; 正反馈驱动 &#x3D;&gt; 迷茫 &#x3D;&gt; 不服 &#x3D;&gt; 习惯 &#x3D;&gt; 爱好 &#x3D;&gt; 随缘</p><p>最适合做自媒体的人（没有压力、能持续发展的）：对自己的工作、技能感兴趣，并愿意将它分享给更多的同学。</p><h4 id="创作压力"><a href="#创作压力" class="headerlink" title="创作压力"></a>创作压力</h4><p>如何坚持高产？</p><ol><li>持续思考，认真观察，即时记录自己的灵感并持续发酵。不会为了想稿子而头疼。</li><li>持续做计划，大目标拆解</li><li>给自己找创作激励和正反馈（不行就多立 Flag）</li></ol><p>平衡工作和自媒体创作？</p><ul><li>最理想的状态是把自己工作中的发现、学到的技术进行分享。</li><li>自媒体创作是兴趣，不玩游戏，时间还是足够的</li><li>90% 的同学没时间的原因都是在玩游戏和回消息（水群），个人习惯：集中一个时间段回复，工作的时候认真回复。</li><li>放弃了午休，放弃了游戏，放弃了一些出去玩  &#x2F; 聊天的机会、熬夜，创造每周第 8 天</li></ul><p>会缺乏动力么？</p><ul><li>会，这时要给自己找点刺激</li><li>心态要随缘，刻意会不持久</li></ul><p>同事知道自己做 UP 是怎样的感受？</p><ul><li>替我担心：你不要再吐槽公司了，很危险啊！</li></ul><h3 id="2-如何做有趣有料的干货内容？"><a href="#2-如何做有趣有料的干货内容？" class="headerlink" title="2. 如何做有趣有料的干货内容？"></a>2. 如何做有趣有料的干货内容？</h3><h4 id="2-1-焦虑"><a href="#2-1-焦虑" class="headerlink" title="2.1 焦虑"></a>2.1 焦虑</h4><p>数据：会焦虑，会和别人对比 <del>，一度怀疑自己被限流，我现在依然怀疑</del></p><p>涨粉：不会焦虑，更多关注内容</p><p>从来没有把自媒体当成任务，但依然会有流量焦虑。主要的焦虑是其他 UP 主带来的，太卷了。</p><h4 id="2-2-内容质量的把控"><a href="#2-2-内容质量的把控" class="headerlink" title="2.2 内容质量的把控"></a>2.2 内容质量的把控</h4><p>希望每期视频都能给大家带来一些知识，而不是纯粹的搞笑或闲聊。哪怕是网站被攻击，也能给大家带来一些收获~</p><ul><li>好玩、有趣</li><li>真实、共鸣</li><li>要留下一些东西（知识点、一个作品）</li><li>精简、突出主旨</li></ul><h4 id="2-3-分享干货的套路"><a href="#2-3-分享干货的套路" class="headerlink" title="2.3 分享干货的套路"></a>2.3 分享干货的套路</h4><ol><li>真实最重要，纵观自己和全网，越真实、越自然，越容易爆火。被喷是很正常的，从你做 UP 主开始，就应该做好心理准备。我不会排斥某些内容，他能上热门一定有它的道理，思考背后的原因。</li><li>摸清观众的心理，比如编程深度知识或完整教程，真正要看这些内容的人会主动搜索、或者不需要你来把文字稿整成视频；应该用轻松的方式，让大家在主线学习之余，零碎时间了解新知识。领悟过程一方面是发现自己随着粉丝的增长、受众越来越小白化，更要注重知识的通俗易懂；另一方面是看数据和大家的评论反馈。向大流量区学习。</li><li>不要去跟某一领域更专业的人竞争，比如培训机构（我不会出自己的完整课程）</li></ol><h4 id="2-4-给新人-UP-主的创作建议"><a href="#2-4-给新人-UP-主的创作建议" class="headerlink" title="2.4 给新人 UP 主的创作建议"></a>2.4 给新人 UP 主的创作建议</h4><ul><li>创作<ul><li>随时记录，随时找灵感，不是硬着头皮写稿子</li><li>调研已有视频，分析做得好与不好的地方</li><li>多关注同类 UP 主，学习经验</li><li>有趣 &gt; 干货（优化稿子：去除废话、加一些梗，剪辑时加一些搞笑的动图、搞笑的音乐</li><li>持续产出，而不是三天打鱼两天晒网，坚持才能成功！</li></ul></li><li>如何增加曝光与点击<ul><li>发布时间选择</li><li>标题</li><li>封面</li><li>标签</li><li>活动</li><li>推广（创作激励）</li><li>社群 &#x2F; 私域流量分享</li><li>前期内容在尽可能多的平台发布</li><li>写简介</li><li>引导三连</li><li>评论区的互动</li></ul></li><li>转化<ul><li>有意引导点赞三连</li><li>引流</li><li>制造期待（下期内容，留下自己的标签）</li></ul></li></ul><h3 id="3-意义和未来打算"><a href="#3-意义和未来打算" class="headerlink" title="3. 意义和未来打算"></a>3. 意义和未来打算</h3><h4 id="3-1-给自己的收获"><a href="#3-1-给自己的收获" class="headerlink" title="3.1 给自己的收获"></a>3.1 给自己的收获</h4><ul><li>快乐</li><li>充实和满足</li><li>收益</li><li>尝试和挑战</li><li>有了一定发声的权利</li><li>项目更容易推广，自己给自己打广告</li><li>认识更多有趣的人</li><li>顺应时代，不掉队</li><li>帅气的光头 🧑‍🦲</li></ul><h4 id="3-2-给大家的帮助和沉淀"><a href="#3-2-给大家的帮助和沉淀" class="headerlink" title="3.2 给大家的帮助和沉淀"></a>3.2 给大家的帮助和沉淀</h4><ul><li>新人入门</li><li>大家的正向反馈（找到工作之类的）</li><li>留下自己的作品</li></ul><h4 id="3-3-未来打算"><a href="#3-3-未来打算" class="headerlink" title="3.3 未来打算"></a>3.3 未来打算</h4><p>走一步算一步吧，继续把自媒体当做爱好，干好本职工作，学习更多技能</p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"/>
    <url>/chaserblog/2024/04/28/%E6%98%9F%E7%90%83%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="用户中心直播笔记（完整版）"><a href="#用户中心直播笔记（完整版）" class="headerlink" title="用户中心直播笔记（完整版）"></a>用户中心直播笔记（完整版）</h1><p>目标：完整了解做项目的思路，接触一些企业级的开发技术，让大家之后都能轻松做出管理系统！</p><h3 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h3><p>用户中心前端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-frontend">http://gitlab.code-nav.cn/root/user-center-frontend</a></p><p>用户中心后端项目源码：<a href="http://gitlab.code-nav.cn/root/user-center-backend">http://gitlab.code-nav.cn/root/user-center-backend</a></p><h2 id="企业做项目流程"><a href="#企业做项目流程" class="headerlink" title="企业做项目流程"></a>企业做项目流程</h2><p>需求分析 &#x3D;&gt; 设计（概要设计、详细设计）&#x3D;&gt; 技术选型 &#x3D;&gt; 初始化 &#x2F; 引入需要的技术 &#x3D;&gt; 写 Demo &#x3D;&gt; 写代码（实现业务逻辑） &#x3D;&gt; 测试（单元测试、系统测试）&#x3D;&gt; 代码提交 &#x2F; 代码评审 &#x3D;&gt; 部署 &#x3D;&gt; 发布上线</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>登录 &#x2F; 注册</li><li>用户管理（仅管理员可见）对用户的查询或者修改</li><li>用户校验（仅星球用户可见）</li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前端：三件套 + React + 组件库 Ant Design + Umi + Ant Design Pro（现成的管理系统）</p><p>后端：</p><ul><li>java</li><li>spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）</li><li>springmvc（web 框架，提供接口访问、restful接口等能力）</li><li>mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）</li><li>mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）</li><li>springboot（<strong>快速启动</strong> &#x2F; 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）</li><li>junit 单元测试库</li><li>mysql 数据库</li></ul><p>部署：服务器 &#x2F; 容器（平台）</p><h2 id="3-种初始化-Java-项目的方式"><a href="#3-种初始化-Java-项目的方式" class="headerlink" title="3 种初始化 Java 项目的方式"></a>3 种初始化 Java 项目的方式</h2><ol><li>GitHub 搜现成的代码</li><li>SpringBoot 官方的模板生成器（<a href="https://start.spring.io/%EF%BC%89">https://start.spring.io/）</a></li><li>直接在 IDEA 开发工具中生成  ✔</li></ol><p>如果要引入 java 的包，可以去 maven 中心仓库寻找（<a href="http://mvnrepository.com/%EF%BC%89">http://mvnrepository.com/）</a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>什么是数据库？存数据的</p><p>数据库里有什么？数据表（理解为 excel 表格）</p><p>java 操作数据库？程序代替人工</p><h3 id="什么是设计数据库表？"><a href="#什么是设计数据库表？" class="headerlink" title="什么是设计数据库表？"></a>什么是设计数据库表？</h3><p>有哪些表（模型）？表中有哪些字段？字段的类型？数据库字段添加索引？表与表之间的关联？</p><p>举例：性别是否需要加索引？</p><h3 id="用户表设计"><a href="#用户表设计" class="headerlink" title="用户表设计"></a>用户表设计</h3><p>id（主键）bigint</p><p>username 昵称  varchar</p><p>userAccount 登录账号 </p><p>avatarUrl 头像 varchar</p><p>gender 性别 tinyint</p><p>userPassword 密码  varchar</p><p>phone 电话 varchar</p><p>email 邮箱 varchar</p><p>userStatus 用户状态 int  0 - 正常 </p><p>createTime 创建时间（数据插入时间）datetime</p><p>updateTime 更新时间（数据更新时间）datetime</p><p>isDelete 是否删除 0 1（逻辑删除）tinyint</p><p>userRole 用户角色 0 - 普通用户 1 - 管理员</p><h3 id="自动生成器的使用"><a href="#自动生成器的使用" class="headerlink" title="自动生成器的使用"></a>自动生成器的使用</h3><p>MyBatisX 插件，自动根据数据库生成：</p><ul><li>domain：实体对象</li><li>mapper：操作数据库的对象</li><li>mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL</li><li>service：包含常用的增删改查</li><li>serviceImpl：具体实现 service</li></ul><p>从而提高开发效率！</p><h2 id="注册逻辑设计"><a href="#注册逻辑设计" class="headerlink" title="注册逻辑设计"></a>注册逻辑设计</h2><ol><li>用户在前端输入账户和密码、以及校验码（todo）</li><li>校验用户的账户、密码、校验密码，是否符合要求<ol><li>非空</li><li>账户长度 <strong>不小于</strong> 4 位</li><li>密码就 <strong>不小于</strong> 8 位吧</li><li>账户不能重复</li><li>账户不包含特殊字符</li><li>密码和校验密码相同</li></ol></li><li>对密码进行加密（密码千万不要直接以明文存储到数据库中）</li><li>向数据库插入用户数据</li></ol><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>接受参数：用户账户、密码</p><p>请求类型：POST </p><p>请求体：JSON 格式的数据</p><blockquote><p>请求参数很长时不建议用 get</p></blockquote><p>返回值：用户信息（ <strong>脱敏</strong> ）</p><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><ol><li><p>校验用户账户和密码是否合法</p><ol><li>非空</li><li>账户长度不小于 4 位</li><li>密码就不小于 8 位</li><li>账户不包含特殊字符</li></ol></li><li><p>校验密码是否输入正确，要和数据库中的密文密码去对比</p></li><li><p>用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露</p></li><li><p>我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器 tomcat 去记录）</p><p>cookie</p></li><li><p>返回脱敏后的用户信息</p></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>控制层 Controller 封装请求</p><p>application.yml 指定接口全局路径前缀：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">servlet</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">context-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><p>控制器注解：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@RestController</span> 适用于编写 restful 风格的 api，返回值默认为 json 类型<br></code></pre></td></tr></table></figure><p>校验写在哪里？</p><ul><li>controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好）</li><li>service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）</li></ul><h3 id="如何知道是哪个用户登录了？"><a href="#如何知道是哪个用户登录了？" class="headerlink" title="如何知道是哪个用户登录了？"></a>如何知道是哪个用户登录了？</h3><blockquote><p>javaweb 这一块的知识</p></blockquote><ol><li><p>连接服务器端后，得到一个 session 状态（匿名会话），返回给前端</p></li><li><p>登录成功后，得到了登录成功的 session，并且给该sessio n设置一些值（比如用户信息），返回给前端一个设置 cookie 的 ”命令“ </p><p><strong>session &#x3D;&gt; cookie</strong> </p></li><li><p>前端接收到后端的命令后，设置 cookie，保存到浏览器内</p></li><li><p>前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求</p></li><li><p>后端拿到前端传来的 cookie，找到对应的 session</p></li><li><p>后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）</p></li></ol><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>接口设计关键：必须鉴权！！！</p><ol><li>查询用户（允许根据用户名查询）</li><li>删除用户</li></ol><h2 id="写代码流程"><a href="#写代码流程" class="headerlink" title="写代码流程"></a>写代码流程</h2><ol><li>先做设计</li><li>代码实现</li><li>持续优化！！！（复用代码、提取公共逻辑 &#x2F; 常量）</li></ol><h2 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h2><p>前端需要向后端发送请求才能获取数据 &#x2F; 执行操作。</p><p>怎么发请求：前端使用 ajax 来请求后端</p><h3 id="前端请求库及封装关系"><a href="#前端请求库及封装关系" class="headerlink" title="前端请求库及封装关系"></a>前端请求库及封装关系</h3><ul><li><p>axios 封装了 ajax</p></li><li><p>request 是 ant design 项目又封装了一次</p></li></ul><p>追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>正向代理：替客户端向服务器发送请求，可以解决跨域问题</p><p>反向代理：替服务器统一接收请求。</p><p>怎么实现代理？</p><ul><li>Nginx 服务器</li><li>Node.js 服务器</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>原本请求：<a href="http://localhost:8000/api/user/login">http://localhost:8000/api/user/login</a></p><p>代理到请求：<a href="http://localhost:8080/api/user/login">http://localhost:8080/api/user/login</a></p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220319005859098.png"></p><h2 id="前端框架介绍"><a href="#前端框架介绍" class="headerlink" title="前端框架介绍"></a>前端框架介绍</h2><h3 id="Ant-Design-Pro（Umi-框架）权限管理"><a href="#Ant-Design-Pro（Umi-框架）权限管理" class="headerlink" title="Ant Design Pro（Umi 框架）权限管理"></a>Ant Design Pro（Umi 框架）权限管理</h3><ul><li>app.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息）</li><li>access.ts 控制用户的访问权限</li></ul><p>获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回值就是全局可用的状态值。</p><h3 id="ProComponents-高级表单"><a href="#ProComponents-高级表单" class="headerlink" title="ProComponents 高级表单"></a>ProComponents 高级表单</h3><ol><li>通过 columns 定义表格有哪些列</li><li>columns 属性<ul><li>dataIndex 对应返回数据对象的属性</li><li>title 表格列名</li><li>copyable 是否允许复制</li><li>ellipsis 是否允许缩略</li><li>valueType：用于声明这一列的类型（dateTime、select）</li></ul></li></ol><h3 id="框架关系"><a href="#框架关系" class="headerlink" title="框架关系"></a>框架关系</h3><p>Ant Design 组件库 &#x3D;&gt; 基于 React 实现</p><p>Ant Design Procomponents &#x3D;&gt; 基于 Ant Design 实现</p><p>Ant Design Pro 后台管理系统 &#x3D;&gt; 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现</p><h3 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h3><p>MFSU：前端编译优化</p><h2 id="后端优化"><a href="#后端优化" class="headerlink" title="后端优化"></a>后端优化</h2><h3 id="通用返回对象"><a href="#通用返回对象" class="headerlink" title="通用返回对象"></a>通用返回对象</h3><p>目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败</p><p>200、404、500、502、503</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br>↓<br><br><span class="hljs-comment">// 成功</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yupi&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><br><span class="hljs-comment">// 错误</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50001</span> <span class="hljs-comment">// 业务状态码</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户操作异常、xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>自定义错误码，返回类支持返回正常和错误</p><h3 id="封装全局异常处理器"><a href="#封装全局异常处理器" class="headerlink" title="封装全局异常处理器"></a>封装全局异常处理器</h3><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ol><li><p>定义业务异常类</p><ol><li>相对于 java 的异常类，支持更多字段</li><li>自定义构造函数，更灵活 &#x2F; 快捷的设置字段</li></ol></li><li><p>编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）</p></li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 &#x2F; 信息</li><li>同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）</li><li>集中处理，比如记录日志</li></ol><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><blockquote><p>直播的 0：00 - 0：35 为踩坑过程，可跳过</p></blockquote><h3 id="全局响应处理"><a href="#全局响应处理" class="headerlink" title="全局响应处理"></a>全局响应处理</h3><p>应用场景：我们需要对接口的 <strong>通用响应</strong> 进行统一处理，比如从 response 中取出 data；或者根据 code 去集中处理错误，比如用户未登录、没权限之类的。</p><p>优势：不用在每个接口请求中都去写相同的逻辑</p><p>实现：参考你用的请求封装工具的官方文档，比如 umi-request（<a href="https://github.com/umijs/umi-request#interceptor%E3%80%81https://blog.csdn.net/huantai3334/article/details/116780020%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%94%A8">https://github.com/umijs/umi-request#interceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用</a> <strong>axios</strong>，参考 axios 的文档。</p><p>创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类。</p><h2 id="用户校验"><a href="#用户校验" class="headerlink" title="用户校验"></a>用户校验</h2><blockquote><p>仅适用于用户可信的情况</p></blockquote><p>先让用户自己填：2 - 5 位编号，全凭自觉。</p><p>后台补充对编号的校验：长度校验、唯一性校验</p><p>前端补充输入框，适配后端。</p><blockquote><p>后期拉取星球数据，定期清理违规用户</p></blockquote><h2 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_41701290/article/details/120173283">https://blog.csdn.net/weixin_41701290/article/details/120173283</a></p><p>本地开发：localhost（127.0.0.1）</p><p>多环境：指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上。</p><p>为什么需要？</p><ol><li>每个环境互不影响</li><li>区分不同的阶段：开发 &#x2F; 测试 &#x2F; 生产</li><li>对项目进行优化：<ol><li>本地日志级别</li><li>精简依赖，节省项目体积</li><li>项目的环境 &#x2F; 参数可以调整，比如 JVM 参数</li></ol></li></ol><p>针对不同环境做不同的事情。</p><p>多环境分类：</p><ol><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）大家连同一台机器，为了大家开发方便</li><li>测试环境（测试）开发 &#x2F; 测试 &#x2F; 产品，单元测试 &#x2F; 性能测试 &#x2F; 功能测试 &#x2F; 系统集成测试，独立的数据库、独立的服务器</li><li>预发布环境（体验服）：和正式环境一致，正式数据库，更严谨，查出更多问题</li><li>正式环境（线上，公开对外访问的项目）：尽量不要改动，保证上线前的代码是 “完美” 运行</li><li>沙箱环境（实验环境）：为了做实验</li></ol><h3 id="前端多环境实战"><a href="#前端多环境实战" class="headerlink" title="前端多环境实战"></a>前端多环境实战</h3><ul><li><p>请求地址</p><ul><li><p>开发环境：localhost:8000</p></li><li><p>线上环境：user-backend.code-nav.cn</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">startFront</span>(<span class="hljs-params">env</span>) &#123;<br>    <span class="hljs-keyword">if</span>(env === <span class="hljs-string">&#x27;prod&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 不输出注释 </span><br>        <span class="hljs-comment">// 项目优化</span><br>        <span class="hljs-comment">// 修改请求地址</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 保持本地开发逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用了 umi 框架，build 时会自动传入 NODE_ENV &#x3D;&#x3D; production 参数，start NODE_ENV 参数为 development</p></li><li><p>启动方式</p><ul><li>开发环境：npm run start（本地启动，监听端口、自动更新）</li><li>线上环境：npm run build（项目构建打包），可以使用 serve 工具启动（npm i -g serve）</li></ul></li><li><p>项目的配置</p><p>不同的项目（框架）都有不同的配置文件，umi 的配置文件是 config，可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境。参考文档：<a href="https://umijs.org/zh-CN/docs/deployment">https://umijs.org/zh-CN/docs/deployment</a></p><ul><li>开发环境：config.dev.ts</li><li>生产环境：config.prod.ts</li><li>公共配置：config.ts 不带后缀</li></ul></li></ul><h3 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h3><p>SpringBoot 项目，通过 application.yml 添加不同的后缀来区分配置文件</p><p>可以在启动项目时传入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar .\user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>主要是改：</p><ul><li><p>依赖的环境地址</p><ul><li><p>数据库地址</p></li><li><p>缓存地址</p></li><li><p>消息队列地址</p></li><li><p>项目端口号</p></li></ul></li><li><p>服务器配置</p></li></ul><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>参考文章：<a href="https://www.bilibili.com/read/cv16179200">https://www.bilibili.com/read/cv16179200</a></p><p>需要 Linux 服务器（建议大家用 CentOS 8+ &#x2F; 7.6 以上）</p><h3 id="原始部署"><a href="#原始部署" class="headerlink" title="原始部署"></a>原始部署</h3><p>什么都自己装</p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>需要 web 服务器：<strong>nginx</strong> 、apache、tomcat</p><p>安装 nginx 服务器：</p><ol><li><p>用系统自带的软件包管理器快速安装，比如 centos 的 yum</p></li><li><p>自己到官网安装（参考文章）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o nginx-1.21.6.tar.gz http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>   37  2022-04-17 23:30:09 yum install pcre pcre-devel -y<br>   39  2022-04-17 23:30:59 yum install openssl openssl-devel -y<br>   41  2022-04-17 23:31:57 ./configure --with-http_ssl_module --with-http_v2_module --with-stream<br>   42  2022-04-17 23:32:13 make<br>   43  2022-04-17 23:32:54 make install<br>   48  2022-04-17 23:33:40 <span class="hljs-built_in">ls</span> /usr/local/nginx/sbin/nginx<br>   vim /etc/profile<br>  在最后一行添加：<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/nginx/sbin<br>  <br>  nginx<br>  <br>  netstat -ntlp 查看启动情况<br></code></pre></td></tr></table></figure><p>注意 nginx 权限</p></li></ol><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><p>java、maven</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y java-1.8.0-openjdk*<br><br>curl -o apache-maven-3.8.5-bin.tar.gz https://dlcdn.apache.org/maven/maven-3/3.8.5/binaries/apache-maven-3.8.5-bin.tar.gz<br><br>git <span class="hljs-built_in">clone</span> xxx 下载代码<br><br>打包构建，跳过测试<br>mvn package -DskipTests<br><br>java -jar ./user-center-backend-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><h3 id="宝塔-Linux-部署"><a href="#宝塔-Linux-部署" class="headerlink" title="宝塔 Linux 部署"></a>宝塔 Linux 部署</h3><p>Linux 运维面板</p><p>官方安装教程：<a href="https://www.bt.cn/new/download.html">https://www.bt.cn/new/download.html</a></p><p>方便管理服务器、方便安装软件</p><h3 id="前端托管"><a href="#前端托管" class="headerlink" title="前端托管"></a>前端托管</h3><p>前端腾讯云 web 应用托管（比容器化更傻瓜式，不需要自己写构建应用的命令，就能启动前端项目）</p><blockquote><p><a href="https://console.cloud.tencent.com/webify/new">https://console.cloud.tencent.com/webify/new</a></p></blockquote><ul><li>小缺点：需要将代码放到代码托管平台上</li><li>优势：不用写命令、代码更新时自动构建</li></ul><h3 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h3><p>docker 是容器，可以将项目的环境（比如 java、nginx）和项目的代码一起打包成镜像，所有同学都能下载镜像，更容易分发和移植。</p><p>再启动项目时，不需要敲一大堆命令，而是直接下载镜像、启动镜像就可以了。</p><p>docker 可以理解为软件安装包。</p><p>Docker 安装：<a href="https://www.docker.com/get-started/">https://www.docker.com/get-started/</a> 或者宝塔安装</p><p>Dockerfile 用于指定构建 Docker 镜像的方法</p><p>Dockerfile 一般情况下不需要完全从 0 自己写，建议去 github、gitee 等托管平台参考同类项目（比如 springboot）</p><p>Dockerfile 编写：</p><ul><li>FROM 依赖的基础镜像</li><li>WORKDIR 工作目录</li><li>COPY 从本机复制文件</li><li>RUN 执行命令</li><li>CMD &#x2F; ENTRYPOINT（附加额外参数）指定运行容器时默认执行的命令</li></ul><p>根据 Dockerfile 构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后端</span><br>docker build -t user-center-backend:v0.0.1 .<br><br><span class="hljs-comment"># 前端</span><br>docker build -t user-center-front:v0.0.1 .<br></code></pre></td></tr></table></figure><p>Docker 构建优化：减少尺寸、减少构建时间（比如多阶段构建，可以丢弃之前阶段不需要的内容）</p><p>docker run 启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前端</span><br>docker run -p 80:80 -d user-center-frontend:v0.0.1<br><br><span class="hljs-comment"># 后端</span><br>docker run -p 8080:8080 user-center-backend:v0.0.1<br></code></pre></td></tr></table></figure><p>虚拟化</p><ol><li>端口映射：把本机的资源（实际访问地址）和容器内部的资源（应用启动端口）进行关联</li><li>目录映射：把本机的端口和容器应用的端口进行关联</li></ol><p>进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t  fee2bbb7c9ee /bin/bash<br></code></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <br></code></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs -f [container-id]<br></code></pre></td></tr></table></figure><p>杀死容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>强制删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi -f<br></code></pre></td></tr></table></figure><h3 id="Docker-平台部署"><a href="#Docker-平台部署" class="headerlink" title="Docker 平台部署"></a>Docker 平台部署</h3><ol><li>云服务商的容器平台（腾讯云、阿里云）</li><li>面向某个领域的容器平台（前端 &#x2F; 后端微信云托管）<strong>要花钱！</strong></li></ol><p>容器平台的好处：</p><ol><li>不用输命令来操作，更方便省事</li><li>不用在控制台操作，更傻瓜式、更简单</li><li>大厂运维，比自己运维更省心</li><li>额外的能力，比如监控、告警、其他（存储、负载均衡、自动扩缩容、流水线）</li></ol><p>爽就完事了！！！</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>前端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器（把网址解析为 ip 地址 &#x2F; 交给其他的域名解析服务） &#x3D;&gt; 服务器 &#x3D;&gt;（防火墙）&#x3D;&gt; nginx 接收请求，找到对应的文件，返回文件给前端 &#x3D;&gt; 前端加载文件到浏览器中（js、css） &#x3D;&gt; 渲染页面</p><p>后端项目访问流程：用户输入网址 &#x3D;&gt; 域名解析服务器 &#x3D;&gt; 服务器 &#x3D;&gt; nginx 接收请求 &#x3D;&gt; 后端项目（比如 8080端口）</p><p>nginx 反向代理的作用：替服务器接收请求，转发请求</p><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2><p>浏览器为了用户的安全，仅允许向 <strong>同域名、同端口</strong> 的服务器发送请求。</p><p>如何解决跨域？</p><p>最直接的方式：把域名、端口改成相同的</p><h3 id="添加跨域头"><a href="#添加跨域头" class="headerlink" title="添加跨域头"></a>添加跨域头</h3><p>让服务器告诉浏览器：允许跨域（返回 cross-origin-allow 响应头）</p><h4 id="1-网关支持（Nginx）"><a href="#1-网关支持（Nginx）" class="headerlink" title="1. 网关支持（Nginx）"></a>1. 网关支持（Nginx）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /api/ &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080/api/;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>    <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="hljs-string">&#x27;true&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-variable">$http_origin</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="hljs-string">&#x27;GET, POST, OPTIONS&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="hljs-number">1728000</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Type&#x27;</span> <span class="hljs-string">&#x27;text/plain; charset=utf-8&#x27;</span>;<br>        <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Content-Length&#x27;</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">204</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改后端服务"><a href="#2-修改后端服务" class="headerlink" title="2. 修改后端服务"></a>2. 修改后端服务</h4><ol><li><p>配置 @CrossOrigin 注解</p></li><li><p>添加 web 全局请求拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfg</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//设置允许跨域的路径</span><br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置允许跨域请求的域名</span><br>                <span class="hljs-comment">//当**Credentials为true时，**Origin不能为星号，需为具体的ip地址【如果接口不带cookie,ip无需设成具体ip】</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://localhost:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:9527&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8082&quot;</span>, <span class="hljs-string">&quot;http://127.0.0.1:8083&quot;</span>)<br>                <span class="hljs-comment">//是否允许证书 不再默认开启</span><br>                .allowCredentials(<span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//设置允许的方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;*&quot;</span>)<br>                <span class="hljs-comment">//跨域允许时间</span><br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义新的 corsFilter Bean，参考：<a href="https://www.jianshu.com/p/b02099a435bd">https://www.jianshu.com/p/b02099a435bd</a></p></li></ol><h2 id="项目优化点"><a href="#项目优化点" class="headerlink" title="项目优化点"></a>项目优化点</h2><ol><li>功能扩充<ol><li>管理员创建用户、修改用户信息、删除用户</li><li>上传头像</li><li>按照更多的条件去查询用户</li><li>更改权限</li></ol></li><li>修改 Bug</li><li>项目登录改为分布式 session（单点登录 - redis）</li><li>通用性<ol><li>set-cookie domain 域名更通用，比如改为 *.xxx.com</li><li>把用户管理系统 &#x3D;&gt; 用户中心（之后所有的服务都请求这个后端）</li></ol></li><li>后台添加全局请求拦截器（统一去判断用户权限、统一记录请求日志）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E9%B1%BC%E6%B3%A1%20-%20%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E9%B1%BC%E6%B3%A1%20-%20%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="鱼泡-伙伴匹配系统"><a href="#鱼泡-伙伴匹配系统" class="headerlink" title="鱼泡 - 伙伴匹配系统"></a>鱼泡 - 伙伴匹配系统</h1><p>介绍：帮助大家找到志同道合的伙伴，移动端 H5 网页（尽量兼容 PC 端）</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>用户去添加标签，标签的分类（要有哪些标签、怎么把标签进行分类）学习方向 java &#x2F; c++，工作 &#x2F; 大学</li><li>主动搜索：允许用户根据标签去搜索其他用户<ol><li>Redis 缓存</li></ol></li><li>组队<ol><li>创建队伍</li><li>加入队伍</li><li>根据标签查询队伍</li><li>邀请其他人</li></ol></li><li>允许用户去修改标签</li><li>推荐<ol><li>相似度计算算法 + 本地分布式计算</li></ol></li></ol><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue 3 开发框架（提高页面开发的效率）</li><li>Vant UI（基于 Vue 的移动端组件库）（React 版 Zent）</li><li>Vite 2（打包工具，快！）</li><li>Nginx 来单机部署</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java 编程语言 + SpringBoot 框架</li><li>SpringMVC + MyBatis + MyBatis Plus（提高开发效率）</li><li>MySQL 数据库</li><li>Redis 缓存</li><li>Swagger + Knife4j 接口文档</li></ol><h2 id="第一期计划"><a href="#第一期计划" class="headerlink" title="第一期计划"></a>第一期计划</h2><ol><li>前端项目初始化 15 min √</li><li>前端主页 + 组件概览 15 min √</li><li>数据库表设计 15 min √<ol><li>标签表</li><li>用户表</li></ol></li><li>初始化后端项目</li><li>开发后端 - 根据标签搜索用户 30 min</li><li>开发前端 - 根据标签搜索用户 20 min</li></ol><h2 id="前端项目初始化"><a href="#前端项目初始化" class="headerlink" title="前端项目初始化"></a>前端项目初始化</h2><p>用脚手架初始化项目</p><ul><li>Vue CLI <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li><li><strong>Vite 脚手架</strong> ：<a href="https://vitejs.cn/guide/#scaffolding-your-first-vite-project">https://vitejs.cn/guide/#scaffolding-your-first-vite-project</a></li></ul><p>整合组件库 Vant：</p><ul><li>安装 Vant</li><li>按需引入 npm i <a href="mailto:&#x76;&#x69;&#x74;&#x65;&#45;&#x70;&#108;&#117;&#103;&#105;&#110;&#x2d;&#x73;&#116;&#121;&#x6c;&#101;&#45;&#x69;&#109;&#112;&#x6f;&#114;&#116;&#x40;&#x31;&#46;&#x34;&#46;&#49;">&#x76;&#x69;&#x74;&#x65;&#45;&#x70;&#108;&#117;&#103;&#105;&#110;&#x2d;&#x73;&#116;&#121;&#x6c;&#101;&#45;&#x69;&#109;&#112;&#x6f;&#114;&#116;&#x40;&#x31;&#46;&#x34;&#46;&#49;</a> -D</li></ul><p>开发页面经验：</p><ol><li>多参考</li><li>从整体到局部</li><li>先想清楚页面要做成什么样子，再写代码</li></ol><h2 id="前端主页-组件概览-15-min"><a href="#前端主页-组件概览-15-min" class="headerlink" title="前端主页 + 组件概览 15 min"></a>前端主页 + 组件概览 15 min</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>导航条：展示当前页面名称</p><p>主页搜索框 &#x3D;&gt; 搜索页 &#x3D;&gt; 搜索结果页（标签筛选页）</p><p>内容</p><p>tab 栏：</p><ul><li>主页（推荐页 + <strong>广告</strong> ）<ul><li>搜索框</li><li>banner</li><li>推荐信息流</li></ul></li><li>队伍页</li><li>用户页（消息 - 暂时考虑发邮件）</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>很多页面要复用组件 &#x2F; 样式，重复写很麻烦、不利于维护，所以抽象一个通用的布局（Layout）</p><p>组件化</p><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p>标签的分类（要有哪些标签、怎么把标签进行分类）</p><h3 id="新增标签表（分类表）"><a href="#新增标签表（分类表）" class="headerlink" title="新增标签表（分类表）"></a>新增标签表（分类表）</h3><p>建议用标签，不要用分类，更灵活。</p><p>性别：男、女</p><p>方向：Java、C++、Go、前端</p><p>正在学：Spring</p><p>目标：考研、春招、秋招、社招、考公、竞赛（蓝桥杯）、转行、跳槽</p><p>段位：初级、中级、高级、王者</p><p>身份：小学、初中、高中、大一、大二、大三、大四、学生、待业、已就业、研一、研二、研三</p><p>状态：乐观、有点丧、一般、单身、已婚、有对象</p><p><strong>【用户自己定义标签】？</strong></p><p>字段：</p><p>id int 主键</p><p>标签名 varchar 非空（必须唯一，唯一索引）</p><p>上传标签的用户 userId int（如果要根据 userId 查已上传标签的话，最好加上，普通索引）</p><p>父标签 id ，parentId，int（分类）</p><p>是否为父标签 isParent, tinyint（0 不是父标签、1 - 父标签）</p><p>创建时间 createTime，datetime</p><p>更新时间 updateTime，datetime</p><p>是否删除 isDelete， tinyint（0、1）</p><p>怎么查询所有标签，并且把标签分好组？按父标签 id 分组，能实现 √</p><p>根据父标签查询子标签？根据 id 查询，能实现 √</p><p>SQL 语言分类：</p><p>DDL define 建表、操作表</p><p>DML manage 更新删除数据，影响实际表里的内容</p><p>DCL control 控制，权限</p><p>DQL query 查询，select</p><p><a href="https://www.cnblogs.com/fan-yuan/p/7879353.html">https://www.cnblogs.com/fan-yuan/p/7879353.html</a></p><h3 id="修改用户表"><a href="#修改用户表" class="headerlink" title="修改用户表"></a>修改用户表</h3><p>用户有哪些标签？</p><p><strong>根据自己的实际需求来！！！</strong> 此处选择第一种</p><ol><li><p>直接在用户表补充 tags 字段，**[‘Java’, ‘男’] 存 json 字符串 ** </p><p>优点：查询方便、不用新建关联表，标签是用户的固有属性（除了该系统、其他系统可能要用到，标签是用户的固有属性）节省开发成本</p><p><strong>查询用户列表，查关系表拿到这 100 个用户有的所有标签 id，再根据标签 id 去查标签表。</strong></p><p>哪怕性能低，可以用缓存。</p><p>缺点：用户表多一列，会有点</p></li><li><p>加一个关联表，记录用户和标签的关系</p><p>关联表的应用场景：查询灵活，可以正查反查</p><p>缺点：要多建一个表、多维护一个表</p><p>重点：企业大项目开发中尽量减少关联查询，很影响扩展性，而且会影响查询性能</p></li></ol><h3 id="开发后端接口"><a href="#开发后端接口" class="headerlink" title="开发后端接口"></a>开发后端接口</h3><h4 id="搜索标签"><a href="#搜索标签" class="headerlink" title="搜索标签"></a>搜索标签</h4><ol><li>允许用户传入多个标签，多个标签都存在才搜索出来 and。like ‘%Java%’ and like ‘%C++%’。</li><li>允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like ‘%Java%’ or like ‘%C++%’</li></ol><p>两种方式：</p><ol><li>SQL 查询（实现简单，可以通过拆分查询进一步优化）</li><li>内存查询（灵活，可以通过并发进一步优化）</li></ol><ul><li><p>如果参数可以分析，根据用户的参数去选择查询方式，比如标签数</p></li><li><p>如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁。</p></li><li><p>还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag</p></li></ul><p>建议通过实际测试来分析哪种查询比较快，数据量大的时候验证效果更明显！</p><p>解析 JSON 字符串：</p><p>序列化：java对象转成 json</p><p>反序列化：把 json 转为 java 对象</p><p>java  json 序列化库有很多：</p><ol><li><p><strong>gson</strong>（google 的）</p></li><li><p>fastjson alibaba（ali 出品，快，但是漏洞太多）</p></li><li><p>jackson</p></li><li><p>kryo</p></li></ol><h2 id="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"><a href="#用户中心来集中提供用户的检索、操作、注册、登录、鉴权" class="headerlink" title="用户中心来集中提供用户的检索、操作、注册、登录、鉴权"></a>用户中心来集中提供用户的检索、操作、注册、登录、鉴权</h2><h2 id="中-2022-05-29"><a href="#中-2022-05-29" class="headerlink" title="中 2022-05-29"></a>中 2022-05-29</h2><p>本次直播内容（计划）： </p><ol><li><strong>上次的标签接口调试</strong> 5 min √</li><li>前端整合路由 5min √</li><li>前端开发（搜索页面、用户信息页、用户信息修改页）30 - 50min √</li><li>后端整合 Swagger + Knife4j 接口文档 10 - 15min</li><li>存量用户信息导入及同步（爬虫） 40 min</li></ol><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ol><li>stream &#x2F; parallelStream 流失处理</li><li>Optional 可选类</li></ol><h3 id="前端整合路由"><a href="#前端整合路由" class="headerlink" title="前端整合路由"></a>前端整合路由</h3><p>Vue-Router：<a href="https://router.vuejs.org/zh/guide/#html%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%BC%95%E5%85%A5">https://router.vuejs.org/zh/guide/#html，直接看官方文档引入</a></p><p>Vue-Router 其实就是帮助你根据不同的 url 来展示不同的页面（组件），不用自己写 if &#x2F; else</p><p>路由配置影响整个项目，所以建议单独用 config 目录、单独的配置文件去集中定义和管理。</p><p>有些组件库可能自带了和 Vue-Router 的整合，所以尽量先看组件文档、省去自己写的时间。</p><h2 id="下-2022-06-05"><a href="#下-2022-06-05" class="headerlink" title="下 2022-06-05"></a>下 2022-06-05</h2><ol><li>Java 后端整合 Swagger + Knife4j 接口文档 10 min √</li><li>存量用户信息导入及同步（爬虫） 30 min - 40 min</li><li></li><li>前后端联调：搜索页面、用户信息页、用户信息修改页 30 - 40 min</li><li>标签内容整理 15 min</li><li>部分细节优化  todo</li></ol><h2 id="后端整合-Swagger-Knife4j-接口文档"><a href="#后端整合-Swagger-Knife4j-接口文档" class="headerlink" title="后端整合 Swagger + Knife4j 接口文档"></a>后端整合 Swagger + Knife4j 接口文档</h2><p>什么是接口文档？写接口信息的文档，每条接口包括：</p><ul><li>请求参数</li><li>响应参数<ul><li>错误码</li></ul></li><li>接口地址</li><li>接口名称</li><li>请求类型</li><li>请求格式</li><li>备注</li></ul><p>who 谁用？一般是后端或者负责人来提供，后端和前端都要使用</p><p>为什么需要接口文档？</p><ul><li>有个书面内容（背书或者归档），便于大家参考和查阅，便于 <strong>沉淀和维护</strong> ，拒绝口口相传</li><li>接口文档便于前端和后端开发对接，前后端联调的 <strong>介质</strong> 。后端 &#x3D;&gt; 接口文档 &lt;&#x3D; 前端</li><li>好的接口文档支持在线调试、在线测试，可以作为工具提高我们的开发测试效率</li></ul><p>怎么做接口文档？</p><ul><li>手写（比如腾讯文档、Markdown 笔记）</li><li>自动化接口文档生成：自动根据项目代码生成完整的文档或在线调试的网页。Swagger，Postman（侧重接口管理）（国外）；apifox、apipost、eolink（国产）</li></ul><p>接口文档有哪些技巧？</p><p>Swagger 原理：</p><ol><li>引入依赖（Swagger 或 Knife4j：<a href="https://doc.xiaominfo.com/knife4j/documentation/get_start.html%EF%BC%89">https://doc.xiaominfo.com/knife4j/documentation/get_start.html）</a></li><li>自定义 Swagger 配置类</li><li>定义需要生成接口文档的代码位置（Controller）</li><li>千万注意：线上环境不要把接口暴露出去！！！可以通过在 SwaggerConfig 配置文件开头加上 <code>@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</code> 限定配置仅在部分环境开启</li><li>启动即可</li><li>可以通过在 controller 方法上添加 @Api、@ApiImplicitParam(name &#x3D; “name”,value &#x3D; “姓名”,required &#x3D; true)    @ApiOperation(value &#x3D; “向客人问好”) 等注解来自定义生成的接口描述信息</li></ol><p>如果 springboot version &gt;&#x3D; 2.6，需要添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><p>todo 怎么隐藏</p><h2 id="存量用户信息导入及同步"><a href="#存量用户信息导入及同步" class="headerlink" title="存量用户信息导入及同步"></a>存量用户信息导入及同步</h2><ol><li>把所有星球用户的信息导入</li><li>把写了自我介绍的同学的标签信息导入</li></ol><p>FeHelper 前端辅助插件，推荐安装</p><h3 id="看上了网页信息，怎么抓到？"><a href="#看上了网页信息，怎么抓到？" class="headerlink" title="看上了网页信息，怎么抓到？"></a>看上了网页信息，怎么抓到？</h3><ol><li>分析原网站是怎么获取这些数据的？哪个接口？</li></ol><p>按 F 12 打开控制台，查看网络请求，复制 curl 代码便于查看和执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;https://api.zsxq.com/v2/hashtags/48844541281228/topics?count=20&quot;</span> ^<br>  -H <span class="hljs-string">&quot;authority: api.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept: application/json, text/plain, */*&quot;</span> ^<br>  -H <span class="hljs-string">&quot;accept-language: zh-CN,zh;q=0.9&quot;</span> ^<br>  -H <span class="hljs-string">&quot;cache-control: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;origin: https://wx.zsxq.com&quot;</span> ^<br>  -H <span class="hljs-string">&quot;pragma: no-cache&quot;</span> ^<br>  -H <span class="hljs-string">&quot;referer: https://wx.zsxq.com/&quot;</span> ^<br>  --compressed<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>用程序去调用接口</strong> （java okhttp httpclient &#x2F; python 都可以）</li><li>处理（清洗）一下数据，之后就可以写到数据库里</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>从 excel 中导入全量用户数据，<strong>判重</strong> 。 easy excel：<a href="https://alibaba-easyexcel.github.io/index.html">https://alibaba-easyexcel.github.io/index.html</a></li><li>抓取写了自我介绍的同学信息，提取出用户昵称、用户唯一 id、自我介绍信息</li><li>从自我介绍中提取信息，然后写入到数据库中</li></ol><h4 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h4><p>两种读对象的方式：</p><ol><li>确定表头：建立对象，和表头形成映射关系</li><li>不确定表头：每一行数据映射为 Map&lt;String, Object&gt;</li></ol><p>两种读取模式：</p><ol><li>监听器：先创建监听器、在读取文件时绑定监听器。单独抽离处理逻辑，代码清晰易于维护；一条一条处理，适用于数据量大的场景。</li><li>同步读：无需创建监听器，一次性获取完整数据。方便简单，但是数据量大时会有等待时常，也可能内存溢出。</li></ol><h2 id="2022-06-12-【4】"><a href="#2022-06-12-【4】" class="headerlink" title="2022-06-12 【4】"></a>2022-06-12 【4】</h2><ol><li>页面和功能开发<ol><li>搜索页面</li><li>用户信息</li><li>用户修改页面</li></ol></li><li>改造用户中心，把单机登录改为分布式 session 登录</li><li>标签的整理、细节的优化</li></ol><h3 id="前端页面跳转传值"><a href="#前端页面跳转传值" class="headerlink" title="前端页面跳转传值"></a>前端页面跳转传值</h3><ol><li>query &#x3D;&gt; url searchParams，url 后附加参数，传递的值长度有限</li><li>vuex（全局状态管理），搜索页将关键词塞到状态中，搜索结果页从状态取值</li></ol><h2 id="Session-共享"><a href="#Session-共享" class="headerlink" title="Session 共享"></a>Session 共享</h2><p>种 session 的时候注意范围，cookie.domain</p><p>比如两个域名：</p><p>aaa.yupi.com</p><p>bbb.yupi.com</p><p>如果要共享 cookie，可以种一个更高层的公共域名，比如 yupi.com</p><h3 id="为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？"><a href="#为什么服务器-A-登录后，请求发到服务器-B，不认识该用户？" class="headerlink" title="为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？"></a>为什么服务器 A 登录后，请求发到服务器 B，不认识该用户？</h3><p>用户在 A 登录，所以 session（用户登录信息）存在了 A 上</p><p>结果请求 B 时，B 没有用户信息，所以不认识。</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234247152.png"></p><p>解决方案：<strong>共享存储</strong> ，而不是把数据放到单台服务器的内存中</p><p><img src="https://qiniuyun.code-nav.cn/img/image-20220612234335539.png"></p><p>如何共享存储？</p><ol><li>Redis（基于内存的 K &#x2F; V 数据库）此处选择 Redis，因为用户信息读取 &#x2F; 是否登录的判断极其<strong>频繁</strong> ，Redis 基于内存，读写性能很高，简单的数据单机 qps 5w - 10w</li><li>MySQL </li><li>文件服务器 ceph</li></ol><h3 id="Session-共享实现"><a href="#Session-共享实现" class="headerlink" title="Session 共享实现"></a>Session 共享实现</h3><h4 id="1-安装-Redis"><a href="#1-安装-Redis" class="headerlink" title="1. 安装 Redis"></a>1. 安装 Redis</h4><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>windows 下载：</p><p>Redis 5.0.14 下载：</p><p>链接：<a href="https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg">https://pan.baidu.com/s/1XcsAIrdeesQAyQU2lE3cOg</a> </p><p>提取码：vkoi </p><p>redis 管理工具 quick redis：<a href="https://quick123.net/">https://quick123.net/</a></p><ol start="2"><li>引入 redis，能够操作 redis：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>引入 spring-session 和 redis 的整合，使得自动将 session 存储到 redis 中：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>修改 spring-session 存储配置 <code>spring.session.store-type</code></p><p>默认是 none，表示存储在单台服务器</p><p>store-type: redis，表示从 redis 读写 session</p></li></ol><p>JWT 的优缺点：<a href="https://zhuanlan.zhihu.com/p/108999941">https://zhuanlan.zhihu.com/p/108999941</a></p><h2 id="todo-待优化"><a href="#todo-待优化" class="headerlink" title="todo 待优化"></a>todo 待优化</h2><p>前端：动态展示页面标题、微调格式</p><h2 id="2022-07-03-伙伴匹配系统-5"><a href="#2022-07-03-伙伴匹配系统-5" class="headerlink" title="2022-07-03 伙伴匹配系统 5"></a>2022-07-03 伙伴匹配系统 5</h2><ol><li>用户修改页面前端、后端开发和联调</li></ol><h2 id="2022-07-17-伙伴匹配系统-6"><a href="#2022-07-17-伙伴匹配系统-6" class="headerlink" title="2022-07-17 伙伴匹配系统 6"></a>2022-07-17 伙伴匹配系统 6</h2><ol><li>开发主页（默认推荐和自己兴趣相当的用户）</li><li>优化主页的性能（缓存 + 定时任务 + 分布式锁）</li></ol><h3 id="开发主页"><a href="#开发主页" class="headerlink" title="开发主页"></a>开发主页</h3><p>最简单：直接 list 列表</p><p>模拟 1000 万个用户，再去查询</p><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><ol><li><p>用可视化界面：适合一次性导入、数据量可控</p></li><li><p>写程序：for 循环，建议分批，不要一把梭哈（可以用接口来控制）<strong>要保证可控、幂等，注意线上环境和测试环境是有区别的</strong></p><p>导入 1000 万条，for i 1000w</p></li><li><p>执行 SQL 语句：适用于小数据量</p></li></ol><h4 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h4><p>for 循环插入数据的问题：</p><ol><li>建立和释放数据库链接（批量查询解决）</li><li>for 循环是绝对线性的（并发）</li></ol><p>并发要注意执行的先后顺序无所谓，不要用到非并发类的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">16</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10000</span>));<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// <span class="hljs-meta">CPU</span> 密集型：分配的核心线程数 = <span class="hljs-meta">CPU</span> - <span class="hljs-number">1</span><br>// IO 密集型：分配的核心线程数可以大于 <span class="hljs-meta">CPU</span> 核数<br></code></pre></td></tr></table></figure><p>数据库慢？预先把数据查出来，放到一个更快读取的地方，不用再查数据库了。（缓存）</p><p>预加载缓存，定时更新缓存。（定时任务）</p><p>多个机器都要执行任务么？（分布式锁：控制同一时间只有一台机器去执行定时任务，其他机器不用重复执行了）</p><h2 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h2><p>用缓存：提前把数据取出来保存好（通常保存到读写更快的介质，比如内存），就可以更快地读写。</p><h3 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h3><ul><li>Redis（分布式缓存）</li><li>memcached（分布式）</li><li>Etcd（云原生架构的一个分布式存储，<strong>存储配置</strong>，扩容能力）</li></ul><hr><ul><li><p>ehcache（单机）</p></li><li><p>本地缓存（Java 内存 Map）</p></li><li><p>Caffeine（Java 内存缓存，高性能）</p></li><li><p>Google Guava</p></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote><p>NoSQL 数据库</p></blockquote><p>key - value 存储系统（区别于 MySQL，他存储的是键值对）</p><h3 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h3><p>String 字符串类型： name: “yupi”</p><p>List 列表：names: [“yupi”, “dogyupi”, “yupi”]</p><p>Set 集合：names: [“yupi”, “dogyupi”]（值不能重复）</p><p>Hash 哈希：nameAge: {  “yupi”: 1, “dogyupi”: 2 }</p><p>Zset 集合：names: {  yupi - 9,   dogyupi - 12  }（适合做排行榜）</p><hr><p>bloomfilter（布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截）</p><p>geo（计算地理位置）</p><p>hyperloglog（pv &#x2F; uv）</p><p>pub &#x2F; sub（发布订阅，类似消息队列）</p><p>BitMap （1001010101010101010101010101）</p><h3 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yupi.yupao.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTemplateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(connectionFactory);<br>        redisTemplate.setKeySerializer(RedisSerializer.string());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引入一个库时，先写测试类</p></blockquote><h3 id="Java-里的实现方式"><a href="#Java-里的实现方式" class="headerlink" title="Java 里的实现方式"></a>Java 里的实现方式</h3><h4 id="Spring-Data-Redis（推荐）"><a href="#Spring-Data-Redis（推荐）" class="headerlink" title="Spring Data Redis（推荐）"></a>Spring Data Redis（推荐）</h4><p>Spring Data：通用的数据访问框架，定义了一组 <strong>增删改查</strong> 的接口</p><p>mysql、redis、jpa</p><p><a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis">spring-data-redis</a></p><p>1）引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）配置 Redis 地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># redis 配置</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>独立于 Spring 操作 Redis 的 Java 客户端</p><p>要配合 Jedis Pool 使用</p><h4 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h4><p><strong>高阶</strong> 的操作 Redis 的 Java 客户端</p><p>异步、连接池</p><h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>分布式操作 Redis 的 Java 客户端，让你像在使用本地的集合一样操作 Redis（分布式 Redis 数据网格）</p><h4 id="JetCache"><a href="#JetCache" class="headerlink" title="JetCache"></a>JetCache</h4><p>对比</p><ol><li>如果你用的是 Spring，并且没有过多的定制化要求，可以用 Spring Data Redis，最方便</li><li>如果你用的不是 SPring，并且追求简单，并且没有过高的性能要求，可以用 Jedis + Jedis Pool</li><li>如果你的项目不是 Spring，并且追求高性能、高定制化，可以用 Lettuce，支持异步、连接池</li></ol><hr><ul><li>如果你的项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐用 redisson</li></ul><h3 id="设计缓存-key"><a href="#设计缓存-key" class="headerlink" title="设计缓存 key"></a>设计缓存 key</h3><p>不同用户看到的数据不同</p><p>systemId:moduleId:func:options（不要和别人冲突）</p><p>yupao:user:recommed:userId</p><p><strong>redis 内存不能无限增加，一定要设置过期时间！！！</strong></p><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>问题：第一个用户访问还是很慢（加入第一个老板），也能一定程度上保护数据库</p><p>缓存预热的优点：</p><ol><li>解决上面的问题，可以让用户始终访问很快</li></ol><p>缺点：</p><ol><li>增加开发成本（你要额外的开发、设计）</li><li>预热的时机和时间如果错了，有可能你缓存的数据不对或者太老</li><li>需要占用额外空间</li></ol><h4 id="怎么缓存预热？"><a href="#怎么缓存预热？" class="headerlink" title="怎么缓存预热？"></a>怎么缓存预热？</h4><ol><li>定时</li><li>模拟触发（手动触发）</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>用定时任务，每天刷新所有用户的推荐列表</p><p>注意点：</p><ol><li>缓存预热的意义（新增少、总用户多）</li><li>缓存的空间不能太大，要预留给其他缓存空间</li><li>缓存数据的周期（此处每天一次）</li></ol><blockquote><p>分析优缺点的时候，要打开思路，从整个项目从 0 到 1 的链路上去分析</p></blockquote><h3 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h3><ol><li><strong>Spring Scheduler（spring boot 默认整合了）</strong> </li><li>Quartz（独立于 Spring 存在的定时任务框架）</li><li>XXL-Job 之类的分布式任务调度平台（界面 + sdk）</li></ol><p>第一种方式：</p><ol><li>主类开启 @EnableScheduling</li><li>给要定时执行的方法添加 @Scheduling 注解，指定 cron 表达式或者执行频率</li></ol><p>不要去背 cron 表达式！！！！！</p><ul><li><a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li><a href="https://www.matools.com/crontab/">https://www.matools.com/crontab/</a></li></ul><hr><h3 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h3><p>为啥？</p><ol><li>浪费资源，想象 10000 台服务器同时 “打鸣”</li><li>脏数据，比如重复插入</li></ol><p><strong>要控制定时任务在同一时间只有 1 个服务器能执行。</strong></p><p>怎么做？</p><ol><li><p>分离定时任务程序和主程序，只在 1 个服务器运行定时任务。成本太大</p></li><li><p>写死配置，每个服务器都执行定时任务，但是只有 ip 符合配置的服务器才真实执行业务逻辑，其他的直接返回。成本最低；但是我们的 IP 可能是不固定的，把 IP 写的太死了</p></li><li><p>动态配置，配置是可以轻松的、很方便地更新的（<strong>代码无需重启</strong>），但是只有 ip 符合配置的服务器才真实执行业务逻辑。</p><ul><li>数据库</li><li>Redis</li><li>配置中心（Nacos、Apollo、Spring Cloud Config）</li></ul><p>问题：服务器多了、IP 不可控还是很麻烦，还是要人工修改</p></li><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑。坏处：增加成本；好处：不用手动配置，多少个服务器都一样。</p></li></ol><p><strong>单机就会存在单点故障。</strong></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</p><p>Java 实现锁：synchronized 关键字、并发包的类</p><p>问题：只对单个 JVM 有效</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>为啥需要分布式锁？</p><ol><li>有限资源的情况下，控制同一时间（段）只有某些线程（用户 &#x2F; 服务器）能访问到资源。</li><li>单个锁只对单个 JVM 有效</li></ol><h3 id="分布式锁实现的关键"><a href="#分布式锁实现的关键" class="headerlink" title="分布式锁实现的关键"></a>分布式锁实现的关键</h3><h4 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h4><p>怎么保证同一时间只有 1 个服务器能抢到锁？</p><p><strong>核心思想</strong> 就是：先来的人先把数据改成自己的标识（服务器 ip），后来的人发现标识已存在，就抢锁失败，继续等待。</p><p>等先来的人执行方法结束，把标识清空，其他的人继续抢锁。</p><p>MySQL 数据库：select for update 行级锁（最简单）</p><p>（乐观锁）</p><p>✔ Redis 实现：内存数据库，<strong>读写速度快</strong> 。支持 <strong>setnx</strong>、lua 脚本，比较方便我们实现分布式锁。</p><p>setnx：set if not exists 如果不存在，则设置；只有设置成功才会返回 true，否则返回 false</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>用完锁要释放（腾地方）√</p></li><li><p><strong>锁一定要加过期时间 √</strong></p></li><li><p>如果方法执行时间过长，锁提前过期了？</p><p>问题：</p><ol><li>连锁效应：释放掉别人的锁</li><li>这样还是会存在多个方法同时执行的情况</li></ol></li></ol><p>​解决方案：续期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!end)&#125;&#123;<br>    续期<br>&#125;)<br><br>end = <span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure><ol start="4"><li><p>释放锁的时候，有可能先判断出是自己的锁，但这时锁过期了，最后还是释放了别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子操作</span><br><span class="hljs-keyword">if</span>(get lock == A) &#123;<br>    <span class="hljs-comment">// set lock B</span><br>    del lock<br>&#125;<br></code></pre></td></tr></table></figure><p>Redis + lua 脚本实现</p></li><li><p>Redis 如果是集群（而不是只有一个 Redis），如果分布式锁的数据不同步怎么办？</p></li></ol><p><a href="https://blog.csdn.net/feiying0canglang/article/details/113258494">https://blog.csdn.net/feiying0canglang/article/details/113258494</a></p><h4 id="拒绝自己写！！！"><a href="#拒绝自己写！！！" class="headerlink" title="拒绝自己写！！！"></a>拒绝自己写！！！</h4><h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><p>Java 客户端，数据网格</p><p>实现了很多 Java 里支持的接口和数据结构</p><p>Redisson 是一个 java 操作 Redis 的客户端，<strong>提供了大量的分布式数据集来简化对 Redis 的操作和使用，可以让开发者像使用本地集合一样使用 Redis，完全感知不到 Redis 的存在。</strong></p><h4 id="2-种引入方式"><a href="#2-种引入方式" class="headerlink" title="2 种引入方式"></a>2 种引入方式</h4><ol><li>spring boot starter 引入（不推荐，版本迭代太快，容易冲突）<a href="https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter">https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter</a></li><li>直接引入：<a href="https://github.com/redisson/redisson#quick-start">https://github.com/redisson/redisson#quick-start</a></li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs setnx">// list，数据存在本地 JVM 内存中<br>List&lt;String&gt; list = new ArrayList&lt;&gt;();<br>list.add(&quot;yupi&quot;);<br>System.out.println(&quot;list:&quot; + list.get(0));<br><br>list.remove(0);<br><br>// 数据存在 redis 的内存中<br>RList&lt;String&gt; rList = redissonClient.getList(&quot;test-list&quot;);<br>rList.add(&quot;yupi&quot;);<br>System.out.println(&quot;rlist:&quot; + rList.get(0));<br>rList.remove(0);<br></code></pre></td></tr></table></figure><h3 id="定时任务-锁"><a href="#定时任务-锁" class="headerlink" title="定时任务  + 锁"></a>定时任务  + 锁</h3><ol><li>waitTime 设置为 0，只抢一次，抢不到就放弃</li><li>注意释放锁要写在 finally 中</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testWatchDog</span>()</span> &#123;<br>    RLock <span class="hljs-keyword">lock</span> = redissonClient.getLock(<span class="hljs-string">&quot;yupao:precachejob:docache:lock&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 只有一个线程能获取到锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>.tryLock(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-comment">// todo 实际要执行的方法</span><br>            doSomeThings();<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;getLock: &quot;</span> + Thread.currentThread().getId());<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(e.getMessage());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 只能释放自己的锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">lock</span>.isHeldByCurrentThread()) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;unLock: &quot;</span> + Thread.currentThread().getId());<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h3><blockquote><p>redisson 中提供的续期机制</p></blockquote><p>开一个监听线程，如果方法还没执行完，就帮你重置 redis 锁的过期时间。</p><p>原理：</p><ol><li>监听当前线程，默认过期时间是 30 秒，每 10 秒续期一次（补到 30 秒）</li><li>如果线程挂掉（注意 debug 模式也会被它当成服务器宕机），则不会续期</li></ol><p><a href="https://blog.csdn.net/qq_26222859/article/details/79645203">https://blog.csdn.net/qq_26222859/article/details/79645203</a></p><hr><p>Zookeeper 实现（不推荐）</p><h3 id="组队功能-1h"><a href="#组队功能-1h" class="headerlink" title="组队功能 1h"></a>组队功能 1h</h3><p>理解为王者荣耀</p><h4 id="理想的应用场景"><a href="#理想的应用场景" class="headerlink" title="理想的应用场景"></a>理想的应用场景</h4><p>我要跟别人一起参加竞赛或者做项目，可以发起队伍或者加入别人的队伍</p><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p><strong>用户创建队伍最多 5 个</strong></p></blockquote><p>展示队伍列表，根据名称搜索队伍  P0，信息流中不展示已过期的队伍</p><p>修改队伍信息 P0 ~ P1</p><p>用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是要有个上限  P0</p><blockquote><p>是否需要队长同意？筛选审批？</p></blockquote><p>用户可以退出队伍（如果队长退出，权限转移给第二早加入的用户 —— 先来后到） P1</p><p>队长可以解散队伍 P0</p><hr><p>分享队伍 &#x3D;》 邀请其他用户加入队伍 P1</p><p>业务流程：</p><ol><li>生成分享链接（分享二维码）</li><li>用户访问链接，可以点击加入</li></ol><p>队伍人满后发送消息通知 P1</p><h4 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h4><h5 id="1、创建队伍"><a href="#1、创建队伍" class="headerlink" title="1、创建队伍"></a>1、创建队伍</h5><p>用户可以 <strong>创建</strong> 一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数</p><p>聊天？</p><p>公开 或 private 或加密</p><p>信息流中不展示已过期的队伍</p></blockquote><ol><li>请求参数是否为空？</li><li>是否登录，未登录不允许创建</li><li>校验信息<ol><li>队伍人数 &gt; 1 且 &lt;&#x3D; 20</li><li>队伍标题 &lt;&#x3D; 20</li><li>描述 &lt;&#x3D; 512</li><li>status 是否公开（int）不传默认为 0（公开）</li><li>如果 status 是加密状态，一定要有密码，且密码 &lt;&#x3D; 32</li><li>超时时间 &gt; 当前时间</li><li>校验用户最多创建 5 个队伍</li></ol></li><li>插入队伍信息到队伍表</li><li>插入用户  &#x3D;&gt; 队伍关系到关系表</li></ol><h5 id="2、查询队伍列表"><a href="#2、查询队伍列表" class="headerlink" title="2、查询队伍列表"></a>2、查询队伍列表</h5><p>分页展示队伍列表，根据名称、最大人数等搜索队伍  P0，信息流中不展示已过期的队伍</p><ol><li>从请求参数中取出队伍名称等查询条件，如果存在则作为查询条件</li><li>不展示已过期的队伍（根据过期时间筛选）</li><li>可以通过某个<strong>关键词</strong>同时对名称和描述查询</li><li><strong>只有管理员才能查看加密还有非公开的房间</strong></li><li>关联查询已加入队伍的用户信息</li><li><strong>关联查询已加入队伍的用户信息（可能会很耗费性能，建议大家用自己写 SQL 的方式实现）</strong></li></ol><p><strong>实现方式</strong></p><p>1）自己写 SQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">// 1. 自己写 SQL<br>// 查询队伍和创建人的信息<br>// <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> team t <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">on</span> t.userId = u.id<br>// 查询队伍和已加入队伍成员的信息<br>// <span class="hljs-keyword">select</span> *<br>// <span class="hljs-keyword">from</span> team t<br>//         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> user_team ut <span class="hljs-keyword">on</span> t.id = ut.teamId<br>//         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">user</span> u <span class="hljs-keyword">on</span> ut.userId = u.id;<br></code></pre></td></tr></table></figure><h5 id="3-修改队伍信息"><a href="#3-修改队伍信息" class="headerlink" title="3. 修改队伍信息"></a>3. 修改队伍信息</h5><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者队伍的创建者可以修改</li><li>如果用户传入的新值和老值一致，就不用 update 了（可自行实现，降低数据库使用次数）</li><li><strong>如果队伍状态改为加密，必须要有密码</strong></li><li>更新成功</li></ol><h5 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4. 用户可以加入队伍"></a>4. 用户可以加入队伍</h5><p>其他人、未满、未过期，允许加入多个队伍，但是要有个上限  P0</p><ol><li>用户最多加入 5 个队伍</li><li>队伍必须存在，只能加入未满、未过期的队伍</li><li>不能加入自己的队伍，不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入的队伍是加密的，必须密码匹配才可以</li><li>新增队伍 - 用户关联信息</li></ol><p><strong>注意，一定要加上事务注解！！！！</strong></p><h5 id="5-用户可以退出队伍"><a href="#5-用户可以退出队伍" class="headerlink" title="5. 用户可以退出队伍"></a>5. 用户可以退出队伍</h5><p>请求参数：队伍 id</p><ol><li><p>校验请求参数</p></li><li><p>校验队伍是否存在</p></li><li><p>校验我是否已加入队伍</p></li><li><p>如果队伍</p><ol><li><p>只剩一人，队伍解散</p></li><li><p>还有其他人</p><ol><li><p>如果是队长退出队伍，权限转移给第二早加入的用户 —— 先来后到</p><blockquote><p>只用取 id 最小的 2 条数据</p></blockquote></li><li><p>非队长，自己退出队伍</p></li></ol></li></ol></li></ol><h5 id="6-队长可以解散队伍"><a href="#6-队长可以解散队伍" class="headerlink" title="6. 队长可以解散队伍"></a>6. 队长可以解散队伍</h5><p>请求参数：队伍 id</p><p>业务流程：</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验你是不是队伍的队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><h5 id="7-获取当前用户已加入的队伍"><a href="#7-获取当前用户已加入的队伍" class="headerlink" title="7. 获取当前用户已加入的队伍"></a>7. 获取当前用户已加入的队伍</h5><h5 id="8-获取当前用户创建的队伍"><a href="#8-获取当前用户创建的队伍" class="headerlink" title="8. 获取当前用户创建的队伍"></a>8. 获取当前用户创建的队伍</h5><p>复用 listTeam 方法，只新增查询条件，不做修改（开闭原则）</p><hr><h4 id="事务注解"><a href="#事务注解" class="headerlink" title="事务注解"></a>事务注解</h4><p>@Transactional(rollbackFor &#x3D; Exception.class)</p><p>要么数据操作都成功，要么都失败</p><h3 id="数据库表设计-1"><a href="#数据库表设计-1" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p>队伍表 team</p><p>字段：</p><ul><li>id 主键 bigint（最简单、连续，放 url 上比较简短，但缺点是爬虫）</li><li>name 队伍名称</li><li>description 描述</li><li>maxNum 最大人数</li><li>expireTime 过期时间</li><li>userId 创建人 id</li><li>status 0 - 公开，1 - 私有，2 - 加密</li><li>password 密码</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    name   <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>)                   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;队伍名称&#x27;</span>,<br>    description <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>)                      <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;描述&#x27;</span>,<br>    maxNum    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;最大人数&#x27;</span>,<br>    expireTime    datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;过期时间&#x27;</span>,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    status    <span class="hljs-type">int</span>      <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;0 - 公开，1 - 私有，2 - 加密&#x27;</span>,<br>    password <span class="hljs-type">varchar</span>(<span class="hljs-number">512</span>)                       <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>    <br>        createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;队伍&#x27;</span>;<br></code></pre></td></tr></table></figure><p>用户  - 队伍表 user_team</p><p>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>createTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_team<br>(<br>    id           <span class="hljs-type">bigint</span> auto_increment comment <span class="hljs-string">&#x27;id&#x27;</span><br>        <span class="hljs-keyword">primary</span> key,<br>    userId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;用户id&#x27;</span>,<br>    teamId            <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;队伍id&#x27;</span>,<br>    joinTime datetime  <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;加入时间&#x27;</span>,<br>    createTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    updateTime   datetime <span class="hljs-keyword">default</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">update</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>    isDelete     tinyint  <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>                 <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;是否删除&#x27;</span><br>)<br>    comment <span class="hljs-string">&#x27;用户队伍关系&#x27;</span>;<br></code></pre></td></tr></table></figure><p>两个关系：</p><ol><li>用户加了哪些队伍？</li><li>队伍有哪些用户？</li></ol><p>方式：</p><ol><li>建立用户 - 队伍关系表 teamId userId（便于修改，查询性能高一点，可以选择这个，不用全表遍历）</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段（便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍）</li></ol><h4 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h4><ol><li><p>请求参数名称 &#x2F; 类型和实体类不一样</p></li><li><p>有一些参数用不到，如果要自动生成接口文档，会增加理解成本</p></li><li><p>对个实体类映射到同一个对象</p></li></ol><h4 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h4><p>可能有些字段需要隐藏，不能返回给前端</p><p>或者有些字段某些方法是不关心的</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>库表设计 5 - 10min</p><p>增删改查 5 - 10 min</p><p>业务逻辑开发（P0）30 min</p><h2 id="2022-09-18-12-期"><a href="#2022-09-18-12-期" class="headerlink" title="2022-09-18 12 期"></a>2022-09-18 12 期</h2><ol><li>开发前端的功能<ol><li>搜索队伍 √</li><li>更新队伍（仅队伍的创始人可见） √</li><li>查看个人已加入队伍 √</li><li>查看个人创建的队伍 √</li><li>解散队伍 √</li><li>退出队伍 √</li></ol></li><li>随机匹配 30 - 40 min</li><li>完成之前的遗留问题 todo</li></ol><h3 id="前端不同页面怎么传递数据？"><a href="#前端不同页面怎么传递数据？" class="headerlink" title="前端不同页面怎么传递数据？"></a>前端不同页面怎么传递数据？</h3><ol><li><strong>url querystring（xxx?id&#x3D;1）</strong> 比较适用于页面跳转</li><li><strong>url（&#x2F;team&#x2F;:id，xxx&#x2F;1）</strong></li><li>hash (&#x2F;team#1)</li><li>localStorage</li><li><strong>context（全局变量，同页面或整个项目要访问公共变量）</strong></li></ol><h3 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h3><blockquote><p>为了帮大家更快地发现和自己兴趣相同的朋友</p></blockquote><p>匹配 1 个还是匹配多个？</p><p>答：匹配多个，并且按照匹配的相似度从高到低排序</p><p>怎么匹配？（根据什么匹配）</p><p>答：标签 tags</p><blockquote><p>还可以根据 user_team 匹配加入相同队伍的用户</p></blockquote><p>本质：找到有相似标签的用户</p><p>举例：</p><p>用户 A：[Java, 大一, 男]</p><p>用户 B：[Java, 大二, 男]</p><p>用户 C：[Python, 大二, 女]</p><p>用户 D：[Java, 大一, 女]</p><h4 id="1-怎么匹配"><a href="#1-怎么匹配" class="headerlink" title="1. 怎么匹配"></a>1. 怎么匹配</h4><ol><li>找到有共同标签最多的用户（TopN）</li><li>共同标签越多，分数越高，越排在前面</li><li>如果没有匹配的用户，随机推荐几个（降级方案）</li></ol><p>编辑距离算法：<a href="https://blog.csdn.net/DBC_121/article/details/104198838">https://blog.csdn.net/DBC_121/article/details/104198838</a></p><blockquote><p>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以变成字符串 2</p></blockquote><p>余弦相似度算法：<a href="https://blog.csdn.net/m0_55613022/article/details/125683937%EF%BC%88%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E5%B8%A6%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%A6%E4%BB%80%E4%B9%88%E6%96%B9%E5%90%91%E6%9C%80%E9%87%8D%E8%A6%81%EF%BC%8C%E6%80%A7%E5%88%AB%E7%9B%B8%E5%AF%B9%E6%AC%A1%E8%A6%81%EF%BC%89">https://blog.csdn.net/m0_55613022/article/details/125683937（如果需要带权重计算，比如学什么方向最重要，性别相对次要）</a></p><h4 id="2-怎么对所有用户匹配，取-TOP"><a href="#2-怎么对所有用户匹配，取-TOP" class="headerlink" title="2. 怎么对所有用户匹配，取 TOP"></a>2. 怎么对所有用户匹配，取 TOP</h4><p>直接取出所有用户，依次和当前用户计算分数，取 TOP N（54 秒）</p><p>优化方法：</p><ol><li><p>切忌不要在数据量大的时候循环输出日志（取消掉日志后 20 秒）</p></li><li><p>Map 存了所有的分数信息，占用内存</p><p>解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户（时间换空间）</p><p>e.g.【3, 4, 5, 6, 7】取 TOP 5，id 为 1 的用户就不用放进去了</p></li><li><p>细节：剔除自己 √</p></li><li><p>尽量只查需要的数据：</p><ol><li>过滤掉标签为空的用户 √</li><li>根据部分标签取用户（前提是能区分出来哪个标签比较重要）</li><li>只查需要的数据（比如 id 和 tags） √（7.0s）</li></ol></li><li><p>提前查？（定时任务）</p><ol><li>提前把所有用户给缓存（不适用于经常更新的数据）</li><li>提前运算出来结果，缓存（针对一些重点用户，提前缓存）</li></ol></li></ol><p>大数据推荐，比如说有几亿个商品，难道要查出来所有的商品？</p><p>难道要对所有的数据计算一遍相似度？</p><p>检索 &#x3D;&gt; 召回 &#x3D;&gt; 粗排 &#x3D;&gt; 精排 &#x3D;&gt; 重排序等等</p><p>检索：尽可能多地查符合要求的数据（比如按记录查）</p><p>召回：查询可能要用到的数据（不做运算）</p><p>粗排：粗略排序，简单地运算（运算相对轻量）</p><p>精排：精细排序，确定固定排位</p><h3 id="分表学习建议"><a href="#分表学习建议" class="headerlink" title="分表学习建议"></a>分表学习建议</h3><p>mycat、sharding sphere 框架</p><p>一致性 hash</p><h3 id="队伍操作权限控制"><a href="#队伍操作权限控制" class="headerlink" title="队伍操作权限控制"></a>队伍操作权限控制</h3><p>加入队伍： 仅非队伍创建人、且未加入队伍的人可见</p><p>更新队伍：仅创建人可见</p><p>解散队伍：仅创建人可见</p><p>退出队伍：创建人不可见，仅已加入队伍的人可见</p><p>加载骨架屏特效 ✔</p><p>解决：van-skeleton 组件</p><p>仅加入队伍和创建队伍的人能看到队伍操作按钮（listTeam 接口要能获取我加入的队伍状态） ✔</p><p>方案 1：前端查询我加入了哪些队伍列表，然后判断每个队伍 id 是否在列表中（前端要多发一次请求）</p><p>方案 2：在后端去做上述事情（推荐）</p><p>前端导航栏死【标题】问题 ✔</p><p>解决：使用 router.beforeEach，根据要跳转页面的 url 路径 匹配 config&#x2F;routes 配置的 title 字段。</p><h2 id="14-优化、上线"><a href="#14-优化、上线" class="headerlink" title="14 优化、上线"></a>14 优化、上线</h2><p>1、强制登录，自动跳转到登录页</p><p>解决：axios 全局配置响应拦截、并且添加重定向</p><p>2、区分公开和加密房间；加入有密码的房间，要指定密码</p><p>3、展示已加入队伍人数</p><p>4、重复加入队伍的问题（加锁、分布式锁）并发请求时可能出现问题</p><p><strong>分布式锁</strong></p><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><p>先区分多环境：前端区分开发和线上接口，后端 prod 改为用线上公网可访问的数据库</p><p>前端：Vercel（免费）</p><p><a href="https://vercel.com/">https://vercel.com/</a></p><p>后端：微信云托管（部署容器的平台，付费）</p><p><a href="https://cloud.weixin.qq.com/cloudrun/service">https://cloud.weixin.qq.com/cloudrun/service</a></p><p><strong>（免备案！！！）</strong></p><h2 id="如何改造成小程序？"><a href="#如何改造成小程序？" class="headerlink" title="如何改造成小程序？"></a>如何改造成小程序？</h2><p><strong>cordova、跨端开发框架 taro、uniapp</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习</title>
    <link href="/chaserblog/2024/04/28/%E9%B1%BC%E7%A5%A8-%E5%8F%91%E5%88%B8%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2024/04/28/%E9%B1%BC%E7%A5%A8-%E5%8F%91%E5%88%B8%E4%B8%AD%E5%BF%83%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="直播开发【发券系统】-鱼票"><a href="#直播开发【发券系统】-鱼票" class="headerlink" title="直播开发【发券系统】 鱼票"></a>直播开发【发券系统】 鱼票</h1><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>给星球的小伙伴发布一个兑换券，凭借兑换券可以充值积分。</strong></p><h4 id="传统思路"><a href="#传统思路" class="headerlink" title="传统思路"></a>传统思路</h4><p>在现有的系统上加功能？在同一个代码上去开发，或者就是该数据库。</p><hr><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>【腾讯文档】鱼票-发券中心项目流程图<br><a href="https://docs.qq.com/flowchart/DUGlDTmZja05MUW12">https://docs.qq.com/flowchart/DUGlDTmZja05MUW12</a></p><h4 id="发兑换券（可以理解为激活码）的系统"><a href="#发兑换券（可以理解为激活码）的系统" class="headerlink" title="发兑换券（可以理解为激活码）的系统"></a>发兑换券（可以理解为激活码）的系统</h4><ol><li>管理员<ol><li>创建兑换券（设置规则 —— <strong>一人一券</strong> &#x2F; 抢）</li><li>发券（设置数量、设置单个用户可以使用的次数）</li></ol></li><li>用户<ol><li>输入券码来兑换奖品</li><li>查看自己用过的券码</li></ol></li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol><li>Vue</li><li>Vite</li><li>Tencent UI</li></ol><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li>Java</li><li>SpringBoot + SSM + MyBatis Plus</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><ol><li>管理员 √<ol><li>创建兑换券，定义规则<ol><li>兑换券的名称</li><li>兑换券的描述</li><li>回调接口地址</li><li>回调接口信息（json）</li></ol></li><li>发券<ol><li>选择已经定义好的券</li><li>数量</li><li>开始时间</li><li>过期时间</li></ol></li><li>管理已发的券<ol><li>查看所有类型的券</li><li>查看每个券的发放情况</li></ol></li></ol></li><li>用户<ol><li>输入券码来兑换奖品</li><li>查看自己用过的券码</li></ol></li></ol><h3 id="Vue3-的几种事件传递方式"><a href="#Vue3-的几种事件传递方式" class="headerlink" title="Vue3 的几种事件传递方式"></a>Vue3 的几种事件传递方式</h3><ol><li>父组件通过 props 将方法传递给子组件</li><li>子组件直接 emit，触发父组件的事件</li></ol><h2 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h2><h3 id="设计库表"><a href="#设计库表" class="headerlink" title="设计库表"></a>设计库表</h3><h4 id="ticket（定义了一类券的信息）"><a href="#ticket（定义了一类券的信息）" class="headerlink" title="ticket（定义了一类券的信息）"></a>ticket（定义了一类券的信息）</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">id <span class="hljs-type">int</span> 主键<br>ticketName <span class="hljs-type">varchar</span> 券名称<br>ticketDesc <span class="hljs-type">varchar</span> 券描述<br>callbackUrl <span class="hljs-type">varchar</span> 回调地址,<br>callbackInfo <span class="hljs-type">text</span> 回调信息 <span class="hljs-type">json</span>,<br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="sendTicket（发券情况）"><a href="#sendTicket（发券情况）" class="headerlink" title="sendTicket（发券情况）"></a>sendTicket（发券情况）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-type">int</span> 主键<br>ticketId <span class="hljs-type">int</span> 券的类型<br>sendNum <span class="hljs-type">int</span> 发圈数量<br>sendStatus <span class="hljs-type">int</span> 发放状态（<span class="hljs-number">0</span> <span class="hljs-operator">-</span> 关闭，<span class="hljs-number">1</span> <span class="hljs-operator">-</span>开启）<br>expireTime <span class="hljs-type">date</span> 过期时间 <br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="ticketDetail（每张券的信息）"><a href="#ticketDetail（每张券的信息）" class="headerlink" title="ticketDetail（每张券的信息）"></a>ticketDetail（每张券的信息）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-type">int</span> 主键<br>ticketId <span class="hljs-type">int</span> 主键<br>sendTicketId <span class="hljs-type">int</span> 所属发券批次<br>token <span class="hljs-type">varchar</span> 券码<br>useStatus <span class="hljs-type">int</span> 使用状态 <span class="hljs-number">0</span> <span class="hljs-operator">-</span> 未使用 <span class="hljs-number">1</span><span class="hljs-operator">-</span> 已使用 <span class="hljs-number">2</span> <span class="hljs-operator">-</span> 使用失败<br>useInfo text 使用信息（用户自主输入）<br>useMessage text 用券情况信息 userId<br>useTime <span class="hljs-type">date</span> 使用时间<br>createTime <span class="hljs-type">date</span> 创建时间<br>updateTime <span class="hljs-type">date</span> 修改时间<br>deleteStatus tinyint 是否删除（逻辑删除）<br></code></pre></td></tr></table></figure><h4 id="创建券"><a href="#创建券" class="headerlink" title="创建券"></a>创建券</h4><p>校验券的信息</p><p>插入券</p><h4 id="发券"><a href="#发券" class="headerlink" title="发券"></a>发券</h4><ol><li>校验请求参数是否合法</li><li>校验这种券是否存在</li><li>创建发券批次信息</li><li>根据数量去创建多张券</li></ol><h3 id="优化发券-两个问题"><a href="#优化发券-两个问题" class="headerlink" title="优化发券 - 两个问题"></a>优化发券 - 两个问题</h3><ol><li>稳定性 —— 事务（可以解决不一致问题，保证原子性，要么都成功，要么都不成功）</li><li>性能 —— 多线程 &#x2F; 批量操作 - 减少重复创建连接</li></ol><blockquote><p>想要领取资料，跟着鱼皮直播做项目、1 对 1 交流答疑、和小伙伴一起交流学习的话：</p><p>欢迎加入鱼皮的编程星球 👉：<a href="http://dogyupi.com/">http://dogyupi.com</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>程序员鱼皮</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/chaserblog/2021/10/01/2022-03-24%20%E6%88%91%E7%9A%84%E7%BB%8F%E5%8E%86%20&amp;%20%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/"/>
    <url>/chaserblog/2021/10/01/2022-03-24%20%E6%88%91%E7%9A%84%E7%BB%8F%E5%8E%86%20&amp;%20%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="大学经历"><a href="#大学经历" class="headerlink" title="大学经历"></a>大学经历</h1><p>工作室</p><p>鹅厂工作</p><h2 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h2><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>不能完全跟着学校学</p><p>Java、MySQL</p><p>网站工作室 - html\css\js\响应式\Bootstrap</p><p>python\C#\java spring</p><p>国家级创新项目 —— 机会是自己争取的</p><p>3.73</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>前端 vue、jquery、组件库，做项目</p><p>后端 java spring、springmvc、mybatis</p><p>做项目去学习 —— 校园打卡系统（前端 + 后端）学生是否在教学楼（上网搜），很杂乱</p><p>5 家实习（大厂）<strong>实习僧</strong> </p><p>html\css\js，算法数据结构，全挂了</p><p>java 拿到了机会，珍惜机会（一般的公司）<strong>目标：java 后端</strong> （思考逻辑）</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>加入实验室，区块链项目、教材</p><p><strong>跳板</strong>     进入一家大点的互联网公司（字节跳动）</p><p>springcloud、socket、netty、dubbo、rpc、jvm、并发编程</p><p><strong>实习</strong> </p><p>不算裸辞（有备选方案）</p><h3 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h3><p>快速晋升，趁早准备，趁早做规划</p><h3 id="工作上半年"><a href="#工作上半年" class="headerlink" title="工作上半年"></a>工作上半年</h3><p>全身心</p><p>做任何事情，一定要朝着自己的目标来。看网上的经验 &#x2F; 知识，自学。</p><h2 id="大一，学编程做项目"><a href="#大一，学编程做项目" class="headerlink" title="大一，学编程做项目"></a>大一，学编程做项目</h2><p>要刷 OJ 的 &#x3D;&gt; 自学额外的编程语言（<strong>前端 \ python</strong> \ Android） 目标：<strong>写代码</strong> 、做出东西。（挤时间）</p><p><strong>做自己的项目：</strong></p><ol><li>一个算法（抢红包）</li><li>网站</li><li>APP</li><li>一个技术框架</li></ol><p>先百度 &#x3D;&gt; 问别人</p><p>把自己所有遇到的 bug 全部记录，收藏好， <strong>错题集</strong></p><p>学编程不要背，记忆的东西越少越好（第二大脑）。（考试前要背）</p><h2 id="大二、竞赛"><a href="#大二、竞赛" class="headerlink" title="大二、竞赛"></a>大二、竞赛</h2><p>做自己的项目 《&#x3D;》 参加比赛</p><p>计算机应用能力大赛（三等奖）2 次 （合作）吃亏了，完成</p><p>蓝桥杯（省二 * 2）友好 <strong>（一定要参加）</strong></p><p>三创赛（上海市二等奖）：拼团购物 APP + 网站，功能多，营销模式上（了解比赛的规则以及详细的打分机制）</p><p>挑战杯（大三上）国家级二等奖 上海市特等奖：合作，计算机真正的价值（多去尝试、多去找机会）</p><h2 id="大三、考研还是就业"><a href="#大三、考研还是就业" class="headerlink" title="大三、考研还是就业"></a>大三、考研还是就业</h2><p>外界的压力、长辈的压力、同龄人的压力、研究生认可度高一点、有一些岗位的硬性要求：算法（AI\NLP\CV）</p><p>就业 挣钱</p><p>趁早抓机会！！！！<strong>大二、大一多学技术</strong></p><h4 id="大二暑假找一个实习（时间不够、能力不够、没机会去）"><a href="#大二暑假找一个实习（时间不够、能力不够、没机会去）" class="headerlink" title="大二暑假找一个实习（时间不够、能力不够、没机会去）"></a>大二暑假找一个实习（时间不够、能力不够、没机会去）</h4><p><strong>想想你会什么、写简历、投递简历、去面试</strong></p><p><strong>兴趣</strong></p><p>转正（抓住眼前的机会）</p><p>《校招薪水》</p><h2 id="大四、求职-面试官最看重的"><a href="#大四、求职-面试官最看重的" class="headerlink" title="大四、求职 - 面试官最看重的"></a>大四、求职 - 面试官最看重的</h2><ol><li>写简历（项目经验 &#x2F; 实习经历）</li><li>逻辑思维（简历的项目介绍，用什么技术解决了什么问题）&#x3D;》自己做项目、多思考别人怎么做的、刷算法（做oj）</li><li>语言表达、做事认真（简历不能有错别字）</li><li>自主性、创新性</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>“《博客搭建相关》”</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
